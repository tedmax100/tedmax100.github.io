{"meta":{"title":"雷N's Blog","subtitle":"時間花在哪, 成就就在那. 充足的努力, 才能看起來毫不費力","description":"後端開發、軟體工程、運維佈署","author":"Nathan雷N","url":"https://tedmax100.github.io","root":"/"},"pages":[{"title":"about","date":"2019-07-14T07:18:51.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"about/index.html","permalink":"https://tedmax100.github.io/about/index.html","excerpt":"","text":"汪洋中的一位迷途攻城屍 個人學習筆記及讀書心得"},{"title":"categories","date":"2019-07-14T16:26:19.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"categories/index.html","permalink":"https://tedmax100.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Go_Context_電話蟲","slug":"Go-Context-電話蟲","date":"2020-12-21T13:26:53.000Z","updated":"2020-12-21T13:27:39.619Z","comments":true,"path":"2020/12/21/Go-Context-電話蟲/","link":"","permalink":"https://tedmax100.github.io/2020/12/21/Go-Context-電話蟲/","excerpt":"想像一下 如果用多個goroutine來處理一個請求, 那怎在這些goroutine之間共享request訊息. 每一個請求都應該要有個超時限制 處理超時, 設定3s後超時 在函數被調用的過程中, 還剩下多久才超時? 需要在哪裡存放這超時訊息 怎樣在請求過程處理中,使其停止? 更方便的控制goroutine的關閉, 如果不想多創造channel的話. ​","text":"想像一下 如果用多個goroutine來處理一個請求, 那怎在這些goroutine之間共享request訊息. 每一個請求都應該要有個超時限制 處理超時, 設定3s後超時 在函數被調用的過程中, 還剩下多久才超時? 需要在哪裡存放這超時訊息 怎樣在請求過程處理中,使其停止? 更方便的控制goroutine的關閉, 如果不想多創造channel的話. ​ ContextContext最常見的是上下文這詞來說明, 但其實應用上我們都只看上文.叫做語境可能更貼切.透過傳遞Context用來簡化對於處理單個請求的多個goroutine之間的資料共享、超時和退出等操作, 手動/超時等操作.當我們在做線程切換時, 就需要保存當前的狀況, 載入下一個線程需要的stack跟資料暫存器.這資料暫存器跟stack其實就是Context. 由於context能衍生出子context,所有能讓基於該context或其衍生的子context都會收到通知, 就能進行結束操作.最後釋放goroutine. 優雅的解決goroutine啟動之後難以控制的問題. 常見的有timeout、deadline 或 只是停止工作. Go提供了可以攜帶Value的context、可以取消的context和可以設置timeout的context. Context Interface1234567891011type Context interface &#123; // 獲取設置好的截止時間 ; 第二個bool返回值表示有沒有設置截止時間 Deadline() (deadline time.Time, ok bool) // 返回一個 readonly channel, 如果該channel可以被讀取, 表示parent context 發起了cancel請求, 就能透過Done方法收到訊號後, 作結束操作. Done() &lt;-chan struct&#123;&#125; // 返回取消的錯誤原因, 為什麼context被取消 Err() error // 讓goroutine共享資料, 透過獲得該Context上綁定的值, 是一組KV pair, 是thread safe的; // 不存在則返回nil Value(key interface&#123;&#125;) interface&#123;&#125;&#125; 建立root Context1234// 通常使用context.Background()作為樹的root, 該方法只會返回一個空的context// 就是接收請求用// 不可cancel, 沒有設置deadline 和帶任何value的contextctx := context.Background() 123// 如果在開發階段, 還不清楚是要怎麼用該context, 可以用TODO(), // 一樣是返回一個空的contextctx := context.TODO() 建立sub context這四個With方法, 都要接收一個parent context參數.能理解成sub context對parent context的繼承; 反過來說就是基於parent context的衍生.這樣層層下去就能創建一個context tree, 每個節點都能有任意個sub node, 層級也能有任意多個. 記得一定要呼叫cancel(), 不然會leak.能透過vet```指令來檢查有沒有leak.123456### WithValue```go// 透過這樣的方式建立一個可被取消的sub context, 然後當作參數傳給goroutine使用// func WithValue(parent Context, key, val interface&#123;&#125;) Contextctx := context.WithValue(context.Background(), key, \"test\") WithCancel12// func WithCancel(parent Context) (ctx Context, cancel CancelFunc)ctx, calcel := context.WithCancel(context.Background()) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package mainimport ( \"context\" \"log\" \"os\" \"time\")var logger *log.Loggervar key string = \"name\"func main() &#123; logger = log.New(os.Stdout, \"\", log.Ltime) // 建立一個cancel context ctx, cancel := context.WithCancel(context.Background()) // 建立數個withValue context, 繼承於ctx, 並給值 valueCtx := context.WithValue(ctx, key, 1) valueCtx2 := context.WithValue(ctx, key, 2) go watch(valueCtx) go watch(valueCtx2) time.Sleep(4 * time.Second) logger.Println(\"任務停止\") // 發出取消 cancel() // 確保工作結束 time.Sleep(1 * time.Second)&#125;func watch(ctx context.Context) &#123; for &#123; select &#123; case &lt;-ctx.Done(): //接收到取消訊號 logger.Println(\"任務\", ctx.Value(key), \":任務停止...\") return default: //取出值 var value int = ctx.Value(key).(int) logger.Println(\"任務\", ctx.Value(key), \":工作中\") time.Sleep(time.Duration(value) * time.Second) &#125; &#125;&#125;/*20:24:50 任務 1 :工作中20:24:50 任務 2 :工作中20:24:51 任務 1 :工作中20:24:52 任務 2 :工作中20:24:52 任務 1 :工作中20:24:53 任務 1 :工作中20:24:54 任務停止20:24:54 任務 2 :任務停止...20:24:54 任務 1 :任務停止...*/ WithDeadline12345// 跟WithCancel很像, 只是多個截止時間, 表示時間到了會自動取消context; // 傳入的不是duration而是確切時間// 但也能手動cancel// func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(2 * time.Second)) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( \"context\" \"log\" \"os\" \"time\")var logger *log.Loggerfunc do(ctx context.Context) &#123; if deadline, ok := ctx.Deadline(); ok == true &#123; logger.Println(\"deadline: \", deadline) &#125; for &#123; select &#123; case &lt;-ctx.Done(): // logger.Println(\"deadline is over\") logger.Println(ctx.Err()) return default: logger.Println(\"do\") time.Sleep(1 * time.Second) &#125; &#125;&#125;func main() &#123; logger = log.New(os.Stdout, \"\", log.Ltime) d := time.Now().Add(2 * time.Second) // 現在時間的2秒後的時間就是deadline ctx, cancel := context.WithDeadline(context.Background(), d) defer cancel() logger.Println(\"start\") go do(ctx) time.Sleep(3 * time.Second)&#125;/*21:20:25 start21:20:25 deadline: 2019-09-22 21:20:27.844274236 +0800 CST m=+2.00019728421:20:25 do21:20:26 do21:20:27 context deadline exceeded*/ WithTimeout123// 開始執行後多少時間自動取消context, 傳入的是duration// func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)ctx, cancel := context.WithTimeout(context.Background(), 2 * time.Second) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package mainimport ( \"context\" \"fmt\" \"log\" \"os\" \"time\")var logger *log.Loggerfunc doForever(ctx context.Context) &#123; for &#123; select &#123; case &lt;-ctx.Done(): logger.Println(ctx.Err()) return default: logger.Println(\"doForever\") time.Sleep(1 * time.Second) &#125; &#125;&#125;func do1second(ctx context.Context) &#123; select &#123; case &lt;-ctx.Done(): logger.Println(ctx.Err()) return default: time.Sleep(1 * time.Second) logger.Println(\"do1second\") &#125;&#125;func main() &#123; logger = log.New(os.Stdout, \"\", log.Ltime) // 建立一個timeout context, 3秒後沒返回就發出超時 ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second) defer cancel() logger.Println(\"start\") go doForever(ctx) go do1second(ctx) time.Sleep(4 * time.Second)&#125;/*21:10:55 start21:10:55 doForever21:10:56 doForever21:10:56 do1second21:10:57 doForever21:10:58 context deadline exceeded*/ Context Tree前面提到了建立sub context, 看看上下文樹的結構 12345678910// A cancelCtx can be canceled. When canceled, it also cancels any children// that implement canceler.type cancelCtx struct &#123; Context mu sync.Mutex // protects following fields done chan struct&#123;&#125; // created lazily, closed by first cancel call children map[canceler]struct&#123;&#125; // set to nil by the first cancel call err error // set to non-nil by the first cancel call&#125; chidren這屬性用來紀錄用此context所建立出來的sub context,同時Context屬性是當前的context. 123456789101112131415161718192021222324252627282930313233343536373839package mainimport \"context\"var cancelBefore = falsefunc main() &#123; c, cCancel := context.WithCancel(context.Background()) c1, cf1 := context.WithCancel(c) defer cf1() c2, cf2 := context.WithCancel(c) defer cf2() c11, cf11 := context.WithCancel(c1) defer cf11() c12, cf12 := context.WithCancel(c1) defer cf12() if cancelBefore &#123; cCancel() &#125; for k, c := range map[string]context.Context&#123;`c1`: c1, `c11`: c11, `c12`: c12, `c2`: c2&#125; &#123; var s string if c.Err() != nil &#123; s = `cancelled` &#125; else &#123; s = `not cancelled` &#125; println(k + ` is ` + s) &#125; if !cancelBefore &#123; cCancel() &#125;&#125; 每個context相互連結, 只要對C發出cancel, 所有屬於它的children context也將會被cancel. cancel123456789101112131415161718192021222324252627282930// cancel closes c.done, cancels each of c's children, and, if// removeFromParent is true, removes c from its parent's children.func (c *cancelCtx) cancel(removeFromParent bool, err error) &#123; if err == nil &#123; panic(\"context: internal error: missing cancel error\") &#125; c.mu.Lock() if c.err != nil &#123; c.mu.Unlock() return // already canceled &#125; c.err = err // 關閉done這個blocking channel if c.done == nil &#123; c.done = closedchan &#125; else &#123; close(c.done) &#125; // 這裡對每個children呼叫cancel for child := range c.children &#123; // NOTE: acquiring the child's lock while holding parent's lock. child.cancel(false, err) &#125; c.children = nil c.mu.Unlock() if removeFromParent &#123; removeChild(c.Context, c) &#125;&#125; 使用原則 不要把context放在struct成員之中, 應該要透過參數作傳遞; 但如果該struct本身也是方法的參數, 就可以. 變數名取為ctx, 且放在參數列的第一個, 返回也是. 在傳遞context時, 不要傳遞nil, 不然在trace追蹤時會斷鏈, 此時可以傳遞TODO() Context是thread safe的, 能放心的在各個goroutine之間傳遞 可以把一個context實例, 傳遞給任意數量的goroutine. context被cancel()時, 所有的goroutine都會接收到取消訊號. 使用情境1 : 全鍊路追蹤透過WithValue在請求的根埋入一組數據, key是生成好的TracId(用戶id).SpanId表示處理該trace的服務代碼, ParentId表示呼叫方的SpanId.透過這樣子的方式就能在http的接口端, 埋入對應資訊.彙整時, 只要對TraceId撈取, 對ParentId做排序, 就能得到一條完整的調用鏈紀錄. 使用情境2 : 對於耗時任務作主動性的取消, 即時的釋放資源最常見的就是使用time.After在select等待接收到資訊, 作任務的返回. 123456func Task() &#123; select &#123; case &lt;- time.After(2*time.Second): return &#125;&#125; 如果使用WithTimeout、WithDeadline、WithCancel就能把這取消的權力, 反轉過來變成是在調用方了.有沒有一種依賴反轉(IOC)的feel? 然後ctx作為參數用外部傳入(DI). 還有許多使用情境, 之後的範例應該會很常用到, 像是資料庫的慢查詢. Go Concurrency Patterns: Context Go Context 官方範例 Go vet 鐵人賽連結","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"},{"name":"iT邦鐵人賽11Th","slug":"iT邦鐵人賽11Th","permalink":"https://tedmax100.github.io/tags/iT邦鐵人賽11Th/"}]},{"title":"Go_Channel","slug":"Go-Channel","date":"2020-12-21T13:23:32.000Z","updated":"2020-12-21T13:24:23.918Z","comments":true,"path":"2020/12/21/Go-Channel/","link":"","permalink":"https://tedmax100.github.io/2020/12/21/Go-Channel/","excerpt":"Channelchannel能夠在多個goroutine之間作數據交換, 任何時間, 同時只能有一個goroutine來存取通道進行發送或獲取資料. Channel就像是一個輸送帶, 遵守著FIFO的規則, 保證收發資料的順序.​","text":"Channelchannel能夠在多個goroutine之間作數據交換, 任何時間, 同時只能有一個goroutine來存取通道進行發送或獲取資料. Channel就像是一個輸送帶, 遵守著FIFO的規則, 保證收發資料的順序.​通道就像是在捷運等公共場所很多人的情況下, 大家在遵守著排隊的習慣, 目的是避免擁擠、插隊導致的低效資源使用與交換過程.多個goroutine為了搶奪存取資料, 勢必造成執行效率的低下, 使用queue是一種高效率的同步存取方式, channel就是一種queue一樣的結構. var 通道名稱 chan 通道類型 chan的空值是nil 聲明完通道後, 要透過make來產生實例 通道實例 := make(chan 通類類型, [bufferSize int]), 晚點會講解有沒有加上buffer size的使用差別 發送資料 &lt;- , 通道變數 &lt;- 值 接收資料 阻塞式接收 資料變數 := &lt;- 通道變數 非阻塞式接收 資料變數, ok := &lt;- 通道變數 ok : 表示是否收到資料 接收後忽略 &lt;- 通道變數 執行到這句會變成阻塞, 直到收到資料, 但收到的資料會被忽略 最常用在goroutine間阻塞式地收發實現併發同步. 用for range 進行多個資料的接收 相較於阻塞式, 會造成較高的CPU佔用. 如果需要超時檢測, 可配合select和計時器channel使用. Ex 1 : 無緩衝通道的併發列印, 發布者與訂閱者的簡易範例 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( \"fmt\")func printer(c chan int) &#123; // 無限循環等待資料 for &#123; // 從channel 取得資料 data := &lt;-c if data == 0 &#123; fmt.Println(\"break\") break &#125; fmt.Println(data) &#125; // 通知main 已經結束了 c &lt;- 0&#125;func main() &#123; // 建立一個int channel c := make(chan int) // 把channel 傳入, 讓它開始等待資料餵入 go printer(c) for i := 1; i &lt;= 10; i++ &#123; // 餵入資料給channel c &lt;- i &#125; // 通知printer 結束 ; 這裡 0 表示結束 c &lt;- 0 // 等printer 結束通知 &lt;-c&#125; Ex2 : 單向通道, 只能發送或是接收 只能發送, var 通道變數 chan &lt;- 類型 只能接收, var 通道變數 &lt;- chan 類型1234ch := make(chan int)var sendOnlyCh chan &lt;- int = chvar recvOnlyCh &lt;- chan int = chkjj 先來看一下內建的Timer的原始碼, 會發現他的屬性C也是個只能接收資料的通道.透過從通道C獲得, 就能得知定時器到期這個事件的到來.只要時間倒數一到, 定時器會對自己發送一個time.Time類型的值. 12345678// The Timer type represents a single event.// When the Timer expires, the current time will be sent on C,// unless the Timer was created by AfterFunc.// A Timer must be created with NewTimer or AfterFunc.type Timer struct &#123; C &lt;-chan Time r runtimeTimer&#125; 1234567891011121314151617181920package mainimport ( \"fmt\" \"time\")func main() &#123; // 設置每2秒就觸發的定時器 timer := time.NewTimer(time.Second * 2) defer timer.Stop() for &#123; // 從channel取值 fmt.Println(&lt;-timer.C) // 重新設置每一秒就觸發的定時器 timer.Reset(time.Second) &#125;&#125; 上面宣告通道時都沒帶上最後一個參數這參數定義的是緩衝空間的大小. 剛剛我們用的叫做無緩衝區的通道, 這種通道類型, 就是沒有宣告buffer size的通道.先來補充上面講的unbuffered 跟buffered channel的差異. Unbuffered Channel 無緩衝區的通道無緩衝通道沒有任何緩衝區容量, 所以需要兩個goroutine(1發1收)準備好進行資料互換.當發布者goroutine嘗試把資料發送到unbuffered channel時, 訂閱者goroutine等待接收資料的話.該channel會把接著要發送資料的goroutine給lock作等待, 直到有其他訂閱者goroutine嘗試接收走.如果有訂閱者goroutine嘗試從unbuffered接收資料, 但也沒有另一個發布者goroutine來發送資料的話, 該訂閱者goroutine也會被lock作等待. 圖中的3、4、5, 就是兩方嘗試作交換的動作. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package mainimport ( \"fmt\" \"sync\" \"time\")var wg sync.WaitGroupfunc main() &#123; // unbuffered channel baton := make(chan int) wg.Add(1) go Runner(baton) // start from 1 baton &lt;- 1 wg.Wait()&#125;func Runner(baton chan int) &#123; var newRunner int // get baton from channel runner := &lt;-baton fmt.Printf(\"Runner %d Running With Baton\\n\", runner) if runner != 4 &#123; newRunner = runner + 1 fmt.Printf(\"Runner %d To The Line\\n\", newRunner) // 創建另一個goroutine, 等有發布者把接力棒丟進去通道內 go Runner(baton) &#125; time.Sleep(100 * time.Millisecond) if runner == 4 &#123; fmt.Printf(\"Runner %d Finished, Race Over\\n\", runner) wg.Done() return &#125; fmt.Printf(\"Runner %d Exchange With Runner %d\\n\", runner, newRunner) baton &lt;- newRunner&#125;/*Runner 1 Running With BatonRunner 2 To The LineRunner 1 Exchange With Runner 2Runner 2 Running With BatonRunner 3 To The LineRunner 2 Exchange With Runner 3Runner 3 Running With BatonRunner 4 To The LineRunner 3 Exchange With Runner 4Runner 4 Running With BatonRunner 4 Finished, Race Over*/ Buffered Channel 有緩衝區的通道上面所提的unbuffered channel可以視為是size為0的buffered channel.有緩衝區的通道, 具有buffer size, 所以發跟收兩方能單獨作業.可是當buffer已滿或是空的, 就跟unbuffered一樣的變成同步行為了. 為什麼要限制長度而不是提供無限長度的通道呢?channel是在兩個goroutine之間通信的橋樑.因此必然有一方提供資料, 一方作為消費者接收資料.當供給速度遠大過接收的處理速度時, 如果通道不限制長度, 則記憶體會不斷膨脹, 直到app崩潰.因此發送資料量必須在消費方處理量+通道長度的範圍內, 才能正確的處理. 結論 :對於buffered channel 長度為C,則通道中第K個接收完成操作發生在第K+C個發送完成之前.如果把C設成0則對應unbuffered channel, 也就是第K個接收完成在K+1個發送完成之前.因為該類型只能同步發送一個. 故可以根據channel的buffer size來控制goroutine的最大數量.不要透過共享變數+Mutex來進行操作, 應該透過channel來共享 Channel的循環接收1234// 通道內的資料可以透過for range進行多個資料的接收操作, 一次for就得到一筆資料for data := range channel &#123;&#125; 123456789101112131415161718192021222324252627282930package mainimport ( \"fmt\" \"time\")func main() &#123; ch := make(chan int) go func() &#123; for i := 3; i &gt;= 0; i-- &#123; ch &lt;- i time.Sleep(time.Second) &#125; &#125;() for data := range ch &#123; fmt.Println(data) if data == 0 &#123; break &#125; &#125;&#125;/*3210*/ Channel的關閉回收channel是一個reference object, 和map類似.只要沒有外部在引用就會被回收掉. 但也能夠主動的關閉.探究golang的channel和map内存释放问题 透過 close(通道變數)被關閉的channel一樣可以被訪問,只是會觸發panic 發送資料給被關閉的channel123456789101112131415161718package mainimport \"fmt\"func main() &#123; ch := make(chan int) close(ch) fmt.Println(\"ptr: %p, len: %d\\n\", ch, len(ch)) ch &lt;- 1&#125;/*ptr: %p, len: %d 0xc000076060 0panic: send on closed channel*/ 被關閉的channel, 其實不會是nil, 但如果嘗試發送資料給被關閉的通道,就會發出panic. 從被關閉的channel接收資料1234567891011121314151617181920212223package mainimport \"fmt\"func main() &#123; ch := make(chan string, 2) ch &lt;- \"0\" ch &lt;- \"1\" close(ch) for i := 0; i &lt; cap(ch)+1; i++ &#123; v, ok := &lt;-ch fmt.Println(v, ok) &#125;&#125;/*0 true1 true false*/ 我們在執行for loop之前就關閉了通道, 但裡面的資料不會被釋放, 通道也不會消失.我們還是可以從被關閉的channel取回資料來處理的, 然後通道這時停止阻塞.前兩個結果表示, 還是可以進行接收資料的動作的.這是字串通道, 第三行的 false, 表示通道在關閉狀態下取出的值. v表示該類型的默認值, 因為是字串類型, 所以返回空字串, false表示沒有獲取成功, 因為通道已經空了. 使用Select用來響應多個channel的操作, 行為類似switch case, 只是每個case被一個channel操作取代了.在每個case都會對應一個channel的收發過程.當收發完成後, 會出發case中對應的語句.多個操作在每次select中挑選一個進行回應.不過如果select中至少兩個以上的case同時被滿足觸發, 就只會隨機挑一個case執行. 12345678select ( case 成功操作ch1 : 響應操作1 case 成功操作ch2 : 響應操作2 default: 其他case都沒有滿足觸發時, 會執行默認case, 避免select被阻塞.) 操作 語句範例 接收任意資料 case &lt;- ch: 接收資料到變數上 case d := &lt;- ch 發送資料 case ch &lt;- 100 ; Deadlock範例1 沒有default case:使用select但沒有default case, 上面提到這預設是為了不被阻塞用也沒有發布者對channel發送資料, 導致main這goroutine被阻塞導致deadlock.只要channel的另一方有goroutine會發送資料, 那怕是幾天才發一筆, 都不會造成deadlock, 頂多是block.所以訂閱者執行時, 會檢查channel另一邊有沒有發布者已經註冊了, 不然就是拋deadlock panic.但接收者先送資料, 沒人收卻不會拋panic的, 最多是channel滿了被block. 如果channel是nil channel也是一樣的, 因為也會無法從中讀取資料, 也是會造成阻塞操作. 12345678910111213package mainfunc main() &#123; dataCh := make(chan int, 5) select &#123; case &lt;-dataCh: &#125;&#125;/*fatal error: all goroutines are asleep - deadlock!goroutine 1 [chan receive]:*/ 1234567891011121314151617package mainimport \"log\"func main() &#123; dataCh := make(chan int, 5) select &#123; case &lt;-dataCh: // 補上default case來避免阻塞 default: log.Println(\"default case executed\") &#125;&#125;/*2019/09/21 16:56:18 default case executed*/ 範例2 沒有半個case :一樣一直阻塞導致deadlock 12345678package mainfunc main() &#123; select &#123;&#125;&#125;/*fatal error: all goroutines are asleep - deadlock!*/ 隨機挑滿足的case看個例子滿足多個case下, 會隨機挑一個滿足的case執行對應操作. 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( \"log\")func main() &#123; dataCh := make(chan int, 5) go func() &#123; for i := 0; i &lt; 5; i++ &#123; select &#123; case dataCh &lt;- 1: log.Println(\"send 1\") case dataCh &lt;- 2: log.Println(\"send 2\") case dataCh &lt;- 3: log.Println(\"send 3\") &#125; if i == 4 &#123; close(dataCh) &#125; &#125; &#125;() for i := 0; i &lt; 5; i++ &#123; log.Printf(\"receive %v\\n\", &lt;-dataCh) &#125;&#125;/*2019/09/21 16:32:32 send 12019/09/21 16:32:32 send 12019/09/21 16:32:32 send 32019/09/21 16:32:32 send 32019/09/21 16:32:32 send 22019/09/21 16:32:32 receive 12019/09/21 16:32:32 receive 12019/09/21 16:32:32 receive 32019/09/21 16:32:32 receive 32019/09/21 16:32:32 receive 2*/ break跳脫思考一下, for 裡面包select , 在case內break 123456789101112131415161718192021222324252627282930313233343536package mainimport ( \"fmt\" \"time\")func test() &#123; i := 0 for &#123; select &#123; case &lt;-time.After(time.Millisecond * time.Duration(500)): i++ if i == 3 &#123; fmt.Println(\"break now\") break &#125; fmt.Println(\"inside the select: \") &#125; fmt.Println(\"inside the for: \") &#125;&#125;func main() &#123; test()&#125;/*inside the select: inside the for: inside the select: inside the for: break nowinside the select: inside the for: ...*/ break在這種使用下, 是無法跳出for之外.只能使用標籤, 搭配break或是goto離開. 12345678910111213141516func test() &#123; i := 0 END: for &#123; select &#123; case &lt;-time.After(time.Millisecond * time.Duration(500)): i++ if i == 3 &#123; fmt.Println(\"break now\") break END &#125; fmt.Println(\"inside the select: \") &#125; fmt.Println(\"inside the for: \") &#125;&#125; 12345678910111213141516func test() &#123; i := 0 for &#123; select &#123; case &lt;-time.After(time.Millisecond * time.Duration(500)): i++ if i == 3 &#123; fmt.Println(\"break now\") goto END &#125; fmt.Println(\"inside the select: \") &#125; fmt.Println(\"inside the for: \") &#125; END:&#125; 對channel的操作行為整理 操作 nil channel closed channel not-closed &amp; not nil channel close panic panic success close ch&lt;- block panic block or sucess write &lt;-ch block read zero value block or read success 看得出來對channel不熟的話, 很容易panic.尤其是在close操作上.來整理一下怎樣的關閉通道, 能全身而退, 安全的在各goroutine之間結束. The Channel Closing Principle 別再訂閱方這裡關閉channel 如果有多個發布者對上同一個channel, 這情況下, 也別在發布端這裡作關閉 不要去關閉一個已經被關閉的channel 不要送資料去一個已經被關閉的channel 那我們在發布端跟訂閱端這裡的使用場景就可分成 一個發布者, 多個訂閱者 多個發布者, 一個訂閱者 M個發布者, N個訂閱者 一個發布者, 多個訂閱者 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainpackage mainimport ( \"log\" \"math/rand\" \"sync\" \"time\")// 一個發布者, 多個訂閱者// 因為只有一個發布者對上channel, 所以由發布者自己決定什麼時候關閉通道func main() &#123; rand.Seed(time.Now().UnixNano()) log.SetFlags(0) // 隨機數字的最大值 const Max = 100000 // 訂閱者數量 const NumSubscribers = 100 wgSubscribers := sync.WaitGroup&#123;&#125; wgSubscribers.Add(NumSubscribers) // 資料通道 dataCh := make(chan int) // 發布者 go func() &#123; for &#123; // 當剛好出現0時 if value := rand.Intn(Max); value == 0 &#123; // 唯一的發布者可自己關閉通道 close(dataCh) return &#125; else &#123; dataCh &lt;- value &#125; &#125; &#125;() // 訂閱者 for i := 0; i &lt; NumSubscribers; i++ &#123; go func() &#123; defer wgSubscribers.Done() //一直從channel接收資料直到通道關閉, 且都沒資料為止 for value := range dataCh &#123; log.Println(value) &#125; &#125;() &#125; wgSubscribers.Wait()&#125; 多個發布者, 一個訂閱者 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport ( \"log\" \"math/rand\" \"sync\" \"time\")func main() &#123; rand.Seed(time.Now().UnixNano()) log.SetFlags(0) const Max = 100000 // 發布者數量 const NumPublishers = 1000 wgSubscriber := sync.WaitGroup&#123;&#125; wgSubscriber.Add(1) // 資料通道 dataCh := make(chan int) // 停止訊號通道, 發訊號給他的是訂閱者, 訂閱者因為自己不能關閉通道, 會違反原則 // 發布者收到停止訊號後, 就會停止發布並且返回 stopCh := make(chan struct&#123;&#125;) // 創建多個發布者 for i := 0; i &lt; NumPublishers; i++ &#123; go func() &#123; for &#123; // 如果只有一個select 內有從stopCh取值跟送值給dataCh這兩個case. // 當同時兩個條件都滿足下, 是會發生隨機挑一個case去執行的無法預估的情況. // 所以第一個select只會有從stopCh取值作提早返回和default case避免阻塞用. select &#123; // 發布者對資料通道是發布者的角色 // 但是對停止訊號通道則是訂閱者的角色 case &lt;-stopCh: return default: &#125; select &#123; case &lt;-stopCh: return case dataCh &lt;- rand.Intn(Max): &#125; &#125; &#125;() &#125; // 訂閱者 go func() &#123; defer wgSubscriber.Done() for value := range dataCh &#123; if value == Max-1 &#123; // 訂閱者對停止事件通道的角色則是發布的作用, // 所以由他負責關閉沒有違反原則, 且也只有他一位. close(stopCh) return &#125; log.Println(value) &#125; &#125;() wgSubscriber.Wait()&#125; M個發布者, N個訂閱者最複雜的case 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package mainimport ( \"log\" \"math/rand\" \"strconv\" \"sync\" \"time\")// 不能讓發布者或是訂閱者來關閉資料通道, 且不能讓發布者這邊來關閉額外的訊息通道來通知其他所有角色退出.// 引入主持人這角色在這情境下, 來關閉訊息通道func main() &#123; rand.Seed(time.Now().UnixNano()) log.SetFlags(0) const Max = 100000 // 訂閱者數量 const NumSubscribers = 10 // 發布者數量 const NumPublishers = 1000 wgSubscribers := sync.WaitGroup&#123;&#125; wgSubscribers.Add(NumSubscribers) // 資料通道 dataCh := make(chan int) // 停止訊號通道, 給仲裁角色用來發送訊號的 stopCh := make(chan struct&#123;&#125;) // 一個長度為1 的通道, 主要是用來告訴主持人說該關閉通道了 // 看是發送者發起還是接收者發起的 toStop := make(chan string, 1) var stoppedBy string // 主持人, 就block自己, 直到從toStop取值成功, 再來關閉訊息通道 go func() &#123; stoppedBy = &lt;-toStop close(stopCh) &#125;() // 創建多個發布者 for i := 0; i &lt; NumPublishers; i++ &#123; go func(id string) &#123; for &#123; value := rand.Intn(Max) if value == 0 &#123; // 某一個發布者決定停止, 發訊號過去給主持人 select &#123; case toStop &lt;- \"sender#\" + id: default: &#125; return &#125; // 嘗試從停止通道中取值, 或者不阻塞往下繼續執行 select &#123; case &lt;-stopCh: return default: &#125; // 嘗試從停止通道中取值, 或者發送資料到資料通道 select &#123; case &lt;-stopCh: return case dataCh &lt;- value: &#125; &#125; &#125;(strconv.Itoa(i)) &#125; // 創建多個訂閱者 for i := 0; i &lt; NumSubscribers; i++ &#123; go func(id string) &#123; defer wgSubscribers.Done() for &#123; // 嘗試從停止通道中取值, 或者不阻塞往下繼續執行 select &#123; case &lt;-stopCh: return default: &#125; // 嘗試從停止通道中取值, 或者從資料通道取值 select &#123; case &lt;-stopCh: return case value := &lt;-dataCh: if value == Max-1 &#123; select &#123; case toStop &lt;- \"receiver#\" + id: default: &#125; return &#125; log.Println(value) &#125; &#125; &#125;(strconv.Itoa(i)) &#125; wgSubscribers.Wait() log.Println(\"stopped by\", stoppedBy)&#125; 好像資料通道跟主持人專用通道, 都沒人去負責Close() ??前面提過因為只要大家都沒在用該通道, 不論是否有沒有主動去close().最終該通道就會被GC掉, 因為沒人在引用該通道了. Pub-Sub == 觀察者模式 ?Pub-Sub中間都會有個第三個組件message broker或者event bus/channel, 負責作調度跟管理.觀察者則是直接由主題變化時, 通知所有觀察者.所以這裡有channel的例子其實都是Pub-Sub. Pub-Sub 觀察者 接著會陸續介紹幾種併發模型跟Context ps:別任意地無限建立goroutine 並且裡面有這樣寫法, 還沒任何的return 123for &#123; xxxx&#125; 這會導致CPU被莫名其妙吃光, 因為CPU Time都花費在for(1) loop上了.Channel本身可以是非阻塞操作讓出CPU時間, 但for (1) loop不會參考來源 鐵人賽連結","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"},{"name":"iT邦鐵人賽11Th","slug":"iT邦鐵人賽11Th","permalink":"https://tedmax100.github.io/tags/iT邦鐵人賽11Th/"}]},{"title":"Goroutine 讓你用少少的線程, 能接受更多的工作, 但沒說會作比較快","slug":"Go_Routine","date":"2020-12-21T13:22:12.000Z","updated":"2020-12-21T13:23:25.011Z","comments":true,"path":"2020/12/21/Go_Routine/","link":"","permalink":"https://tedmax100.github.io/2020/12/21/Go_Routine/","excerpt":"​","text":"​ Goroutine開發運行時總是會需要處理併發任務.併發是指同一時間可以執行多個任務.併發通常包含多執行緒, 多進程, 分佈式程序等.Go提供的是處理多份工作的能力, 透過goroutine來進行系統調度, 把一個方法創建為goroutine時, Go會將其視為一個獨立的工作單元, 這個單元會被調度到可用的邏輯處理器上執行;一個goroutine大小大概2kb-4kb, 非常的小, 所以要管理個上千上萬個goroutine是相對於其他語言, 比較不佔記憶體的.Go的併發同步模型是採用CSP(Communicating Sequential Process), 是一種訊息傳遞模式, 不是透過對資料加上lock來做同步存取, 而是透過CSP在goroutine之間傳遞訊息, channel在多個goroutine之間進行同步通信與交換. OS調度器會決定哪個threads要進行調度到CPU上執行.Go是把單個邏輯CPU綁定到單個OS thread上, 這些邏輯CPU會來執行所有被創建的goroutine, 運行時再把每個可用的實際CPU分配一個邏輯CPU. 只有單核的情形下, Goroutine跟 NodeJS的EventLoop(1:m映射)很相似.都是同時間只有一件事情在主線程內處理, 只是快速的在事件間切換, 但NodeJS就是單線程+IO多路複用, 特別適合IO密集型的情境.只是處理網路請求, Node是都會吃下請求的, 但如果進行後面的處理, 就會是同步的了.要善用全部核心, 就要依賴PM2這類的起多個Node實例. 但只要有多核心多線程, goroutine會生成多個邏輯處理器在調度器間處理, 每個上會有很多goroutines (n:m映射). 並且是透過channel交換訊息, 確保同時間只有一個goroutine可以訪問資料, 並不是透過跨線程的共享內存空間來交換, 這需要很多額外的lock來處理同步. Concurrency is not ParallelismConcurrency一個收銀機服務一排隊列, 只是代表能同時管理很多事情, 這些事情可能只做一半就被暫停去作別的事情; 能滿足Go跟Node的設計哲學, “用較少的資源作更多的事情”. Parallelism數個收銀機同時服務多排隊列 如上面所說的, 只要有多個P(logical CPU), 調度器會把goroutine分配到每個P上. 這會讓goroutine在不同的系統線程M上執行.但如果要實現平行, 需要自己讓代碼執行在有多個物理cpu上. 併發的案例 : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( \"fmt\" \"runtime\" \"sync\")func main() &#123; // 使用一個邏輯處理器給調度器用 runtime.GOMAXPROCS(1) // wg + 2 表示要等待2個goroutine完成 var wg sync.WaitGroup wg.Add(2) fmt.Println(\"start goroutines\") // 創建goroutine go func() &#123; defer wg.Done() for count := 0; count &lt; 3; count++ &#123; for char := 'a'; char &lt; 'a'+26; char++ &#123; fmt.Printf(\"%c\", char) &#125; &#125; &#125;() // 創建另一個goroutine go func() &#123; defer wg.Done() for count := 0; count &lt; 3; count++ &#123; for char := 'A'; char &lt; 'A'+26; char++ &#123; fmt.Printf(\"%c\", char) &#125; &#125; &#125;() fmt.Println(\"waiting to finish\") wg.Wait() fmt.Println(\"\\nfinish Program\")&#125;// Output :// tart goroutines// waiting to finish// ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz// finish Program 能看到2個goroutine一個接一個併發執行. 把邏輯處理器改成2 123runtime.GOMAXPROCS(2)// Output :// ABCDEFGHabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mainimport ( \"fmt\" \"runtime\" \"sync\")var wg sync.WaitGroupfunc main() &#123; // 使用一個邏輯處理器給調度器用 runtime.GOMAXPROCS(1) // wg + 2 表示要等待2個goroutine完成 wg.Add(2) fmt.Println(\"start goroutines\") // 創建goroutine go printPrime(\"A\") go printPrime(\"B\") fmt.Println(\"waiting to finish\") wg.Wait() fmt.Println(\"\\nfinish Program\")&#125;func printPrime(prefix string) &#123; defer wg.Done()next: for outer := 2000; outer &lt; 50000; outer++ &#123; for inner := 2; inner &lt; outer; inner++ &#123; if outer%inner == 0 &#123; continue next &#125; &#125; fmt.Printf(\"%s : %d\\n\", prefix, outer) &#125; fmt.Println(\"completed\", prefix)&#125;// Output :// tart goroutines// waiting to finish// B : 49801// B : 49807// B : 49811// A : 49411// A : 49417// A : 49429// finish Program 因為查找質數會耗費不少時間, 能看到調度器有機會在第一個goroutine找到所有質數之前, 切換到另一個goroutine. 控制併發 runtime.Gosched(), 告訴調度器將切換到另一個goroutine. 全局共享變數1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( \"fmt\" \"runtime\" \"sync\")var ( counter int wg sync.WaitGroup)func main() &#123; /* runtime.GOMAXPROCS(2) */ wg.Add(2) go incCounter(1) go incCounter(2) wg.Wait() fmt.Println(\"finish counter:\", counter)&#125;func incCounter(id int) &#123; defer wg.Done() for count := 0; count &lt; 2; count++ &#123; value := counter runtime.Gosched() value++ counter = value &#125;&#125;// finish counter: 2 因為在存取counter這全局變數時, 沒有上鎖, 導致發生race condition在counter這變數的存取上. Go有指令能幫助偵測race condition 12go build -race./app 1234567891011121314151617181920==================WARNING: DATA RACERead at 0x0000005ef648 by goroutine 7: main.incCounter() main.go:30 +0x6fPrevious write at 0x0000005ef648 by goroutine 6: main.incCounter() main.go:34 +0x90Goroutine 7 (running) created at: main.main() main.go:19 +0x89Goroutine 6 (finished) created at: main.main() main.go:18 +0x68==================finish counter: 4Found 1 data race(s) 明確的說出在第幾行會有競爭問題. Lock atomic 原子方法(透過底層的加鎖機制, 所以還是有鎖) 12345678910111213141516171819202122232425262728293031package mainimport ( \"fmt\" \"sync\" \"sync/atomic\")var ( counter int64 wg sync.WaitGroup mutex sync.Mutex)func main() &#123; wg.Add(2) go incCounter(1) go incCounter(2) wg.Wait() fmt.Printf(\"finish:%d\\n\", counter)&#125;func incCounter(id int) &#123; defer wg.Done() for count := 0; count &lt; 2; count++ &#123; counter = atomic.AddInt64(&amp;counter, 1) &#125;&#125; sync.mutex 互斥鎖 利用mutex創建一個critical section, 保證同一時間只會有一個goroutine進入執行1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( \"fmt\" \"runtime\" \"sync\")var ( // shared variable counter int64 wg sync.WaitGroup // mutex lock mutex sync.Mutex)func main() &#123; wg.Add(2) go incCounter(1) go incCounter(2) wg.Wait() fmt.Printf(\"finish:%d\\n\", counter)&#125;func incCounter(id int) &#123; defer wg.Done() for count := 0; count &lt; 2; count++ &#123; // lock the critical section mutex.Lock() &#123; value := counter runtime.Gosched() value++ counter = value &#125; // unlock mutex.Unlock() &#125;&#125;// finish : 4 鐵人賽連結","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"},{"name":"iT邦鐵人賽11Th","slug":"iT邦鐵人賽11Th","permalink":"https://tedmax100.github.io/tags/iT邦鐵人賽11Th/"}]},{"title":"Go_Defer_延遲調用","slug":"Go-Defer-延遲調用","date":"2020-12-21T13:19:31.000Z","updated":"2020-12-21T13:20:34.914Z","comments":true,"path":"2020/12/21/Go-Defer-延遲調用/","link":"","permalink":"https://tedmax100.github.io/2020/12/21/Go-Defer-延遲調用/","excerpt":"看個例子, 這是一個讀取資料庫取資料的方法 123456func (db *DB) ReadData(age int, results []Result) &#123; // 查詢資料庫 // 錯誤, 釋放連線 // 取值反射錯誤, 釋放連線 // 成功, 釋放連線&#125; 因為GO沒有try{} finally{} 這語句.所以很多情況如果要在離開函數之前, 作一些必要的動作時就要在各種case下, 加上處理.early return的寫法, 也要每個return前都寫一樣的處理, 破壞簡潔. wtf 很容易寫成這樣 … 只要邏輯的層數多點的話​","text":"看個例子, 這是一個讀取資料庫取資料的方法 123456func (db *DB) ReadData(age int, results []Result) &#123; // 查詢資料庫 // 錯誤, 釋放連線 // 取值反射錯誤, 釋放連線 // 成功, 釋放連線&#125; 因為GO沒有try{} finally{} 這語句.所以很多情況如果要在離開函數之前, 作一些必要的動作時就要在各種case下, 加上處理.early return的寫法, 也要每個return前都寫一樣的處理, 破壞簡潔. wtf 很容易寫成這樣 … 只要邏輯的層數多點的話​But!!!Go有Defer這延遲載入的語句!!!剛剛的例子就能夠改成 1234567func (db *DB) ReadData(age int, results []Result) &#123; // 查詢資料庫 defer 釋放連線 // 錯誤 // 取值反射錯誤 // 成功&#125; 來看看defer實際的存放跟執行順序先defer 會被後面的執行語句, 依照後進先出LIFO的方式作執行, 至於defer被觸發的時間點, 就在當前函數返回之前就會被調用. defer的結構123456789type _defer struct &#123; siz int32 started bool sp uintptr pc uintptr fn *funcval _panic *_panic link *_defer&#125; fn 存的就是指向defer關鍵字傳入的語句了 1234567891011121314func main() &#123; fmt.Println(\"begin\") defer fmt.Print(1) fmt.Println(\"do something\") defer fmt.Print(2) fmt.Println(\"end\")&#125;/*begindo somethingend21*/ 也能傳入匿名函數 12345678910111213func main() &#123; fmt.Println(\"ithome\") defer func() &#123; fmt.Println(\"ironman\") fmt.Println(\"Day 13 post sucess\") &#125;()&#125;/*ithomeironmanDay 13 post sucess*/ 進階題 : defer 裡函數裡包著函數 1234567891011121314151617181920212223func calc(index string, a, b int) int &#123; ret := a + b fmt.Println(index, a, b, ret) return ret&#125;func main() &#123; a := 1 b := 2 // 記得是FILO defer calc(\"1\", a, calc(\"10\", 2, b)) a = 0 defer calc(\"2\", a, calc(\"20\", a, b)) b = 1&#125;/*10 2 2 420 0 2 22 0 2 21 1 4 5*/ 123456789101112func main() &#123; for i := 0; i &lt; 5; i++ &#123; defer fmt.Println(i) &#125;&#125;/*43210*/ 使用情境 打開文件後, 關閉/釋放文件 接收請求後, 回覆請求 加鎖後, 解鎖 釋放資源1234567891011121314151617181920212223func fileSize(filename string) int64 &#123; // 根據文件名稱打開 f, err := os.Open(filename) if err != nil &#123; // 錯誤回傳, 觸發defer return 0 &#125; // 延遲調用Close(), 這時候還不會立刻被呼叫 defer f.Close() // 獲取文件訊息 info, err := f.Stat() if err != nil &#123; // 錯誤回傳, 觸發defer return 0 &#125; // 獲取文件大小 size := info.Size() // 回傳, 觸發defer return size&#125; 加鎖解鎖12345678910111213var ( valueByKey = make(map[string]int) valueByKeyGuard sync.Mutex)func readValue(key string) int &#123; valueByKeyGuard.Lock() // 延遲解鎖 defer valueByKeyGuard.Unlocok() return valueByKey[key]&#125; 誤用deferdefer 去執行nil1234567891011func main() &#123; var run func() = nil defer run() fmt.Println(\"ithome\")&#125;/*ithomepanic: runtime error: invalid memory address or nil pointer dereference*/ for loop中使用123456789func main() &#123; for &#123; row, err := db.Query(\"select 1\") if err != nil &#123; fmt.Println(err) &#125; defer row.Close() &#125;&#125; 這種用法會在main這方法內, 一直累加很多個defer…直到崩潰. 解法, 直接再開一個匿名函數, 就會在這匿名函數結束前執行defer123456789101112func main() &#123; for &#123; func() &#123; row, err := db.Query(\"select 1\") if err != nil &#123; fmt.Println(err) &#125; defer row.Close() &#125;() &#125;&#125; panic恢復透過defer將匿名函數延遲執行,panic觸發時, protectRun()函數就會結束, defer就會被觸發.透過defer內的recoever捕捉到panic與其內容.判斷是否是運行時的錯誤, 還是手動拋出的錯誤, 並作不同處置. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport ( \"fmt\" \"runtime\")type panicContext struct &#123; function string&#125;func protectRun(entry func()) &#123; defer func() &#123; if err := recover(); err != nil &#123; switch err.(type) &#123; case runtime.Error: fmt.Println(\"runtime: \", err) default: fmt.Println(\"error : \", err) &#125; &#125; &#125;() entry()&#125;func main() &#123; fmt.Println(\"執行前\") protectRun(func() &#123; fmt.Println(\"手動觸發panic前\") panic(&amp;panicContext&#123;\"手動觸發!\"&#125;) fmt.Println(\"手動觸發panic後\") &#125;) protectRun(func() &#123; fmt.Println(\"賦值當機前\") var a *int *a = 1 fmt.Println(\"賦值當機後\") &#125;) fmt.Println(\"執行後\")&#125;/*執行前手動觸發panic前error : &amp;&#123;手動觸發!&#125;賦值當機前runtime: runtime error: invalid memory address or nil pointer dereference執行後*/ 分享這個是因為…未來很多真正使用上都會需要defer跟錯誤處理. 躲避 Go 1.13 defer 性能提升的姿势 鐵人賽連結","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"},{"name":"iT邦鐵人賽11Th","slug":"iT邦鐵人賽11Th","permalink":"https://tedmax100.github.io/tags/iT邦鐵人賽11Th/"}]},{"title":"Go modules 終於不會再被GOPATH綁死了","slug":"go-modules-終於不會再被GOPATH綁死了","date":"2020-12-21T13:18:29.000Z","updated":"2020-12-21T13:19:17.127Z","comments":true,"path":"2020/12/21/go-modules-終於不會再被GOPATH綁死了/","link":"","permalink":"https://tedmax100.github.io/2020/12/21/go-modules-終於不會再被GOPATH綁死了/","excerpt":"Go ModulesGo modules 出現原因 解除對GOPATH的完全依賴, 有go modules就能在$GOPATH外開專案了. 不同環境或者是多專案, 需要一套切換vendor目錄. 同一個依賴包的多種版本共存問題, 加入了版本化的支援. 可以使用GOProxy來解決某些地區無法使用go get的問題. 以往需要將vendor目錄一起提交到git, 避免CI/CD去拉到外部的依賴包. go modules有build cache, 在CI build server上速度飛快.​","text":"Go ModulesGo modules 出現原因 解除對GOPATH的完全依賴, 有go modules就能在$GOPATH外開專案了. 不同環境或者是多專案, 需要一套切換vendor目錄. 同一個依賴包的多種版本共存問題, 加入了版本化的支援. 可以使用GOProxy來解決某些地區無法使用go get的問題. 以往需要將vendor目錄一起提交到git, 避免CI/CD去拉到外部的依賴包. go modules有build cache, 在CI build server上速度飛快.​ 環境準備 Go version &gt;= 1.11 GO111MODULE=on (Go MOdule模式), 使用go module, 不諮詢GOPATH, 只是下載下來的依賴包依然存在GOPATH/pkg/mod/底下. GO111MODULE=off, 這表示是GOPATH模式, 查找依賴包順序如同昨天提的vendor目錄和GOPATH下. GO111MODULE=auto, 默認模式,在這模式下要使用go module, 需要滿足兩個條件 該專案目錄不在GOPATH/src/下 當前或上一層目錄存在go.mod檔案 Go Mododules 對於匯入依賴包的影響 可以在$GOPATH之外的地方建立專案 該專案Go Module開啟後, 下載的package會放在$GOPATH/pkg/mod下. $GOPATH/bin的功能依然保持 Go Mod Commands有兩種方式能定義一個正確的Go module 12345678// 在$GOPATH/src的目錄下, 建立合理的module路徑// 進入該module目錄, 執行下面命令go mod init [module name]///```bash// 在任意地方, 建立好module路徑// 在該目錄下, 執行go mod init [folder/]module name 就會在該專案下生出了go.mod文件了. go.mod的一些名詞 module 定義模組路徑 go 定義預期的go version require 指定依賴的功能包和其版本或是更高版本[預設是最新版] exclude 排除該功能包和其版本 replace 使用不同的依賴包版本替換原有的依賴包版本 註解 // 單行註解 /* 多行註解 */ indirect 被間接導入的依賴包123456module my/packagego 1.12require other/thing v1.0.2 // 註解require new/thing/v2 v2.3.4 // indirectexclude old/thing v1.2.3replace bad/thing v1.4.5 =&gt; good/thing v1.4.5 同專案的子目錄因為go.mod在專案的根目錄下, 子目錄的導入路徑會是該專案的導入路徑+子目錄路徑.舉例: 建立了ithome的專案, 底下有一個ironman的子目錄.則不需要也在子目錄建立go mod init指令, Go build會自動辨識ironman這目錄是ithome的一部分. Go Mod Require 安裝一下logrus1go get github.com/sirupsen/logrus go.mod的內容 123module modtestgo 1.12require github.com/sirupsen/logrus v1.4.2 // indirect 此時把v1.4.2 改成v1.4.1執行 1go mod download go.mod的內容 123module modtestgo 1.12require github.com/sirupsen/logrus v1.4.1 // indirect 也會發生$GOPATH/pkg/mod/github.com/sirupsen目錄下,多了logrus@v1.4.1和1.4.2版本的源碼 Go Mod Excludego.mod的內容 12345module modtestgo 1.12require github.com/sirupsen/logrus v1.4.2 // indirectexclude github.com/gin-gonic/gin v1.4.0 1go get github.com/gin-gonic/gin 會發現應該是要下載當前最新板的v1.4.0的gin; 但因為有exclude gin 1.4.0 ;所以改成下載v1.3.9 go.mod的內容 12345678910111213module modtestgo 1.12require ( github.com/gin-contrib/sse v0.1.0 // indirect github.com/gin-gonic/gin v1.3.0 // indirect github.com/golang/protobuf v1.3.2 // indirect github.com/mattn/go-isatty v0.0.8 // indirect github.com/sirupsen/logrus v1.4.2 github.com/ugorji/go v1.1.7 // indirect gopkg.in/go-playground/validator.v8 v8.18.2 // indirect gopkg.in/yaml.v2 v2.2.2 // indirect)exclude github.com/gin-gonic/gin v1.4.0 如果exclude指定gin的依賴功能包, 該功能包會避開該版號作安裝 Go Mod Replace如果有package被replace, 則編譯時會使用對應的項目來作取代. 與require類似, 可以指向令一個repo 又或是指向本地的一個目錄 gomodtest 1234// go.modmodule modtestgo 1.12require github.com/sirupsen/logrus v1.4.2 // indirect 1234567891011121314// modtest.gopackage gomodtestimport ( log \"github.com/sirupsen/logrus\")func Init() &#123; log.Info(\"godmodtest init\")&#125;func Exec() &#123; log.Info(\"godmodtest exec\")&#125; gomaintest 1234// go.modmodule github.com/tedmax100/gomaintestgo 1.12replace github.com/tedmax100/modtest =&gt; ../gomodtest 12345678910// main.gopackage mainimport ( modtest \"github.com/tedmax100/modtest\")func main() &#123; modtest.Exec()&#125; 執行結果 notes Replace和Exclude都只對當前這module有影響, 對其他功能包不會去影響到 ;其他功能包自己的replace也不會影響到這包. 自己寫個共用依賴模組用在自己的專案試試看依賴包專案目錄結構 /GOPATH/src/ithome 1go mod init github.com/tedmax100/ithome 因為我等等要推上github的repo中, 這裡就如以前說的會有域名/目錄/專案…這樣的層次關係. 1go get github.com/sirupsen/logrus 這裡跟govendor fetch有些不同了, 再有go modules專案內輸入go get.預設會去抓最新的tag版本; 如果沒有設立tag, 就抓最新的commit版本. go.sum這時候就會把logrus目錄下go.mod跟go.sum的依賴包跟其版本保存起來.go.sum 其實跟npm的package-lock.json有著一樣的功能. go.mod(npm的package.json)定義我們指名要的依賴跟版本.go.sum把go.mod的所有依賴包, 每一個像是樹的根節點一樣, 開始走訪去下載, 並且紀錄關係在此. ironman/ironman.go 123456789package ironmanimport ( log \"github.com/sirupsen/logrus\")func PrintIronMan() &#123; log.Info(\"hi iron man\")&#125; ithome.go 1234567891011121314package ithomeimport ( // 這裡因為我們定義的mod name就這麼長, // 子目錄的導入路徑會是該專案的導入路徑+子目錄路徑. \"github.com/tedmax100/ithome/ironman\" log \"github.com/sirupsen/logrus\")func PrintItHome() &#123; log.Info(\"hi ItHome\") ironman.PrintIronMan()&#125; 存檔, commit, 推上github.這裡我沒有打release tag. 可執行的專案目錄結構 /GOPATH/src/gomod 123go mod init gomod// 下載依賴包go get -u github.com/tedmax100/ithome main.go 123456789package mainimport ( \"github.com/tedmax100/ithome\")func main() &#123; ithome.PrintItHome()&#125; 執行main.go 把依賴包給作個release tag, 試試看 12// 作個更新go get -u github.com/tedmax100/ithome 可以看到ithome這依賴包, 從本來是紀錄commit hash, 變成是紀錄tag版本號了. 把依賴包給再進個commit, 但tag 還在v0.0.1 12// 作個更新go get -u github.com/tedmax100/ithome 正如前面說的, 他會先找tag/release有沒有, 沒有才去找最新的commit.但因為我們已經有tag v0.0.1, 所以怎樣更新依賴,只要沒有更新版的依賴被release就不會被更新. 那! 就來進版吧 各版本有下載過得都會在go/pkg/mod/匯入包路徑底下 反悔了! 想退回去指定的某一版1go get github.com/tedmax100/ithome@v0.0.1 因為快取有了, 就不必重抓也會順便更改go.mod和go.sum的內容 這外部的難用, 我要用自己魔改過得, 放在vendor底下的 或 我怕外部有人偷偷在代碼放後門, 我要用自己網路cache有的, 複製到vendor下 1go mod vendor 這會建立出一個vendor目錄, 底下有現在go.mod依賴包的代碼. 我們改一下程式gomod/vendor/github.com/tedmax100/ithome/ithome.go 12345678910111213package ithomeimport ( \"github.com/tedmax100/ithome/ironman\" log \"github.com/sirupsen/logrus\")func PrintItHome() &#123; // 就改這行, 存檔 log.Info(\"hi ItHome from vendor\") ironman.PrintIronMan()&#125; 開心的在terminal輸入 1go run main.go 笑XD因為只要啟用了go modules, 就會完全忽略了vendor目錄的存在, 只讀取go.mod的內容. 那怎辦呢?原本的指令go build, go install, go runm, go test啦等等的加上-mod=vendor 多安裝一些依賴包1go get github.com/go-sql-driver/mysql 結果最後根本沒有半個地方有import怎辦, 自己檢查每一個.go檔案, 看哪些沒有import ? 哪些依賴又沒有抓到呢? 12# add missing and remove unused modulego mod tidy 依賴包的module名稱能不能帶上版本號? 要是有breaking change, 新舊版本無法兼容呢?ithome/go.mod 12345module github.com/tedmax100/ithome@v2.0.0 // 這裡打上版本號go 1.12require github.com/sirupsen/logrus v1.4.2 改個程式 1234567891011121314151617package ithomeimport ( \"github.com/tedmax100/ithome/ironman\" log \"github.com/sirupsen/logrus\")func PrintItHome() &#123; log.Info(\"hi ItHome V0.0.7\") ironman.PrintIronMan()&#125;func PrintItHomeV2() &#123; log.Info(\"hi ItHome V2.0\") ironman.PrintIronMan()&#125; 存檔commit, push作release 跑到執行專案, 執行 1go get -u github.com/tedmax100/ithome 這時候發現, 不會去下載這2.0.0版本的依賴包因為版本號的v2.0.0, 這個第一個數字表示主版本號, 不同版本間若是無法兼容使用,則建議是提昇這版本號, 且建議遠端分之多上v2分支.版本號若是v1.10.13, 這個1表示主要版本號, 10表示次要版本號, 13表示修正版本號且go get -u會檢查go mod的版本號, 並不會主動去下載並提昇到不同的主要版本號的依賴包. 這裡import改成使用v2版 12345678910package mainimport ( \"github.com/tedmax100/ithome/v2\")func main() &#123; ithome.PrintItHome() ithome.PrintItHomeV2()&#125; 1go mod tidy 開心了, 收工 go mod 可以相當完美的跟vendor做切換並存.有機會來玩玩看goproxy. 鐵人賽連結","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"},{"name":"iT邦鐵人賽11Th","slug":"iT邦鐵人賽11Th","permalink":"https://tedmax100.github.io/tags/iT邦鐵人賽11Th/"}]},{"title":"好多依賴要管理","slug":"GoVendor好多依賴要管理","date":"2020-12-21T13:17:18.000Z","updated":"2020-12-21T13:18:11.520Z","comments":true,"path":"2020/12/21/GoVendor好多依賴要管理/","link":"","permalink":"https://tedmax100.github.io/2020/12/21/GoVendor好多依賴要管理/","excerpt":"回憶一下之前Day01提到的​","text":"回憶一下之前Day01提到的​ Go WorkSpace 工作目錄我們安裝好Go之後進去預設的GOPATH目錄下, 就會看到這樣的目錄結構. 123456789101112131415- GOPATH | -- bin/ | -- pkg/ | -- src/ | -- project1/ | -- vendor/ | -- project2/ | -- vendor/ bin 包含可安裝並執行的command (可執行的二進制文件) pkg 包含各種package objects (二進制的library檔, *.a檔) src 包含各專案的代碼 GOPATHGOPATH是一個環境變數, 用絕對路徑來指定工作目錄的位置.要是我們多人參與開發, 每個人都有一套自己的目錄結構, 讀取配置文件的位置也不統一, 這樣輸出的二進制文件也不會統一, 會導致開發的標準不一. GOPATH存在的目的是 所有在Go代碼裡, 透過import 宣告的package path, 用來計算該包的路徑用. 儲存任何透過go get獲取的依賴包. go build、go install產生的二進制文件會放在$GOPATH/bin底下 go get官方提供的工具, 會把go get取得的第三方套件代碼存放到$GOPATH/src中. 有許多社群做了幾個package management工具 Glide、dep、 govendor, 包含後面出的gomodule等, 都是為了方便專案去管理使用了哪些依賴包跟對應的版本, 以及下載位置.小弟接觸比較晚, 就挑了govendor和gomodule來學習.這兩個可以共存XD vendor在Go Module還沒出來時, 在1.5版提供了vendor. 但要手動環境變數GO15VENDOREXPERIMENT=11.6版則是默認是11.7版則是不必再設定該環境變數, 默認開啟vendor vendor特性在我們執行go build 或者是go run時, go會依照下列順序依序去找我們的要的依賴包 當下專案目錄的vendor資料夾 一路往上層目錄查找, 直到找到$GOPATH/src下的vendor 在GOROOT目錄下查找 在GOPATH下查找 vendor使用建議 一個專案只會有一個vendor目錄, 且就位於專案的根目錄內. govendorgovendor就是一個基於vendor這種目錄機制所做出來的套件管理工具.go在以前常用的套件包管理工具其中之一就是govendor.能在go build時的應用路徑搜尋調整成為當前專案項目目錄/vendor目錄的方式. 安裝govendor1go get -u -v github.com/kardianos/govendor 安裝好到$GOPATH/bin下, 會看到govendor的可執行檔. 使用govendor初始化vendor12// 移動該專案的根目錄govendor init 下載依賴包下載master主幹下最新的commit1govendor fetch 路徑 vendor.json用來紀錄依賴包的commit的hash跟時間等等 下載特定的版本1govendor fetch 路徑@v版本 vendor.json用來紀錄依賴包的列表版本, commit的hash跟時間等等 下載特定的tag 或是branch12govendor fetch 路徑@=tag_namegovendor fetch 路徑@=branch_name 加入GOPATH現有的包到vendor管理下從GOPATH下複製指定的包1govendor add path 這依賴包位於我的$GOPATH/src/githut.com/xwb1989/sqlparser目錄下 添加所有的依賴包1govendor add +external 使用自己小改過的包來取代官方第三方依賴包可能內部對github.com/go-sql-driver/mysql有加入點東西, 就能用這種方式改用自己的,但是程式import 還是照常github.com/go-sql-driver/mysql 1govendor get 'github.com/go-sql-driver/mysql::github.com/tedmax100/go-mysql' 刪除沒用的依賴包1govendor remove +unused 輸入完之後, 會發現全空, 因為我這時該專案目錄下還沒有任何程式作import. 1234567891011package mainimport ( log \"github.com/sirupsen/logrus\")func main() &#123; log.WithFields(log.Fields&#123; \"animal\": \"walrus\", &#125;).Info(\"A walrus appears\")&#125; 透過govendor再次安裝依賴包 12govendor fetch github.com/sirupsen/logrus@v1.4.2 govendor add github.com/xwb1989/sqlparser/ 1govendor remove +unused 只會留下有用到的. 再次清空govendor所有依賴執行add 1govendor add +external 也會得到跟上圖一樣的結果. 1go run main.go 成功執行! 列出該專案所有存在的依賴包1govendor list 從vendor.json恢復所有依賴包原始碼到vendor目錄下1govendor sync 與npm、yarn相同的使用命令 command npm yarn govendor 初始化 npm init yarn init govendor init 增加依賴包 npm install -s yarn add govendor fetch 刪除依賴包 npm uninstall yarn remove govendor remove 同步依賴包 npm install yarn install govendor sync govendor看似完美了, 但幹麻還出gomodule?因為govendor要求一定要在$GOPATH/src下執行.不然會報錯誤 下一篇的go module就是能解決這問題 鐵人賽連結","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"},{"name":"iT邦鐵人賽11Th","slug":"iT邦鐵人賽11Th","permalink":"https://tedmax100.github.io/tags/iT邦鐵人賽11Th/"}]},{"title":"Interface & OOP  就說你是鴨子! 你就是要呱呱叫","slug":"GoInterface","date":"2020-12-20T14:47:46.000Z","updated":"2020-12-20T14:51:46.968Z","comments":true,"path":"2020/12/20/GoInterface/","link":"","permalink":"https://tedmax100.github.io/2020/12/20/GoInterface/","excerpt":"​","text":"​ Interface一個interface(接口) 就是包含了一系列行為的method集合.好處: 能建立低耦合的系統 透過這些被定義在接口的抽象行為, 讓要在多個單獨組件間彼此組合/通信會變得更為容易. 隱藏每個Class對其實現的細節 Reusability, 因為可重複利用, 能把一些複雜問題給簡化. Go InterfaceGo沒有真正的繼承, 所以沒有OOP那種該類別實際告訴大家我實現了某個接口這種聲明;所以對於實現Interface是透過隱性的向上轉型的方式(Duck typing), 在程式代碼的上下文判定struct是否實現了接口聲明的方法.所以只要該類型實現了該接口所有方法就是實現了該接口. example : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package mainimport ( \"fmt\")type Engine interface &#123; Start() Stop()&#125;// CarEngine並沒繼承Engine也沒宣告自己實現了Enginetype CarEngine struct &#123;&#125;// CarEngine有自己的公開方法Start()func (c CarEngine) Start() &#123; fmt.Println(\"Car engine is started\")&#125;func (c CarEngine) Stop() &#123; fmt.Println(\"Car engine is stoped\")&#125;type TrainEngine struct &#123;&#125;func (t TrainEngine) Start() &#123; fmt.Println(\"Train engine is started\")&#125;func (t TrainEngine) Stop() &#123; fmt.Println(\"Train engine is stoped\")&#125;// Starting和Stoping 的參數要求代入的是Engine這類型func Starting(e Engine) &#123; e.Start()&#125;func Stoping(e Engine) &#123; e.Stop()&#125;func main() &#123; carEngine := CarEngine&#123;&#125; trainEngine := TrainEngine&#123;&#125; // 這裡會檢查CarEngine和TrainEngine是否有實現Engine的全部方法 engines := []Engine&#123; carEngine, trainEngine, &#125; for _, engine := range engines &#123; Starting(engine) Stoping(engine) &#125;&#125;// 如果把TrainEngine的Stop刪除// 在48行就會在編譯時期被檢查出錯誤 因為Duck typing幾乎都出現在動態語言上, 程式寫起來飛快,但錯誤往往都是在執行時才能被發現. 靜態語言就是能在編譯時期發現這類的錯誤. Go採取了折衷的方法, 在安全和靈活之間取得平衡: 靜態類型 隱性實現 只有某個類型的變數實現了某個接口的全部方法, 這個變數才能在要求使用該接口的地方. 一個類型可以實現多個接口12345678// io.Writertype Writer interface &#123; Write(p []byte) (n int, err error)&#125;// io.Closertype Closer interface &#123; Close() error&#125; 1234567891011121314151617181920212223242526272829type Socket struct &#123;&#125;func (s *Socket) Write(p []byte) (n int, err error) &#123; fmt.Println(\"Write has be involked\") return 0, nil&#125;func (s *Socket) Close() error &#123; fmt.Println(\"Close has be involked\") return nil&#125;func usingWriter(writer io.Writer) &#123; writer.Write(nil)&#125;func usingCloser(closer io.Closer) &#123; closer.Close()&#125;func main() &#123; s := new(Socket) usingWriter(s) usingCloser(s)&#125;// Output :// Write has be involked// Close has be involked 多個類型可以實現同樣的接口(polymorphism)123456789101112131415161718192021222324252627type Service interface &#123; Start() Log(string)&#125;type Logger struct&#123;&#125;func (g *Logger) Log(l string) &#123; fmt.Println(l)&#125;type GameService struct &#123; Logger&#125;func (g *GameService) Start() &#123; fmt.Println(\"game service start\")&#125;func main() &#123; var s Service = new(GameService) s.Start() s.Log(\"hello\")&#125;// Output :// game service start// hello 接口的嵌套組合12345678910111213141516171819202122232425262728293031323334353637type device struct &#123;&#125;// 實現func (d *device) Write(p []byte) (n int, err error) &#123; return 0, nil&#125;// 實現func (d *device) Close() error &#123; return nil&#125;/*// WriteCloser is the interface that groups the basic Write and Close methods.type WriteCloser interface &#123; Writer Closer&#125;// Implementations must not retain p.type Writer interface &#123; Write(p []byte) (n int, err error)&#125;*/func main() &#123; // 宣告io.WriteClose, 並賦予device的實例 var wc io.WriteCloser = new(device) wc.Write(nil) wc.Close() // 宣告io.Writer, 並賦予device的實例 var writeOnly io.Writer = new(device) writeOnly.Write(nil)&#125; 空接口 interface{}interface{}是接口類型的特殊形式; 空接口沒有任何方法, 所以任何類型都沒必要去實現空接口; 反過來說, 任何值都滿足空接口的實現需求, 所以它可以保存任何值, 也能從空接口中取出值.空接口類型類似C#, Java中的Object, C的void*.空接口內部只保存了對象的類型和指針, 所以在使用上會比較慢一些. 12345// eface = empty interfacetype eface struct &#123; _type *_type data unsafe.Pointer&#125; 12345678910var any interface&#123;&#125;any = 1fmt.Println(any)any = falsefmt.Println(any)// Output :// 1// false 12345678var a int =1var i interface&#123;&#125; = a var b int = i// 第三行會報錯// cannot use i (type interface&#123;&#125;) as type int in assigment : need type assertion// 因為i 在此時還是interface&#123;&#125;類型, 並不是int類型// 要使用類型斷言var b int = i.(int) 接口斷言 Type AssertionsType Assertion是對於interface value的一種操作方法.語法格式 1t, ok := i.(T) i 代表實現接口的變數T 表示轉換的目標類型t 表示轉換後的變量ok 檢查i接口是否實現T類型的效果 鳥和豬有不同的特性, 一個能飛能走, 一個只能走.讓鳥跟豬各自實現Flyer和Walker的接口.然後實例被放進interface{}的map中, interface{}表示空接口, 所以什麼類型都能放.透過斷言操作來操作各接口. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152type Flyer interface &#123; Fly()&#125;type Walker interface &#123; Walk()&#125;type bird struct &#123;&#125;func (b *bird) Fly() &#123; fmt.Println(\"bird can fly\")&#125;func (b *bird) Walk() &#123; fmt.Println(\"bird can walk\")&#125;type pig struct &#123;&#125;func (p *pig) Walk() &#123; fmt.Println(\"pig can walk\")&#125;func main() &#123; animals := map[string]interface&#123;&#125;&#123; \"bird\": new(bird), \"pig\": new(pig), &#125; for name, obj := range animals &#123; f, isFlyer := obj.(Flyer) w, isWalker := obj.(Walker) fmt.Printf(\"name: %s isFlyer: %v isWalker: %v\\n\", name, isFlyer, isWalker) if isFlyer &#123; f.Fly() &#125; if isWalker &#123; w.Walk() &#125; &#125;&#125;// Output :// name: bird; isFlyer: true, isWalker: true// bird can fly// bird can walk// name: pig; isFlyer: false, isWalker: true// pig can walk 上面寫法會很多if能用type switch簡化 12345678switch obj := obj.(type) &#123;case Flyer: fmt.Printf(\"name: %s\\n\", name) obj.Fly()case Walker: fmt.Printf(\"name: %s\\n\", name) obj.Walk() &#125; Go OOP封裝透過package級別做封裝私有成員跟方法在Go是以小寫開頭的, 只有在該package內可見.公開成員跟方法是以大寫開頭. 12345678910111213type Bag struct &#123;// private property for Bag item []int&#125;// public method for Bagfunc (b *Bag) Insert(itemid int) &#123; b.items = append(b.items, itemid)&#125;func main() &#123; b := new(Bag) b.Insert(1002)&#125; Go沒有建構式, 透過簡單工廠方法來實現 123456789type Bag struct &#123;// private property for Bag item []int&#125;// simple factory methodfunc NewBag() Bag &#123; return &amp;Bag&#123;&#125;&#125; 繼承Go其實沒有繼承, 都是依靠組合(composition), 允許嵌入組合.也因為沒有繼承, 就不會出現可多重繼承裡會出現的死亡鑽石問題. 只要嵌入一個匿名類型的組合就等同於實現了繼承,如果只是嵌入struct那跟脆弱基類是一樣的脆弱, 所以會透過嵌入接口, 來提早檢查問題. 多態Go 依賴接口來實現這特性.只要對象實現相同的接口, Go就能處理不同類型的那些對象. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport \"fmt\"type Shape interface &#123; Area() int64&#125;type Rectangle struct &#123; width, height int64&#125;func NewRectangle(width, height int64) *Rectangle &#123; return &amp;Rectangle&#123; width: width, height: height, &#125;&#125;func (r *Rectangle) Area() int64 &#123; return r.width * r.height&#125;type Circle struct &#123; radius int64&#125;func NewCircle(radius int64) *Circle &#123; return &amp;Circle&#123; radius: radius, &#125;&#125;func (c *Circle) Area() int64 &#123; return c.radius * c.radius&#125;func main() &#123; r := NewRectangle(10, 5) c := NewCircle(5) s := []Shape&#123;r, c&#125; for _, shape := range s &#123; fmt.Println(shape.Area()) &#125;&#125; 鐵人賽連結","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"},{"name":"iT邦鐵人賽11Th","slug":"iT邦鐵人賽11Th","permalink":"https://tedmax100.github.io/tags/iT邦鐵人賽11Th/"}]},{"title":"Type & Struct, 從單細胞生物, 來到多細胞生物了","slug":"GoTypeStruct","date":"2020-12-20T14:44:21.000Z","updated":"2020-12-20T14:46:16.465Z","comments":true,"path":"2020/12/20/GoTypeStruct/","link":"","permalink":"https://tedmax100.github.io/2020/12/20/GoTypeStruct/","excerpt":"Type &amp; Struct, 從單細胞生物, 來到多細胞生物了可以創建類似Java的Class以及宣告屬性與方法​","text":"Type &amp; Struct, 從單細胞生物, 來到多細胞生物了可以創建類似Java的Class以及宣告屬性與方法​ Typetype這關鍵字用來聲明宣告一些東西 struct等下就介紹 interface下次介紹 基礎型別 123456789101112131415161718192021222324252627282930313233343536package mainimport ( \"fmt\")// 宣告別名type name = string// 定義新的基礎型別type newStr stringfunc SayName(str name) &#123; fmt.Println(str)&#125;func Say(str newStr) &#123; fmt.Println(str)&#125;func main() &#123; var str = \"test\" SayName(str) // 這行會噴型別錯誤, 註解掉用下面的方式寫 // Say(str) var ns newStr ns = \"test newStr\" Say(ns)&#125;/*main.go:25:6: cannot use str (type string) as type newStr in argument to Saystr是字串類型, 可以傳入也是string但卻是別名的SayName, 可見類型一致.但透過type宣告出來的基礎型別, 卻是不同的類型, 無法傳入使用string的Say.*/ 類型查詢 123456789//在switch使用變數名稱.(type), 查詢變數是由哪種類型賦值的switch v := a.(type) &#123; case string: fmt.Println(\"string type\") case int: fmt.Println(\"int type\") default: fmt.Println(\"other type\", v)&#125; StructStruct(結構體)是類型中帶有屬性成員的複合類型.其實就非常類似其他語言的Class (87%相似)用結構體名稱和結構體屬性來描述真實世界的實體和實體對應的各種屬性. 每個屬性必須要有自己的類型和值 屬性名稱在結構體內必須唯一 屬性的類型也可以是結構體, 或是自己所在的結構體的指針, 但不能跟是自己的類型. 可以屬性都不要設置, 稱為empty struct, 能用來給channel發訊號用. 屬性成員名稱小寫開頭為private, 大寫為public 沒有繼承, 用的是組合這概念, 這部份更多應用明天分享. 1234567type 類型名稱 struct &#123; 屬性1 屬性1類型 屬性2 屬性2類型 屬性3, 屬性4, 屬性5 屬性345類型 (需要相同類型) 類型 // 匿名屬性, 類型名稱就是成員屬性名稱 ...&#125; 初始化有很多種方式…這裡有沒有列出全部, 我也不太清楚QQJS要建立一個object, 也是超多種方式XD 12345678// 匿名結構體, 無須透過type關鍵字來定義p := struct &#123; X int Y int&#125; &#123; X : 20, Y : 10,&#125; 123456789// 透過var聲明type Point struct &#123; X int Y int&#125;var p Pointp.X = 20p.Y = 10 12345// 透過var的簡短聲明var p = Point&#123; X: 20, Y: 10,&#125; 1234// 透過new實例出結構體,p是一個Point指標類型, 指向Point結構體的實例. p := new(Point)p.X = 20p.Y = 10 new()的方法介面 : 回傳的就是指向該類型的指標func new(Type) *Type 12345678910111213141516171819202122// 因為沒有類別也沒多載, 所以用各種不同名稱的外部方法來模擬建構式func NewEmptyPoint() Point &#123; return Point&#123; &#125;&#125;func NewPoint(x, y int) Point &#123; return Point&#123; X : x, Y : y, &#125;&#125;func NewEmptyPointPtr() *Point &#123; return &amp;Point&#123; &#125;&#125;func NewPointPtr(x, y int) *Point &#123; return &amp;Point&#123; X : x, Y : y, &#125;&#125; 1234567891011121314151617181920212223// demo/pointer.gopackage pointertype Point struct &#123; X int Y int&#125;func New(x, y int) Point &#123; return &amp;Point&#123; X : x, Y : y, &#125;&#125;// main.gopackage mainimport \"demo/pointer\"func main() &#123; // 這樣有沒有比較像建構式的feel了 p := pointer.New(10, 20)&#125; 這裡會發現跟C有些不同了, C對於ptr類型需要用-&gt;來存取成員屬性.Go施予了語法糖來方便開發者, 自動的把ptr類型的p.X轉成(*p).X Pointer to Struct vs Struct value上面會發現struct在使用上會有pointer to struct(結構體指針)跟Struct value(結構體實例)2種類型. 結構體指針 一個指向結構體實例的ptr 傳遞給函數當參數時, 就只會複製該ptr而已, 省很多記憶體, 也快速. 對結構體指針作任何修改, 都會影響到該指針所指向的結構體去作修改. 要直接操作指向的對象時,要加上* 會發生逃逸現象, 需要透過GC來回收. 結構體指針的空值都是nil 結構體實例 傳遞給函數當參數時, 會複製物件本身. 傳遞給函數時, 會放在stack內; 在離開函數時, 會被釋放. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport \"fmt\"type Bag struct &#123; items []int&#125;func Insert(b *Bag, itemId int) &#123; fmt.Printf(\"address of *b: %p\\n\", b) b.items = append(b.items, itemId)&#125;func InsertValue(b Bag, itemId int) Bag &#123; fmt.Printf(\"address of b: %p\\n\", &amp;b) b.items = append(b.items, itemId) return b&#125;func main() &#123; bag := new(Bag) fmt.Printf(\"address of bag: %p\\n\", bag) fmt.Println(\"新增元素前給ptr: \", bag) Insert(bag, 1000) fmt.Println(\"新增元素後給ptr: \", bag) bagValue := Bag&#123;&#125; fmt.Printf(\"address of bagValue: %p\\n\", bag) fmt.Println(\"新增元素前給實例前: \", bagValue) InsertValue(bagValue, 1001) fmt.Println(\"新增元素後, 但沒賦值回去: \", bagValue) bagValue = InsertValue(bagValue, 1001) fmt.Println(\"新增元素後, 有沒賦值回去: \", bagValue)&#125;/*address of bag: 0xc00000c080新增元素前給ptr: &amp;&#123;[]&#125;address of *b: 0xc00000c080新增元素後給ptr: &amp;&#123;[1000]&#125;address of bagValue: 0xc00000c080新增元素前給實例前: &#123;[]&#125;address of b: 0xc00000c100新增元素後, 但沒賦值回去: &#123;[]&#125;address of b: 0xc00000c140新增元素後, 有沒賦值回去: &#123;[1001]&#125;*/ 看完輸出能發現, 透過指針傳遞的都是指向同一個位置的變數, 我們對它作操作, 在方法結束後, 他的改變都是有效的.透過值傳遞, 都不是同一個變數, 都是透過複製出來的副本, 所以要透過回傳, 再把回傳值複製一份給外面, 不然就不會真的作到修改. 結構體方法Go中的方法, 適用於特定類型的函數. 稱為Receiver(接收器)如果該特定類型是結構體實例或者是結構體指針時.接收器的概念就類似JS的this. 就是方法作用的目標!!當然任何類型都可以有自己的方法. 12345// (b *Bag) 這個就是接收器, 接受來自Point類型的指標func (b *Bag) Insert(itemId int) &#123;...&#125;// (b Bag) 這個就是接收器, 接受來自Point實例func (b Bag) Insert(itemId int) &#123;...&#125; 接收器的命名官方建議receiver的名字, 第一個字小寫, 而不是用self/this等命名. 接收器的類型選擇在結構體方法的接收器是要用值還是指標…蠻難抉擇的, 大部分都是用指標.只有小部份情形會用值傳遞. map, func, chan 其實引用類型(reference type), 都是指針了,別再用一個指針指向他們, 然後作操作. 如果結構體內有sync.Mutex或其他跟同步相關字眼的, 也別傳值, 傳指針, 讓各地方都用同一個記憶體空間作同步操作. 如果想要呼叫的函數, 就直接能作內容修改, 就傳指針 如果是自定義的結構體、Array、Slice就傳指針, 不用多複製; 且意圖更明顯, 就是在操作該物件自己; 官方建議如果Array容量很小還是傳值比較好, 但我自己不太清楚怎樣去定義”小”, 所以我還是都傳指針. 如果是基礎型別或者是內建的型別(time.Time這種), 它內部沒有指針屬性或者沒有mutable屬性時, 就傳值, 就不會發生逃逸進到Heap等待GC. 不清楚? 就是傳指針 但又如何XD反正Go其實就只有傳值這概念, 只是傳的如果是指針類型, 還是複製一份指針的副本.上面有提到會把ptr類型轉成(*ptr), 直接指向該物件去操作.所以官方才說不清楚判斷該傳什麼, 就傳指針. 我們要清楚的是, 該類型到底是基礎型別還是引用類型(), 這2種都傳值裡面有沒有同步需要用到的mutex這些, 有就是傳值,其他都傳ptr 就行了. 引用類型的範例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package mainimport \"fmt\"func PrintMap(m map[string]int) &#123; fmt.Printf(\"address of map: %p\\n\", m)&#125;func PrintFunc(f func()) &#123; fmt.Printf(\"address of func: %p\\n\", f)&#125;func PrintChan(c chan int) &#123; fmt.Printf(\"address of chan: %p\\n\", c)&#125;func PrintSlice(s []int) &#123; fmt.Printf(\"address of slice: %p\\n\", s)&#125;func PrintArray(a [3]int) &#123; fmt.Printf(\"address of array: %p\\n\", &amp;a)&#125;func PrintArrayPtr(a *[3]int) &#123; fmt.Printf(\"address of array: %p\\n\", a)&#125;func main() &#123; m := make(map[string]int) fmt.Printf(\"address of map: %p\\n\", m) PrintMap(m) fun := func() &#123; fmt.Println(\"func\") &#125; fmt.Printf(\"address of func: %p\\n\", fun) PrintFunc(fun) channel := make(chan int) fmt.Printf(\"address of chan: %p\\n\", channel) PrintChan(channel) s := make([]int, 10) fmt.Printf(\"address of slice: %p\\n\", s) PrintSlice(s) // Array不是引用類型 a := [3]int&#123;1, 2, 3&#125; fmt.Printf(\"value of array: %p\\n\", a) fmt.Printf(\"address of array: %p\\n\", &amp;a) PrintArray(a) PrintArrayPtr(&amp;a)&#125;/*address of map: 0xc000078150address of map: 0xc000078150address of func: 0x489520address of func: 0x489520address of chan: 0xc000076060address of chan: 0xc000076060address of slice: 0xc0000200f0address of slice: 0xc0000200f0value of array: %!p([3]int=[1 2 3])address of array: 0xc000018560address of array: 0xc0000185a0address of array: 0xc000018560*/ 很明顯這些都是引用類型, 我們操作的一直都是指針類型的變數,就不必再用一個指針去指向它們了. 後面的0xnnnnnn數字不同, 每次跑我也都不同, 那是記憶體開始位置, 每次都會不同的, so…跑出來跟我範例不同, 不是程式寫錯QQ [Go 語言教學影片] 在 struct 內的 pointers 跟 values 差異這是AppleBoy大大的影片, 有提到goroutine內傳指標會出現的問題. 鐵人賽連結","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"},{"name":"iT邦鐵人賽11Th","slug":"iT邦鐵人賽11Th","permalink":"https://tedmax100.github.io/tags/iT邦鐵人賽11Th/"}]},{"title":"Map","slug":"GoMap","date":"2020-12-20T14:42:24.000Z","updated":"2020-12-20T14:44:52.664Z","comments":true,"path":"2020/12/20/GoMap/","link":"","permalink":"https://tedmax100.github.io/2020/12/20/GoMap/","excerpt":"​","text":"​ MapMap是一種透過Key來取得Value的一種資料結構, 目的是為了快速查找用O(1).為什麼MAP能這麼快定位到資料是否存在，或資料本身的位置因為它使用更多資訊來紀錄資料放在哪邊就像關聯式資料庫的索引，以空間來換取時間 (反正現在記憶體夠大夠便宜XD)而Key具唯一性,在Map中若Key重複, 會把Value作後蓋前的更新. Java的話是HashMap, C# &amp; Python則是Dictionary.Go的map是一張hash table的引用, 它是一個無序的key/value成對的集合.Key跟Value可以是不同類型, 但在同一個map內的key一定要同一種類型. 底層實現Go在map的底層實現是透過之前提到的Array+List去實現的.Go這裡把hash table稱為buckets是個Array.bucket內每個元素是指向一串List, 每個節點為bmap, 裡面最多放8組key和value.根據Hash函數獲得key的特徵值, 作為hash key去映射看是對到哪個bucket.所以查找Hash table只需要O(1). 如果特徵值重複, 表示元素發生碰撞. 碰撞的元素就會放在同一個特徵值的list中.當bmap因為最多放8組key, 超過多的會放到overflow這裡.然後同一list的bmap過多的話, 會進行擴容. 盡量避免碰撞發生. 更多詳情能看連結, 有更多大神整理出文章. cch123/map.md Map格式1map[KeyType]ValueType 初始化Mapmap是內建型別, 所以不需要額外import任何lib. map是個reference type.不是透過該2種方式創建的話, 後續在存取上會引生panic錯誤 12// make創建map變數 := make(map[keyType]valueType) 123// 直接實例化, 大括號內能給key:valuemap變數 := map[keyType]valueType&#123;&#125;map變數 := map[string]int&#123;\"C\":5, \"B\":6&#125; 注意 12345678// 通過宣告但沒實例化var colors map[string]stringcolors[\"red\"] = \"#da1337\"// 會出現error// siignment to entry in nil map// 這是因為使用一個沒初始化的map, 其實你得到的是一個指向nil的指標而已. 操作方法新增元素1map變數[key] = value 刪除元素使用delete() 1delete(map變數, key) 查詢取值查詢分兩類, 一種直接給key; 一種是走訪, 不需要知道key Key查找 直接取值1v := map變數[key] 1234value := colors[\"blue\"]// 直接判斷value是否為零值; key不在, 是返回該valuetype的零值if value != \"\" &#123;...&#125; 取值和取得這key是否存在的標誌1v, exist := map變數[key] 1234value, exists := colors[\"blue\"]// 判斷key是否存在if exists != \"\" &#123;...&#125; 走訪, 就不必知道key了 为什么遍历 Go map 是无序的？ 1for key, value := range map變數 &#123;...&#125; 123456789101112131415161718192021222324252627282930313233package mainimport \"fmt\"func main() &#123; mapDemo := map[int]int&#123; 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, &#125; for k, v := range mapDemo &#123; fmt.Println(\"value :\", v, \", key : \", k) &#125;&#125;/*value : 9 , key : 9value : 10 , key : 10value : 6 , key : 6value : 7 , key : 7value : 3 , key : 3value : 4 , key : 4value : 5 , key : 5value : 8 , key : 8value : 1 , key : 1value : 2 , key : 2*/ 疑, 為什麼走訪順序不如預期中的那樣排序.雖然前面有提過本質是hash table本來就是無序的.但小弟稍微提一下, 更多大神有針對這情況作討論.Go是random key的方式挑選要從哪個開始走訪.但是有自己一套隨機函數, 讓挑中每個元素的機會都是一樣的.也是為了避免太常挑到array裡是nil的部份. 清空map抱歉…Go沒有清空的方法, 就是重新make一個新的map.不必去擔心GC的效率. 1map變數 := make(map[keyType]valueType) 取得map的元素個數 1len(map變數) 基本範例1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport \"fmt\"func main() &#123; // 初始化一個key是string, value是int的map m := make(map[string]int) // 依據key 塞值 m[\"k1\"] = 7 m[\"k2\"] = 13 fmt.Println(\"map:\", m) // 依據key取值 v1 := m[\"k1\"] fmt.Println(\"v1: \", v1) // 取得map的長度 fmt.Println(\"len:\", len(m)) // 根據key刪除元素 delete(m, \"k2\") fmt.Println(\"map:\", m) // 判斷k2在不再map內 _, prs := m[\"k2\"] fmt.Println(\"prs:\", prs) // 從給定的元素直接去實例化map n := map[string]int&#123;\"foo\": 1, \"bar\": 2&#125; fmt.Println(\"map:\", n)&#125;/*map: map[k1:7 k2:13]v1: 7len: 2map: map[k1:7]prs: falsemap: map[bar:2 foo:1]*/ Sync.Map因為map在併發情況下讀寫map, 並沒保證線程安全. 123456789101112131415161718192021222324252627package mainfunc main() &#123; m := make(map[int]int) // 一條goroutine 拼命塞值 go func() &#123; for &#123; m[1] = 1 &#125; &#125;() // 一條goroutine 拼命取值 go func() &#123; for &#123; _ = m[1] &#125; &#125;() // 無窮迴圈 for &#123; &#125;&#125;/*fatal error: concurrent map read and map write*/ 噴錯了!! 因為使用了兩個goroutine併發的讀跟寫,在讀取時, 會檢查hashWriting這標記, 如果這標記為true, 產生了race condition.map內部機制會對這種併發操作進行檢查並提早發現.當然也能透過加上讀寫鎖, 來保證線程安全. 但這樣效能很差. Go則是提供了sync.Map, 該結構具有這些特性: 無須初始化, 只需要聲明宣告 不能透過上面的操作方法, 要用Store/Load/Delete/LoadOrStore/Range來操作 Lock-free, 採用CAS演算法 沒提供len()方法123456type Map struct &#123; mu Mutex // 給dirty map用的 read atomic.Value // readOnly, 這本身保證線程安全 dirty map[interface&#123;&#125;]*entry misses int&#125; 操作方式Store 儲存一組key跟value1func (m *Map) Store(key, value interface&#123;&#125;) &#123;...&#125; Load 依靠key來尋找, 如果存在返回值跟true ; 不存在就返回nil跟false1func (m *Map) Load(key interface&#123;&#125;) (value interface&#123;&#125;, ok bool) &#123;...&#125; LoadOrStore 依靠key來尋找, 如果存在返回value跟true ; 不存在就新增key跟value, 並返回false1func (m *Map) LoadOrStore(key, value interface&#123;&#125;) (actual interface&#123;&#125;, loaded bool) &#123;...&#125; Delete 依靠key來刪除1func (m *Map) Delete(key interface&#123;&#125;) &#123;...&#125; Range 走訪讀取map中元素的key和value傳給函數f1func (m *Map) Range(f func(key, value interface&#123;&#125;) bool) &#123;...&#125; 基本範例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mainimport ( \"fmt\" \"sync\")var printMap = func(key, value interface&#123;&#125;) bool &#123; fmt.Printf(\"key: %s, value: %d\\n\", key, value) return true&#125;func main() &#123; // 初始化sync.map var m sync.Map // 新增元素 m.Store(\"k1\", 7) m.Store(\"k2\", map[string]int&#123;\"k4\": 5&#125;) // 走訪map m.Range(printMap) fmt.Println(\"------------\") // 依據key讀取元素 v1, _ := m.Load(\"k1\") fmt.Println(\"v1: \", v1) fmt.Println(\"------------\") // 依照key 刪除元素 m.Delete(\"k2\") // 讀取或是新增元素 v1, exist := m.LoadOrStore(\"k1\", 8) fmt.Printf(\"v1: %d, exist: %v\\n\", v1, exist) v3, exist3 := m.LoadOrStore(\"k3\", 2) fmt.Printf(\"v3: %d, exist: %v\\n\", v3, exist3) m.Range(printMap) fmt.Println(\"------------\") _, exist2 := m.Load(\"k2\") fmt.Printf(\"v3 exist: %v\\n\", exist2)&#125;/*key: k1, value: 7key: k2, value: map[%!d(string=k4):5]------------v1: 7------------v1: 7, exist: truev3: 2, exist: falsekey: k1, value: 7key: k3, value: 2------------v3 exist: false*/ 鐵人賽連結","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"},{"name":"iT邦鐵人賽11Th","slug":"iT邦鐵人賽11Th","permalink":"https://tedmax100.github.io/tags/iT邦鐵人賽11Th/"}]},{"title":"3兄弟-Ring","slug":"3兄弟-Ring","date":"2020-12-20T14:37:57.000Z","updated":"2020-12-20T14:38:52.270Z","comments":true,"path":"2020/12/20/3兄弟-Ring/","link":"","permalink":"https://tedmax100.github.io/2020/12/20/3兄弟-Ring/","excerpt":"這隻又跑出來了XDRing其實就是雙向環鏈(circular doubled linked list)用這圖, 是想表達, 我們有一個歌單可以單向依序放到完, 當然也能選擇循環依序播放阿 !!!Ring可以滿足這行為的操作!!​","text":"這隻又跑出來了XDRing其實就是雙向環鏈(circular doubled linked list)用這圖, 是想表達, 我們有一個歌單可以單向依序放到完, 當然也能選擇循環依序播放阿 !!!Ring可以滿足這行為的操作!!​ Ring只有一個Value屬性,開發者可以任意操作.prev, next都是給操作方法操作用的. 1234type Ring struct &#123; next, prev *Ring Value interface&#123;&#125; &#125; ​ Ring vs List可以發現Ring的結構跟List超像. 結構差別是List是由List和Element類別兩個聯合表示; 而Ring自己就能代表值和關聯. Ring一開始要指定初始元素個數, 被創建出來後, 長度就不可變; 但List則不必, 也沒這必要. 通過var聲明的Ring的零值是長度為1的環鏈; 而List的零值則是長度為0的雙向鏈結, 因為只有root ptr, 並沒有指向任何元素. Ring的Len()是O(N), 它需要把每個元素走訪一次直到走到自己; List的則是O(1), 因為有個len變數在紀錄長度. 這在某些情境上, 大大影響效能.​初始化 透過New(size), 生出長度為size的Ring 123456789101112131415161718192021// New creates a ring of n elements.func New(n int) *Ring &#123; if n &lt;= 0 &#123; return nil &#125; r := new(Ring) p := r for i := 1; i &lt; n; i++ &#123; p.next = &amp;Ring&#123;prev: p&#125; p = p.next &#125; p.next = r r.prev = p return r&#125;​func (r *Ring) init() *Ring &#123; r.next = r r.prev = r return r&#125; 透過宣告, 生出長度為1的Ring 1var ring變數 ring.Ring ​ 操作方法 透過next取得下一個元素 1func (r *Ring) Next() *Ring &#123;...&#125; 透過prev取得前一個元素 1func (r *Ring) Prev() *Ring &#123;...&#125; 讓目前環鏈依據目前所在的元素位置, 往前(n&lt;0)或是往後(n&gt;0)移動數個位置 1func (r *Ring) Move(n int) *Ring &#123;...&#125; 讓目前的環鏈與另一個環鏈作連結, s會插入到r目前指向的元素後面, 返回插入前, r.Next()所表示的元素如果r跟s指向的是同一個ring, 就會刪掉r跟s之間的元素,被刪掉的元素會組成一個新的ring, 返回的就是指向這新ring的指針 1func (r *Ring) Link(s *Ring) *Ring &#123;...&#125; 從當前環鏈所在的Next()依序刪除n個元素, 返回值是被刪除的元素們 1func (r *Ring) Unlink(n int) *Ring &#123;...&#125; 取得環鏈元素個數, 複雜度為O(N) 1func (r *Ring) Len() int &#123;...&#125; 傳入一個函數, Do會依序地讓每個元素的Value當作參數去執行該函數; 類似JS的map()也能透過累加數值在外部變數上或者實做策略模式, 執行每個元素的封裝行為.但要避免函數f去改變了r, 會發生不可預期的行為. 1func (r *Ring) Do(f func(interface&#123;&#125;)) &#123;...&#125; 基本範例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package main​import ( \"container/ring\" \"fmt\")​// 宣告一個要給Do()執行的函數, 用來列印值而已var printRing = func(v interface&#123;&#125;) &#123; fmt.Print(v.(int), \"-&gt;\")&#125;​// 只是用來呼叫r.Do跟代入printRing, 只是多一個換行func PrintRing(r *ring.Ring) &#123; r.Do(printRing) fmt.Println()&#125;​func main() &#123; // 透過var 來宣告ring var varRing ring.Ring // 查看透過var宣告的ring的長度 fmt.Println(\"查看透過var宣告的ring的長度: \", varRing.Len()) fmt.Println(\"----------------------\") //透過New創建10個元素的ring r := ring.New(10) // 查看透過New()初始化ring的長度 fmt.Println(\"查看透過New()初始化ring的長度: \", r.Len()) // 給ring中每個元素進行走訪並且給值 for i := 0; i &lt; 10; i++ &#123; r.Value = i // 取得下一個元素 r = r.Next() &#125; fmt.Print(\"r : \") PrintRing(r)​ // 往後移動ring的指向 r = r.Move(2) fmt.Println(\"ring 向後移動2個位置的元素值:\", r.Value)​ // 往前移動ring的指向 r = r.Move(-8) fmt.Println(\"ring 向前移動8個位置的元素值:\", r.Value)​ // 從ring當前指向開始刪除n個元素 deletedElm := r.Unlink(2) fmt.Print(\"r 所剩下的元素 : \") PrintRing(r) fmt.Print(\"從r刪除的元素 : \") PrintRing(deletedElm)​ // 準備第2個ring r2 r2 := ring.New(3) for i := 0; i &lt; 3; i++ &#123; r2.Value = i + 10 r2 = r2.Next() &#125; fmt.Print(\"r2 : \") PrintRing(r2)​ fmt.Println(\"現在r的指向在 :\", r.Value) // Link r 跟 r2 fmt.Print(\"Link r 跟 r2 : \") linkedRing := r.Link(r2) PrintRing(r)​ // 以原本r.Next()開始走訪 fmt.Print(\"以原本r.Next()開始走訪 : \") PrintRing(linkedRing)&#125;/*查看透過var宣告的ring的長度: 1----------------------查看透過New()初始化ring的長度: 10r : 0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9-&gt;ring 向後移動2個位置的元素值: 2ring 向前移動8個位置的元素值: 4r 所剩下的元素 : 4-&gt;7-&gt;8-&gt;9-&gt;0-&gt;1-&gt;2-&gt;3-&gt;從r刪除的元素 : 5-&gt;6-&gt;r2 : 10-&gt;11-&gt;12-&gt;現在r的指向在 : 4Link r 跟 r2 : 4-&gt;10-&gt;11-&gt;12-&gt;7-&gt;8-&gt;9-&gt;0-&gt;1-&gt;2-&gt;3-&gt;以原本r.Next()開始走訪 : 7-&gt;8-&gt;9-&gt;0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;10-&gt;11-&gt;12-&gt;*/ 輪播範例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package main​import ( \"container/ring\" \"fmt\" \"time\")​// song類別type song struct &#123; name string artist string length time.Duration&#125;​// 定義歌單var ( songs = []song&#123; &#123; name: \"Something Just Like This\", artist: \"The Chainsmokers\", length: 247, &#125;, &#123; name: \"Blame\", artist: \"Calvin Harris\", length: 214, &#125;, &#123; name: \"Wolves\", artist: \"Selena Gomez\", length: 197, &#125;, &#123; name: \"Sing You To Sleep\", artist: \"Matt Cab\", length: 236, &#125;, &#125;)​func main() &#123; // 載入歌單 songList := ring.New(len(songs)) repeatedCnt := 0​ for i := 0; i &lt; songList.Len(); i++ &#123; songList.Value = songs[i] songList = songList.Next() &#125;​ // 開始播放 for &#123; if repeatedCnt == 1 &#123; break &#125; songList.Do(func(v interface&#123;&#125;) &#123; time.Sleep((v.(song).length / 100) * time.Second) // 加速播放 fmt.Printf(\"現正播放%s, 演唱者為%s\\n\", v.(song).name, v.(song).artist) &#125;) repeatedCnt++ fmt.Printf(\"播放次數 : %d\\n\", repeatedCnt) &#125;​ fmt.Println(\"播放完畢\")&#125;/*現正播放Something Just Like This, 演唱者為The Chainsmokers現正播放Blame, 演唱者為Calvin Harris現正播放Wolves, 演唱者為Selena Gomez現正播放Sing You To Sleep, 演唱者為Matt Cab播放次數 1: 現正播放Something Just Like This, 演唱者為The Chainsmokers現正播放Blame, 演唱者為Calvin Harris現正播放Wolves, 演唱者為Selena Gomez現正播放Sing You To Sleep, 演唱者為Matt Cab播放次數 2: 現正播放Something Just Like This, 演唱者為The Chainsmokers現正播放Blame, 演唱者為Calvin Harris現正播放Wolves, 演唱者為Selena Gomez現正播放Sing You To Sleep, 演唱者為Matt Cab播放次數 3: 播放完畢*/ ​ 3兄弟各自適合的使用場景 List FIFO queue Heap 排序 Priority queue 定時器 Ring 上面提到的輪播 保存近n筆操作日誌​應該還有更多, 我暫時還沒想到, 歡迎大家補充給我.感謝各位. 鐵人賽連結","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"},{"name":"iT邦鐵人賽11Th","slug":"iT邦鐵人賽11Th","permalink":"https://tedmax100.github.io/tags/iT邦鐵人賽11Th/"}]},{"title":"Container 3兄弟-Heap","slug":"3兄弟-Heap","date":"2020-12-20T14:16:31.000Z","updated":"2020-12-20T14:17:15.614Z","comments":true,"path":"2020/12/20/3兄弟-Heap/","link":"","permalink":"https://tedmax100.github.io/2020/12/20/3兄弟-Heap/","excerpt":"","text":"HeapHeap(堆積)其實是一個Complete Binary Tree(完全二元樹).Go的Heap特性是 各個節點都自己是其子樹的根, 且值是最小的.同個根節點的左子樹的值會小於右子樹.所以根節點的值是最小的, 位於索引0的位置.也有另一種是最大的(max heap), 只是Go這裡是最小的(min heap).定義 : n個元素 k1, k2,…ki…kn, 並且若且唯若滿足下列關係時稱為heapki &lt;= k2i, ki &lt;= k(2i+1) 或者 ki &gt;= k2i, ki &gt;= k(2i+1), i = 1,2,3…,n/2又因為最小(或最大)的值, 取出該值都只要O(1)的時間. 通常該結構是用來實現(priority queue)優先隊列的方法之一. 能對任務工作作優先等級的排序用.底層還是以陣列形式表示 Dijkstra’s algorithm也是能用Heap做實現. Heap Interface這裡會提到接口interface, 之後會更詳細的介紹interface的部份 只要實現這些接口, 就可以操作heap提供的各種方法了.可以看得出來heap接口繼承了sort.Interface, 而sort.Interface內又有三個方法需要實現.繼承後面會有更詳細的部份介紹.總之就是要實現這5個方法就行了. 12345678910111213141516type Interface interface &#123; sort.Interface Push(x interface&#123;&#125;) // add x as element Len() Pop() interface&#123;&#125; // remove and return element Len() - 1.&#125;// sort.Interfacetype Interface interface &#123; // Len is the number of elements in the collection. Len() int // Less reports whether the element with // index i should sort before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int)&#125; 初始化Heap1heap.Init(customizeHeap) Heap內建的操作方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 一個滿足以上全部接口的堆積結構, 在操作前都要先執行Init()做初始化排序. // 複雜度O(log n), n = Len(), 因為是二元搜尋樹的查找func Init(h Interface) &#123; // heapify n := h.Len() for i := n/2 - 1; i &gt;= 0; i-- &#123; down(h, i, n) &#125;&#125;// 對Array增加一個新元素在最後面// 並透過up()重新排序把元素作上升, 來滿足min heap的要求.// 複雜度O(log n), n = Len()func Push(h Interface, x interface&#123;&#125;) &#123; h.Push(x) // 會呼叫我們自定義好的Push() up(h, h.Len()-1)&#125;// 刪除並且返回Len()-1位置的元素(Array最後一個的元素)// 等同於對Array做了取[:n-1]的動作, 等於是把第一個元素跟最後一個做了互換後, 透過down(), 把新的根節點下沉到適合的位置, 用來滿足min heap的要求.// Pop()跟Remove(h, 0 )是一樣的func Pop(h Interface) interface&#123;&#125; &#123; n := h.Len() - 1 h.Swap(0, n) down(h, 0, n) return h.Pop() // 會呼叫我們自定義好的Pop()&#125;// 如果heap中有元素的值被修改, 則透過Fix()重新排序, down() &amp; up()也會被呼叫.// 複雜度O(log n), n = Len()func Fix(h Interface, i int) &#123; if !down(h, i, h.Len()) &#123; up(h, i) &#125;&#125;// 刪除heap中第i個元素, 並且重新排序// 複雜度O(log n), n = Len()func Remove(h Interface, i int) interface&#123;&#125; &#123; n := h.Len() - 1 if n != i &#123; h.Swap(i, n) if !down(h, i, n) &#123; up(h, i) &#125; &#125; return h.Pop()&#125;// 把元素下沉到對應的子樹合適的位置上func down(h Interface, i0, n int) bool &#123;...&#125;// 把元素上升到對應的子樹合適的位置上func up(h Interface, j int) &#123;...&#125; 實現自定義的int Heap首先定義一個類型或是結構, 並且實現那5個方法.取官網的範例來說明 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package mainimport ( \"container/heap\" \"fmt\")// An IntHeap is a min-heap of ints.type IntHeap []int// 返回元素個數func (h IntHeap) Len() int &#123; return len(h) &#125;// 比較大小, 只要索引i的元素&lt;索引j的元素, 就會返回true, 否則返回false, 因為是Min Heap, 所以都在比小// Max Heap就是反過來比大, 但這方法名還是叫Less不能改就是了XDfunc (h IntHeap) Less(i, j int) bool &#123; return h[i] &lt; h[j] &#125;// 交換h[i]跟h[j]的元素, Golang對swap的寫法很簡單, 不必在創建temp變數在那裡賦值.func (h IntHeap) Swap(i, j int) &#123; h[i], h[j] = h[j], h[i] &#125;// 新增元素func (h *IntHeap) Push(x interface&#123;&#125;) &#123; *h = append(*h, x.(int))&#125;// Pop出最後一個元素func (h *IntHeap) Pop() interface&#123;&#125; &#123; old := *h n := len(old) // 把最後一個賦值給x x := old[n-1] // 建立一組新的slice , 取原有的slice 開始到n-1個元素, 並賦值 *h = old[0 : n-1] return x&#125;func main() &#123; h := &amp;IntHeap&#123;2, 1, 5&#125; heap.Init(h) heap.Push(h, 3) heap.Push(h, 4) heap.Push(h, 9) fmt.Printf(\"minimum: %d\\n\", (*h)[0]) // first : 1 for h.Len() &gt; 0 &#123; fmt.Printf(\"%d \", heap.Pop(h)) &#125; // 2 3 4 5 9 // 把上面走訪heap整段註解掉 // 修改第1個元素的值 // 會把原本h[1]的元素, 移動到適當的位置去 (*h)[1] = 6 // 讓heap重新排序 heap.Fix(h, 1) for h.Len() &gt; 0 &#123; fmt.Printf(\"%d \", heap.Pop(h)) &#125; // 2 4 5 6 9&#125; 實現Priority Queue官網範例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package mainimport ( \"container/heap\" \"fmt\")// 元素結構type Item struct &#123; value string // 元素的值 priority int // 元素的優先權值 index int // 紀錄索引值&#125;// PriorityQueue, 本質上是一個*item的Arraytype PriorityQueue []*Item// sort.Interface的實現// 返回元素個數func (pq PriorityQueue) Len() int &#123; return len(pq) &#125;// 因為希望Pop出來的是priority值最大的元素, 所以這裡的邏輯是反著寫// 其實這就是個Max Heap, 根節點的priority的值大於其他.func (pq PriorityQueue) Less(i, j int) bool &#123; return pq[i].priority &gt; pq[j].priority&#125;// 交換pq[i]跟pq[j]的元素, 這裡還要互換兩個元素彼此的indexfunc (pq PriorityQueue) Swap(i, j int) &#123; pq[i], pq[j] = pq[j], pq[i] pq[i].index = i pq[j].index = j&#125;// heap.Interface的實現// 新增元素在Array最後func (pq *PriorityQueue) Push(x interface&#123;&#125;) &#123; n := len(*pq) item := x.(*Item) // 這裡用類型斷言, 日後會補充 item.index = n // 設定新增進來元素的index *pq = append(*pq, item)&#125;// Pop出Array最後1個元素func (pq *PriorityQueue) Pop() interface&#123;&#125; &#123; old := *pq n := len(old) item := old[n-1] old[n-1] = nil // 把元素設置為沒有指向任何東西, 等GC來回收原來指向所配置出來的空間 item.index = -1 // 保險起見, 把pop出去的元素index設置成-1 *pq = old[0 : n-1] // 從old slice來取 0 ~ n-1的元素來形成新的slice, 並賦值給*pq return item&#125;// 更新元素的值和優先權, 並且重新排序func (pq *PriorityQueue) update(item *Item, value string, priority int) &#123; item.value = value item.priority = priority heap.Fix(pq, item.index)&#125;func main() &#123; items := map[string]int&#123; \"banana\": 3, \"apple\": 2, \"pear\": 4, &#125; pq := make(PriorityQueue, len(items)) i := 0 for value, priority := range items &#123; pq[i] = &amp;Item&#123; value: value, priority: priority, index: i, // 依照清單個數, 依序給index &#125; i++ &#125; // 初始化Heap heap.Init(&amp;pq) // 新增一個新元素 item := &amp;Item&#123; value: \"orange\", priority: 1, &#125; heap.Push(&amp;pq, item) // 修改該元素 pq.update(item, item.value, 5) // 依序Pop出來 for pq.Len() &gt; 0 &#123; item := heap.Pop(&amp;pq).(*Item) fmt.Printf(\"%.2d:%s \", item.priority, item.value) &#125;&#125;// 05:orange 04:pear 03:banana 02:apple 初始化完成時的heap跟Array 新增orange, 並修改優先權後, 明顯orange被上升到合適的位置了 依序Pop出來 我發現Array位置沒改對…原諒我, 懶得修圖了 - .-但二元樹是對的!’LeetCode 23 可以嘗試用heap來實現小弟我日後補上 鐵人賽連結","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"},{"name":"iT邦鐵人賽11Th","slug":"iT邦鐵人賽11Th","permalink":"https://tedmax100.github.io/tags/iT邦鐵人賽11Th/"}]},{"title":"Container 3兄弟-List","slug":"3兄弟-List","date":"2020-12-20T13:26:42.000Z","updated":"2020-12-20T14:17:18.050Z","comments":true,"path":"2020/12/20/3兄弟-List/","link":"","permalink":"https://tedmax100.github.io/2020/12/20/3兄弟-List/","excerpt":"Go有提供幾種 List、Heap、Ring來依序玩看看","text":"Go有提供幾種 List、Heap、Ring來依序玩看看 List 因為上篇講Array &amp; Slice, 這兩種底層都需要連續的記憶體空間來配置.List則是可以非連續空間的容器, 也可以支援快速增刪元素.List由多個節點所組成的, 節點之間透過一些變數紀錄彼此的關係.且List並沒有限制每個節點的元素類型. 所以可以是任意類型.但後續轉換時就要注意. List有多種實現方式 : Single Linked List Double Linked List : Go內建這個類型, 相較於single linked list, 在增刪元素時不需要移動元素, 可以原地增刪. 還能夠雙向走訪. 這是List 的source code, 可以看到有next, prev這兩個ptr, 指向前後各一個元素的位置.呼叫Init()時, prev, next都指向root節點. 123456789101112131415161718192021222324252627282930313233// Element is an element of a linked list.type Element struct &#123; // Next and previous pointers in the doubly-linked list of elements. // To simplify the implementation, internally a list l is implemented // as a ring, such that &amp;l.root is both the next element of the last // list element (l.Back()) and the previous element of the first list // element (l.Front()). next, prev *Element // The list to which this element belongs. list *List // The value stored with this element. Value interface&#123;&#125;&#125;// List represents a doubly linked list.// The zero value for List is an empty list ready to use.type List struct &#123; root Element // sentinel list element, only &amp;root, root.prev, and root.next are used len int // current list length excluding (this) sentinel element&#125;// Init initializes or clears list l.func (l *List) Init() *List &#123; l.root.next = &amp;l.root l.root.prev = &amp;l.root l.len = 0 return l&#125;// New returns an initialized list.func New() *List &#123; return new(List).Init() &#125; 初始化List12345// 透過New(), New會去呼叫Init()變數名稱 := list.New()// 透過聲明來初始化var 變數名稱 list.List 插入新元素PushFront、PushBack 可以在List的最前面或最後面增加元素.PushFront 是對目前List的root節點前面在多一個元素; 看原始碼會發現呼叫了insertValue(), 第二個參數是root, 然後又呼叫了insert(&amp;Element, root), 第一個參數是新增的元素, 第二個參數是該新增元素要插入在誰的後面, 這裡是安插在root後面.PushBack 是對目前List的尾巴節點後面多一個元素. InsertBefore、InsertAfter則是在被標記的元素前或後增加元素. 原始碼 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// insert inserts e after at, increments l.len, and returns e.func (l *List) insert(e, at *Element) *Element &#123; n := at.next at.next = e e.prev = at e.next = n n.prev = e e.list = l l.len++ return e&#125;// insertValue is a convenience wrapper for insert(&amp;Element&#123;Value: v&#125;, at).func (l *List) insertValue(v interface&#123;&#125;, at *Element) *Element &#123; return l.insert(&amp;Element&#123;Value: v&#125;, at)&#125;// PushFront inserts a new element e with value v at the front of list l and returns e.func (l *List) PushFront(v interface&#123;&#125;) *Element &#123; l.lazyInit() return l.insertValue(v, &amp;l.root)&#125;// PushBack inserts a new element e with value v at the back of list l and returns e.func (l *List) PushBack(v interface&#123;&#125;) *Element &#123; l.lazyInit() return l.insertValue(v, l.root.prev)&#125;// InsertBefore inserts a new element e with value v immediately before mark and returns e.// If mark is not an element of l, the list is not modified.// The mark must not be nil.func (l *List) InsertBefore(v interface&#123;&#125;, mark *Element) *Element &#123; if mark.list != l &#123; return nil &#125; // see comment in List.Remove about initialization of l return l.insertValue(v, mark.prev)&#125;// InsertAfter inserts a new element e with value v immediately after mark and returns e.// If mark is not an element of l, the list is not modified.// The mark must not be nil.func (l *List) InsertAfter(v interface&#123;&#125;, mark *Element) *Element &#123; if mark.list != l &#123; return nil &#125; // see comment in List.Remove about initialization of l return l.insertValue(v, mark)&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package mainimport ( \"container/list\" \"fmt\")func traverse(list *list.List) &#123; // 走訪list fmt.Printf(\"root -&gt; \") for el := list.Front(); el != nil; el = el.Next() &#123; fmt.Printf(\"%v -&gt; \", el.Value) &#125;&#125;func main() &#123; // 宣告一個List, 並且初始化 list := list.New() // 最後面新增20 list.PushBack(20) // 最前面新增10 list.PushFront(\"10\") // 最後面新增25, 並且保存該新增元素到變數上 element := list.PushBack(25) // 在該元素後面新增26 list.InsertAfter(\"26\", element) // 在該元素前面新增26 list.InsertBefore(24, element) traverse(list) fmt.Println(\"\\n---------------------\") // element 換到第一個元素的後面 list.MoveAfter(element, list.Front()) traverse(list) fmt.Println(\"\\n---------------------\") // element 換到第一個元素的前面 list.MoveBefore(element, list.Front()) traverse(list) fmt.Println(\"\\n---------------------\") // element 換到最後面 list.MoveToBack(element) traverse(list) fmt.Println(\"\\n---------------------\") // element 換到最前面 list.MoveToFront(element) traverse(list) fmt.Println(\"\\n---------------------\") // 移除該元素 list.Remove(element) traverse(list)&#125;/*root -&gt; 10 -&gt; 20 -&gt; 24 -&gt; 25 -&gt; 26 -&gt; ---------------------root -&gt; 10 -&gt; 25 -&gt; 20 -&gt; 24 -&gt; 26 -&gt; ---------------------root -&gt; 25 -&gt; 10 -&gt; 20 -&gt; 24 -&gt; 26 -&gt; ---------------------root -&gt; 10 -&gt; 20 -&gt; 24 -&gt; 26 -&gt; 25 -&gt; ---------------------root -&gt; 25 -&gt; 10 -&gt; 20 -&gt; 24 -&gt; 26 -&gt; ---------------------root -&gt; 10 -&gt; 20 -&gt; 24 -&gt; 26 -&gt; */ 走訪List走訪List需要配合Front()取得第一個元素, 開始往下走訪.每次就呼叫目前元素的Next(), 只要元素不是nil 就能繼續往下走.也能逆向往前走, 改用Prev()就可. 取得List長度1list.Len() List vs Slice比較新增元素、插入元素、走訪的速度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package mainimport ( \"container/list\" \"fmt\" \"time\")func main() &#123; t := time.Now() sli := make([]int, 10) for i := 0; i &lt; 1*100000*1000; i++ &#123; sli = append(sli, 1) &#125; fmt.Println(\"Slice 新增元素耗費：\" + time.Now().Sub(t).String()) // 比较走訪 t = time.Now() for _ = range sli &#123; &#125; fmt.Println(\"走訪Slice耗費:\" + time.Now().Sub(t).String()) // 比較插入元素 t = time.Now() slif := sli[:100000*500] slib := sli[100000*500:] slif = append(slif, 10) slif = append(slif, slib...) fmt.Println(\"Slice 的插入元素耗費 : \" + time.Now().Sub(t).String()) // 比較刪除元素 t = time.Now() index := 100000 _ = append(sli[:index], sli[index+1:]...) fmt.Println(\"Slice 的刪除元素耗費 : \" + time.Now().Sub(t).String()) sli = make([]int, 10) // ---------Slice end, start list fmt.Println(\"------------------------------\") t = time.Now() l := list.New() for i := 0; i &lt; 1*100000*1000; i++ &#123; l.PushBack(1) &#125; fmt.Println(\"List 新增元素耗費: \" + time.Now().Sub(t).String()) t = time.Now() for e := l.Front(); e != nil; e = e.Next() &#123; &#125; fmt.Println(\"走訪List耗費:\" + time.Now().Sub(t).String()) var em *list.Element i := 0 // 找到1/3處的元素 for e := l.Front(); e != nil; e = e.Next() &#123; i++ if i == l.Len()/3 &#123; em = e break &#125; &#125; // 因為是記算插入元素的速度, 所以忽略查找的時間 t = time.Now() l.InsertAfter(2, em) fmt.Println(\"List 的插入元素耗費 : \" + time.Now().Sub(t).String()) // 比較刪除元素 t = time.Now() l.Remove(em) fmt.Println(\"List 的刪除元素耗費:\" + time.Now().Sub(t).String())&#125;/*Slice 新增元素耗費：1.749752738s走訪Slice耗費:35.548381msSlice 的插入元素耗費 : 46.402953msSlice 的刪除元素耗費 : 92.097862ms------------------------------List 新增元素耗費: 17.721431965s走訪List耗費:364.763942msList 的插入元素耗費 : 2.17µsList 的刪除元素耗費:73ns*/ 結論對於資料量很多的情境下,如果很頻繁的插入或是刪除, List的成本低到幾乎可以不計算.但如果頻繁的新增或是走訪查找, Slice的效能高過List許多. 首圖是參考該文章的, 該文有講單鏈, 雙鏈跟環鏈, 有機會再分享 鐵人賽連結","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"},{"name":"iT邦鐵人賽11Th","slug":"iT邦鐵人賽11Th","permalink":"https://tedmax100.github.io/tags/iT邦鐵人賽11Th/"}]},{"title":"Array & Slice","slug":"Array","date":"2020-12-20T13:09:04.000Z","updated":"2020-12-20T13:09:57.269Z","comments":true,"path":"2020/12/20/Array/","link":"","permalink":"https://tedmax100.github.io/2020/12/20/Array/","excerpt":"Array","text":"Array 123// n 陣列元素數量// type 陣列元素類型var array變數 [n]type 長度是固定的, 聲明後無法被改變 長度是陣列類型的一部份, 所以兩個長度不同但元素類型相同的陣列, 是不同的類型, ex: [2]int 跟[3]int是不同的類型.初始化方式1234567891011121314a := [3]int&#123;1,2,3&#125; b := [...]int&#123;1,2,3,4&#125; //透過初始化給的元素數量來給定長度c := [3]int&#123;2:100, 1:200&#125; //透過索引初始化元素, 沒被初始化的就是該類型的預設值d := [...]struct &#123; name: string age uint8&#125; &#123; &#123; \"user1\", 5 &#125;, &#123; \"user2\", 18 &#125;,&#125;// 多維度陣列aa := [2][3]int&#123;&#123;1,2,3&#125;, &#123;4,5,6&#125;&#125;bb := [...][3]int&#123;&#123;1,2,3&#125;, &#123;4,5,6&#125;&#125; //只有第一個維度能用... 操作方法12345678910111213// 取值data := aa[1] //透過索引取用//賦值aa[1] = 2 //透過索引賦值// 走訪陣列每個元素for k, v := range d &#123; fmt.Println(k, v)&#125;/*0 &#123;user1, 5&#125;1 &#123;user2, 18&#125;*/ Array的傳遞123456789101112131415161718192021222324package mainimport \"fmt\"func main() &#123; arrA := [2]int&#123;&#125; var arrB [2]int arrB = arrA fmt.Printf(\"arrA : %p , %v\\n\", &amp;arrA, arrA) fmt.Printf(\"arrB : %p , %v\\n\", &amp;arrB, arrB) arr(arrA)&#125;func arr(x [2]int) &#123; fmt.Printf(\"pass Array : %p , %v\\n\", &amp;x, x)&#125;/*arrA : 0xc000016100 , [0 0]arrB : 0xc000016110 , [0 0]pass Array : 0xc000016150 , [0 0]*/ 3個都是[2]int的記憶體位置都不同, 這很明顯Go在Array的賦值和傳參數都是value type,靠複製整個Array的, 因此如果是1億數量的int64陣列, 一個元素佔64bits, 那這陣列就要800MB, 這樣copy 瞬間會需要1.6GB的記憶體空間. 所以也能改成方法參數傳指針, 來避掉這問題. 123456789101112131415161718192021222324252627package mainimport ( \"fmt\" \"time\")func main() &#123; arrA := [2]int&#123;1, 2&#125; fmt.Printf(\"arrA : %p , %v\\n\", &amp;arrA, arrA) arr(&amp;arrA) arrA[0]++ fmt.Printf(\"arrA : %p , %v\\n\", &amp;arrA, arrA)&#125;func arr(x *[2]int) &#123; fmt.Printf(\"pass Array : %p , %v\\n\", x, *x) time.Sleep(time.Second) (*x)[0]++&#125;/*arrA : 0xc00008e010 , [1 2]pass Array : 0xc00008e010 , [1 2]arrA : 0xc00008e010 , [3 2]*/ 會看到都是操作同一個位置的陣列了.但會引發另一個問題, 原來陣列的指針指向改變了, 函數內的也會更著變動. 這兩個問題, Slice都能有效的處理解決. Slice 動態分配大小的Array, 可以不必事先指定大小.雖然是這樣講, 但他其實是一個結構, 透過ptr指向引用的底層Array. 123456789// type 元素類型// array 指向array的指針// len 目前slice中有多少元素數量// cap 可容納多少個元素type slice struct &#123; array unsafe.Pointer len int cap int&#125; 初始化方式 從現有的array或是slice生出新的slice 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package mainimport ( \"fmt\" \"reflect\")func main() &#123; var arr = [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125; // 取開始到中間的所有元素 slice0 := arr[:5] fmt.Println(slice0) // 取中間到尾部的所有元素 slice1 := arr[5:] fmt.Println(slice1) // 取中間區間的所有元素 slice2 := arr[2:7] fmt.Println(slice2) // 取所有元素, 表示原有的slice slice3 := arr[:] fmt.Println(slice3) // 重置slice, 清空擁有的元素 slice4 := arr[0:0] fmt.Println(slice4) fmt.Println(\"-------------------\") slice := arr[1:3] fmt.Println(reflect.TypeOf(arr)) fmt.Println(reflect.TypeOf(slice)) fmt.Println(len(slice), cap(slice)) fmt.Println(arr) fmt.Println(slice) fmt.Println(\"-------------------\") slice[0] = 0 fmt.Println(arr) fmt.Println(slice)&#125;/*[0 1 2 3 4][5 6 7 8 9][2 3 4 5 6][0 1 2 3 4 5 6 7 8 9][]-------------------[10]int[]int2 9[0 1 2 3 4 5 6 7 8 9][1 2]-------------------[0 0 2 3 4 5 6 7 8 9][0 2]*/ 宣告slice 1234567891011121314151617181920212223242526package mainimport ( \"fmt\")func main() &#123; // 宣告字串slice var numList []int // 宣告一個空slice var numEmptyList = []int&#123;&#125; fmt.Println(numList, numEmptyList) fmt.Println(len(numList), len(numEmptyList)) fmt.Println(numList == nil) fmt.Println(numEmptyList == nil)&#125;/*[] []0 0truefalse*/ 這裡第18行是true, 是因為numList只是宣告, 還沒真正實例化第19行則是有被實例化被分配到記憶體內了.因為slice還是個struct動態結構, 所以只能和nil作比較. 使用make()1234// type 元素類型// size 為slice先分配多少個元素的預設值進去// cap 預分配的數量, 只是能提前分配空間, 降低之後多次分配空間的效能問題.make([]type, size, cap) 透過make()生成的slice, 一定會實例化配置記憶體,但透過從其他slice指定開始和結束位置的slice, 只是把新的slice指向舊的slice已經分配好的空間, 只是新的slice註明開始跟結束位子而已, 此時新的slice並不會真的去跟記憶體要一個新的連續空間來宣告新array. 123456789101112131415161718192021package mainimport ( \"fmt\")func main() &#123; // 宣告int slice, 壹開始2個都先分配2元素進去 a := make([]int, 2) // 會發現b, 它的預先配置在記憶體的位置大小, 其實已經是能塞10個元素的配置了 b := make([]int, 2, 10) fmt.Println(a, b) fmt.Println(len(a), len(b)) fmt.Println(cap(a), cap(b))&#125;/*[0 0] [0 0]2 22 10*/ 透過append()添加元素append()能為slice動態添加數個元素.當slice不能容納足夠多的元素時, slice就會進行擴容.“擴容”往往發生在append()被調用時.擴容時,容量的擴展規律按照容量的2倍在擴容, 例如1、2、4、8. 123456789101112131415161718192021222324252627package mainimport ( \"fmt\")func main() &#123; // 宣告一個len 和cap 都是0的slice numbers := make([]int, 0) for i := 0; i &lt; 10; i++ &#123; numbers = append(numbers, i) fmt.Printf(\"len: %d, cap: %d, ptr: %p\\n\", len(numbers), cap(numbers), numbers) &#125;&#125;/*len: 1, cap: 1, ptr: 0xc000016100len: 2, cap: 2, ptr: 0xc000016130len: 3, cap: 4, ptr: 0xc000018560len: 4, cap: 4, ptr: 0xc000018560len: 5, cap: 8, ptr: 0xc00001a340len: 6, cap: 8, ptr: 0xc00001a340len: 7, cap: 8, ptr: 0xc00001a340len: 8, cap: 8, ptr: 0xc00001a340len: 9, cap: 16, ptr: 0xc00006e080len: 10, cap: 16, ptr: 0xc00006e080*/ 可以很明顯看到, 當原來的cap滿的時候, 會產生擴容現象. 舉個生活例子來說明這len和cap以及擴容.公司發展初期, 資金少, 人員配置也少, 只需要小小的辦公室就能容納所有員工.隨著業務的擴展和收入的增加, 就需要擴編, 但現有辦公室大小是固定的, 無法改變它.所以公司決定！ 換個更大的辦公室, 每次搬家就要把所有人搬遷到新的辦公處.員工就是slice中的元素辦公室就是配置好的記憶體空間, 大小是固定的搬家就是重新配置不論搬家多少次, 公司名稱都是固定的, 表示外部使用這slice的變數名稱是不會修改的,但因為搬家後地址發生變化, 所以slice內部array指向的地址會有所修改. 123456// 添加多個元素numbers = append(numbers, 1, 2, 3) // 透過令一個slice來添加多個元素 nums := []int&#123;4,5,6,7&#125; numbers = append(numbers, nums...) More example12345678910111213141516package mainimport ( \"fmt\")func main() &#123; a := make([]int, 0, 10) b := append(a, 1) _ = append(a, 2) fmt.Println(b[0])&#125;// 2// 因為b.ptr = a.ptr, 且a的cap有10,足夠插入新元素, // 第9行執行完, 會發現a的len還是0// 執行了 第10行後, 當然append a就會把第0個元素的值給修改掉了. 1234567891011121314package mainimport ( \"fmt\")func main() &#123; a := make([]int, 10, 20) b := a[5:] fmt.Println(len(b), cap(b))&#125;// 5 15// 因為b等於是對a作重新slice, 只取a的第5到結束的值. 那就是10-5 = 5, 所以len(b)=5// cap同上, 指針指到的是a.ptr的第5個元素, 20-5= 15 123456789101112131415161718192021222324package mainimport ( \"fmt\")func doAppend(a []int) &#123; b := append(a, 0) fmt.Println(b)&#125;func main() &#123; a := []int&#123;1, 2, 3, 4, 5&#125; doAppend(a[0:2]) fmt.Println(a)&#125;// [1 2 0]// [1 2 0 4 5]// 調用doAppend時, 傳入2個元素, 但這操作卻把外部的a的第3個元素也改掉了// 只要把第14行的程式改成doAppend(a[0:2:2])// [1 2 0]// [1 2 3 4 5]// 結果就會正確了, 因為[0:2:2]最後的2就是指定重新切片後的capacity, 這時候指定是2.// 所以append操作時發現cap &gt;2, 就會重新分配記憶體來存放, 這樣就不會改到原本的了 透過copy()複製slice到令一個sliceGo內建copy()方法, 可以快速的把slice 作copy 12// 回傳有多少個元素被複製過去 func copy(dst, src []Type) int 123456789101112131415161718192021222324252627282930313233package mainimport ( \"fmt\")func main() &#123; numbers := make([]int, 0) for i := 0; i &lt; 10; i++ &#123; numbers = append(numbers, i) &#125; copyA := make([]int, len(numbers)) fmt.Println(\"copy cnt:\", copy(copyA, numbers)) fmt.Println(\"copied data:\", copyA) copyB := make([]int, 3) fmt.Println(\"copy cnt:\", copy(copyB, numbers[2:5])) fmt.Println(\"copied data:\", copyB) copyC := make([]int, 3) fmt.Println(\"copy cnt:\", copy(copyC, numbers)) fmt.Println(\"copied data:\", copyC)&#125;/*copy cnt: 10copied data: [0 1 2 3 4 5 6 7 8 9]copy cnt: 3copied data: [2 3 4]copy cnt: 3copied data: [0 1 2]*/ copyA宣告的容量是來源的既有元素數量, 所以能完整copy來源所有元素. copyB只宣告了3個容量的slice, 之前提過slice可以取開始和結束區間, 這裡用這方式來取值作copy copyC一樣容量只有3, 但要複製來源所有元素時, 卻因為容量不夠, 所以沒法複製全部. 又因為擴容只會發生在append, 因此這例子不會自動擴容, 導致後半段資料全被切掉. 刪除slice中的元素因為slice並沒有提供刪除專用的api.所以只能用本身特性來刪除元素.本質操作上就是, 以被刪除的元素位置為分界點, 將該元素的前後兩個部份作拼接. 12345678910111213141516171819202122package mainimport ( \"fmt\")func main() &#123; numbers := [...]int&#123;1, 2, 3, 4, 5&#125; fmt.Println(numbers) index := 2 fmt.Println(numbers[:index], numbers[index+1:]) deletedNumbers := append(numbers[:index], numbers[index+1:]...) fmt.Println(deletedNumbers)&#125;/*[1 2 3 4 5][1 2] [4 5][1 2 4 5]*/ 因為slice如果頻繁刪除新增裡面的元素的話,是會頻繁的搬動位置, 這點對效能損耗較高.可能就要考慮其他資料結構來實做. 鐵人賽連結","categories":[],"tags":[]},{"title":"第一隻Go程式","slug":"第一隻Go程式","date":"2020-12-20T08:50:06.000Z","updated":"2020-12-20T13:10:15.261Z","comments":true,"path":"2020/12/20/第一隻Go程式/","link":"","permalink":"https://tedmax100.github.io/2020/12/20/第一隻Go程式/","excerpt":"安裝Go跟開發環境Golang下載Install docVsCode","text":"安裝Go跟開發環境Golang下載Install docVsCode Install the GO on Linux123456789# Download filewget https://dl.google.com/go/go1.12.7.linux-amd64.tar.gz# Extract it into /usr/localtar -C /usr/local -xzf go1.12.7.linux-amd64.tar.gz# Add /usr/local/go/bin to the Path environment variableexport PATH=$PATH:/usr/local/go/bin# Check installationgo env 其他名稱會在後面講package時會稍微提到. Upgrade Go123456# Download filewget https://dl.google.com/go/go$VERSION.linux-amd64.tar.gz# Extract it into /usr/localtar -C /usr/local -xzf go$VERSION.linux-amd64.tar.gz# Add /usr/local/go/bin to the Path environment variableexport PATH=$PATH:/usr/local/go/bin Upgrade by shell scriptupdate-golang WorkspacesWorkspacesSetting GoPath在GoPath所顯示的目錄下創建以下資料夾 src : go source file pkg : 編譯產生的文件, .a檔案(一包object file) ; 暫態緩存文件 bin : 編譯後可執行檔案1mkdir -p $GOPATH/src $GOPATH/pkg $GOPATH/bin Hello Go123mkdir -p $GOPATH/src/hellocd $GOPATH/src/hellocode . 以VsCode開啟該目錄 1234567package mainimport \"fmt\"func main() &#123; fmt.Println(\"Hello Go\")&#125; 12345# 編譯產生可執行的二進制檔案, 會被安裝到$GOPATH/bin底下go install hello# 執行$GOPATH/bin/hello&gt; Hello Go Main packageGo每支檔案都會需要宣告這是屬於哪個package的, 相當於C#的namespace概念.主要的會有一個叫做main的package包, 做為這隻可執行程式的入口包.如果該專案沒有main包時, 就沒法被編譯成可執行檔案.所以如果是要做成共享套件, 就可以不必有main包的存在於該專案內. main裡面會有main方法作為程式的執行進入點. 123456789101112// main包宣告package main// 匯入fmt包import ( \"fmt\" ) // main 方法, 作為執行程式的入口 func main() &#123; fmt.Println(\"Hello IThome\") &#125; import用來導入其他的包, 要用雙引號作為字串來使用. 單行匯入 12import \"包A\"import \"包B\" 多行匯入, 宣告順序不影響真正的匯入結果 1234import ( \"包A\" \"包B\") 要是我有一個包在$GOPATH/src/底下的資料夾路徑是這樣的 github.com ithome packageA那我要引入 packageA的話要按照$GOPATH開始計算的路徑, 使用/進行路徑分隔.也因為跟資料夾路徑有關, 所以建議上都是把資料夾名稱跟package名稱取名成一致.123import ( \"github.com/ithome/packageA\") 安裝第三方套件今天想安裝mysql套件, 他的遠端路徑是 github.com/go-sql-driver/mysql依照 /作路徑分隔的話.第一段表示網域名稱第二段表示作者或者是機構名稱第三段則是專案名稱 透過go get指令, 透過這指令下載原始碼並且編譯.由於go get需要GOPATH已經被設置, Go1.8之後GOPATH預設在用戶目錄的go資料夾下. 1go get github.com/go-sql-driver/mysql go get 參數說明: -d 只有下載, 不會安裝 -v verbose, 顯示下載編譯時的log -u 更新既有的依賴包 有了基本包的概念, 就能寫簡單的範例了. 12# 安裝logrus這log套件go get github.com/sirupsen/logrus go/src/packagedemo/mylib/add.go 12345package mylibfunc Add(a, b int) int &#123; return a + b&#125; go/src/packageDemo/main.go 123456789101112package mainimport ( \"fmt\" \"packagedemo/mylib\" // 這裡使用log 這別名來取代logrus這包名 log \"github.com/sirupsen/logrus\")func main() &#123; fmt.Println(mylib.Add(1,2)) log.Info(\"IThome Iron man\")&#125; 執行 1234go run main.go# 輸出 :# 3# INFO[0000] IThome Iron man 鐵人賽連結","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"},{"name":"iT邦鐵人賽11Th","slug":"iT邦鐵人賽11Th","permalink":"https://tedmax100.github.io/tags/iT邦鐵人賽11Th/"}]},{"title":"學Golang的緣由","slug":"學Golang的緣由","date":"2020-12-20T08:17:50.000Z","updated":"2020-12-20T13:10:25.504Z","comments":true,"path":"2020/12/20/學Golang的緣由/","link":"","permalink":"https://tedmax100.github.io/2020/12/20/學Golang的緣由/","excerpt":"學Golang的緣由","text":"學Golang的緣由 這是小弟第一次參加鐵人賽, 來挑戰一下自我.開始學著寫Golang的原因是因為寫了幾年NodeJS跟C#,但Node真的一個專案打包成docker image超臃腫.就嘗試找一個也支援高併發, 性能優, 方便部屬的語言,但希望它的執行檔大小能是超小的, 且各種OS都支援.就選擇Golang這語言了.就下班加減學一點學一點, 至今也看了兩三個月.一些東西紀錄在自己的部落格當作筆記 Go語言特性 Google開發並負責維護的開源專案! 靜態、編譯型, 自帶GC和併發處理的語言, 能編譯出目標平台的可執行檔案, 編譯速度也快. 全平台適用, Arm都能執行 上手容易, 我覺得跟C比較真的頗容易, 但跟JS比我覺得還是差一些 原生支援併發 (goroutine), 透過channel進行通信 關鍵字少, 30個左右吧 用字首大小寫, 判別是否是public / private 沒用到的import 或者是 變數, 都會在編譯時期給予警告 沒有繼承! 適合寫些工具, 像是hugo、fzf、Drone、Docker 適合其他語言大部分的業務, RestAPI, RPC, WebSocket 內含測試框架 不必在煩惱 到底要i++還是++i了, 因為在Go裡沒有++i, 也不能透過i++賦值給其他的變數 從Node到GolangHello WorldNodeJS 1console.log(\"hello world\"); 1&gt; node app.js Golang的對等寫法 12345678package mainimport ( \"fmt\")func main() &#123; fmt.Println(\"hello world\")&#125; 1&gt; go run main.go Array 和 Slice1const names = [\"it\", \"home\"]; 1names := []string &#123; \"it\", \"home\"&#125; 印出後面幾個字的子字串12let game = \"it home iron man\";console.log(game.substr(8, game.length)); 12game := \"it home iron man\"fmt.Println(game[8: ]) 流程控制123456789101112const gender = 'female';switch (gender) &#123; case 'female': console.log(\"you are a girl\"); break; case 'male': console.log(\"your are a boy\"); break; default: console.log(\"wtf\");&#125; 123456789gender := \"female\"switch gender &#123;case \"female\": fmt.Println(\"you are a girl\")case \"male\": fmt.Println(\"your are a boy\")default: fmt.Println(\"wtf\")&#125; 看得出來Go省略了break這關鍵字 LoopJavascript有for loop, while loop, do while loopGo只有for loop 就能模擬上面三個 12345678910111213for i := 0; i &lt; 10; i++ &#123; fmt.Println(i)&#125;// key value pairskvs := map[string]string&#123; \"name\": \"it home\", \"website\": \"https://ithelp.ithome.com.tw\",&#125;for key, value := range kvs &#123; fmt.Println(key, value)&#125; Object123456const Post = &#123; ID: 10213107 Title: \"下班加減學點Golang\", Author: \"Nathan\", Difficulty: \"Beginner\",&#125; 12345678910111213type Post struct &#123; ID int Title string Author string Difficulty string&#125;p := Post &#123; ID: 10213107, Title : \"下班加減學點Golang\", Author: \"Nathan\", Difficulty:\"Beginner\",&#125; Go能透過定義抽象的struct與其屬性, 在實例化也能透過map[string]interface來定義 123456Post := map[string]interface&#123;&#125; &#123; \"ID\": 10213107, \"Title\" : \"下班加減學點Golang\", \"Author\": \"Nathan\", \"Difficulty\":\"Beginner\",&#125; 從上面幾個例子就能看的出來Node跟Go語法結構上很類似,所以學過Node再來學Go好像就沒那麼難了 XD之後會慢慢補充Go的更多東西. 謝謝各位 下班加減學點Golang與Docker-鐵人賽連結 鐵人賽連結","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"},{"name":"iT邦鐵人賽11Th","slug":"iT邦鐵人賽11Th","permalink":"https://tedmax100.github.io/tags/iT邦鐵人賽11Th/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-12-20T07:56:16.169Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2020/12/20/hello-world/","link":"","permalink":"https://tedmax100.github.io/2020/12/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Docker Multi Stage Build","slug":"Docker-Multi-Stage-Build","date":"2019-08-07T16:06:18.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/08/08/Docker-Multi-Stage-Build/","link":"","permalink":"https://tedmax100.github.io/2019/08/08/Docker-Multi-Stage-Build/","excerpt":"Docker 17.05版的發布了Multi-stage build, 讓image肥大的問題有了優雅的解法.","text":"Docker 17.05版的發布了Multi-stage build, 讓image肥大的問題有了優雅的解法. Our Go program :1234567package mainimport \"fmt\"func main() &#123; fmt.Println(\"Hello world!\")&#125; Single-stage buildDockerfile : 12345FROM golang:alpineWORKDIR /appADD . /appRUN cd /app &amp;&amp; go build -o goappENTRYPOINT ./goapp 12# build imagedocker build -t main . 1docker images | grep main 352MB的鏡像大小, 這對於要快速佈署是相當的肥大的.因為Go只需要編譯完成的binary檔, Go image其實只是輔助編譯source code用的.所以透過Multi-Stage build 來減少程式的鏡像檔大小. Multi-Stage Build適用在需要編譯環境的應用上(GO, C, JAVA…)至少都會需要兩個環境的Docker image: 編譯環境鏡像 完整的編譯引擎, 依賴庫等等 運行環境鏡像 編譯好的二進制檔, 用來執行app, 因為沒有編譯環境, 所以體機會小上很多使用multi-stage build, 可以使用單一的dockerfile, 降低維護複雜度. 12345678910# build stageFROM golang:alpine AS build-envADD . /srcRUN cd /src &amp;&amp; go build -o goapp#final stageFROM alpineWORKDIR /appCOPY --from=build-env /src/goapp /app/ENTRYPOINT ./goapp 7.58MB More ExamplesImport “time” main.go123456789101112131415161718package mainimport ( \"fmt\" \"time\")func main() &#123; location, err := time.LoadLocation(\"Europe/Berlin\") if err != nil &#123; fmt.Println(err) &#125; t := time.Now().In(location) fmt.Println(\"Time in Berlin:\", t.Format(\"02.01.2006 15:04\"))&#125; build 完之後執行會出錯 搜尋該錯誤 panic: time: missing Location in call to Time.In搜尋Google後得知, 原來時區位置是從本地文件讀取出的.可以透過安裝tzdata, 在/usr/share/zoneinfo產生各時區的資訊; 或者複製機器上的修改Dockefile 1234567891011121314# build stageFROM golang:alpine AS build-envADD . /srcWORKDIR /srcRUN go build -o goapp#final stageFROM alpineWORKDIR /app# RUN apk add --no-cache tzdata# COPY --from=build-env /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/COPY --from=build-env /usr/share/zoneinfo /usr/share/zoneinfoCOPY --from=build-env /src/goapp /app/ENTRYPOINT ./goapp Go ModuleApp Code + go.mod + go.sum 12345678910111213141516// main.gopackage mainimport ( \"github.com/gin-gonic/gin\")func main() &#123; r := gin.Default() r.GET(\"/ping\", func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; \"message\": \"pong\", &#125;) &#125;) r.Run()&#125; 1. Build Golang App準備官方的Golang image, 並且取別名為builder-env, 方便在之後的階段來使用設定工作目錄,因為我是用go module作套件依賴管理,這裡把路徑設定成跟我們開發環境中一樣, 都是GOPATH下(go/src)的路徑.複製代碼, 並且安裝依賴, 編譯go app 12345FROM golang AS build-envWORKDIR /go/src/github.com/tedmax100/docker-multistage-build-demoCOPY . .ENV GO111MODULE=onRUN CGO_ENABLED=0 GOOS=linux go build -o main 2. Deployment image使用scratch 來作基礎image把編譯好的程式放在裡面;scratch大小 比alpine還小.如果app 需要SSL/TLS來進行訪問, 則需要複製ca-certificates 12345FROM scratchWORKDIR /bin# COPY --from=build-env /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ca-certificates.crtCOPY --from=build-env /go/src/github.com/tedmax100/mahjong .CMD [\"./main\"] 僅產生出15.Mb的image docker build透過–rm 刪除中間過程產生的容器 1docker build --rm -t main . docker run1docker run --rm -d -p 8081:8080 main source code","categories":[{"name":"Docker","slug":"Docker","permalink":"https://tedmax100.github.io/categories/Docker/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"},{"name":"Docker","slug":"Docker","permalink":"https://tedmax100.github.io/tags/Docker/"}]},{"title":"Go-Context","slug":"Go-Context","date":"2019-07-28T14:42:02.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/07/28/Go-Context/","link":"","permalink":"https://tedmax100.github.io/2019/07/28/Go-Context/","excerpt":"","text":"Context允許傳遞”Context”在goroutine之中, 手動/超時來中止routine樹等操作.讓所有基於該context或其衍生的子context都會收到通知, 就能進行結束操作, 最後釋放goroutine. 優雅的解決goroutine啟動之後難以控制的問題. 常見的有timeout、deadline 或 只是停止工作. Context Interface123456789type Context interface &#123; Deadline() (deadline time.Time, ok bool) Done() &lt;-chan struct&#123;&#125; Err() error Value(key interface&#123;&#125;) interface&#123;&#125;&#125; Deadline 獲取設置好的截止時間 ; 第二個bool返回值表示有沒有設置截止時間 Done 返回一個 readonly channel, 如果該channel可以被讀取, 表示parent context 發起了cancel請求, 就能透過Done方法收到訊號後, 作結束操作. Err 返回取消的錯誤原因, 為什麼context被取消 Value 獲得該Context上綁定的值, 是一組KV pair, 該值通常是thread safe的 建立Context1234// 通常使用context.Background()作為樹的root, 該方法只會返回一個空的context// 就是接收請求用// 不可cancel, 沒有設置deadline 和帶任何value的contextctx := context.Background() 123// 如果不需要一個全局的context, 可以用TODO一樣只會返回一個空的context// 就是接收請求用ctx := context.TODO() 建立sub context這四個With方法, 都要接收一個parent context參數.能理解成sub context對parent context的繼承; 反過來說就是基於parent context的衍生.這樣層層下去就能創建一個context tree, 每個節點都能有任意個sub node, 層級也能有任意多個. 123// 透過這樣的方式建立一個可被取消的sub context, 然後當作參數傳給goroutine使用// func WithValue(parent Context, key, val interface&#123;&#125;) Contextctx := context.WithValue(context.Background(), key, \"test\") 12// func WithCancel(parent Context) (ctx Context, cancel CancelFunc)ctx, calcel := context.WithCancel(context.Background()) 1234// 跟WithCancel很像, 只是多個截止時間, 表示時間到了會自動取消context; // 但也能手動cancel// func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(2 * time.Second)) 123// 開始執行後多少時間自動取消context// func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)ctx, cancel := context.WithTimeout(context.Background(), 2 * time.Second) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( \"context\" \"fmt\" \"time\")func main() &#123; ctx, cancel := context.WithCancel(context.Background()) go watch(ctx, \"goroutine1\") go watch(ctx, \"goroutine2\") go watch(ctx, \"goroutine3\") time.Sleep(3 * time.Second) fmt.Println(\"notify stop goroutines by the context\") cancel() time.Sleep(5 * time.Second)&#125;func watch(ctx context.Context, name string) &#123; for &#123; select &#123; case &lt;-ctx.Done(): fmt.Println(name, \"finish the goroutine\") return default: fmt.Println(name, \"goroutine working...\") time.Sleep(1 * time.Second) &#125; &#125;&#125;/*goroutine1 goroutine working...goroutine2 goroutine working...goroutine3 goroutine working...goroutine1 goroutine working...goroutine3 goroutine working...goroutine2 goroutine working...goroutine2 goroutine working...goroutine1 goroutine working...goroutine3 goroutine working...notify stop goroutines by the contextgoroutine2 finish the goroutinegoroutine3 finish the goroutinegoroutine1 finish the goroutine*/","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"}]},{"title":"Odds, Margin, Market","slug":"Odds-Margin-Market","date":"2019-07-18T15:05:15.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/07/18/Odds-Margin-Market/","link":"","permalink":"https://tedmax100.github.io/2019/07/18/Odds-Margin-Market/","excerpt":"","text":"歐賠各大家娛樂網的分析結果 * 歷史紀錄的統計 * 人氣形勢 * 歷史淵源 * 戰意、球隊凝聚力 * 主客場戰績 * 近況 * 過往戰績 * 核心球員受傷、心理、生理等狀況 * 聯賽特性 * 排名 * 突發事件Poisson線上計算根據上面各家自己算出來的主勝、客勝、和局的機率。 再把各機率取倒數, 得到賠率(期望值)主勝賠率: 1/0.5198 = 1.92客勝賠率: 1/0.2339 = 4.2753和局賠率: 1/0.2462 = 4.0617但這跟圖上的會不同，因為同上的會有margin做細微調整. 毛利 margin / 抽水(house edge)其中 100 / 93.57% = 106.861則margin = 6.861% 上面的各選項機率 * 106.861 會得到0.5198 * 106.861 = 55.546%0.2339 * 106.861 = 24.994%0.2462 * 106.861 = 26.309% 主勝賠率 : 1 / 55.546% = 1.80和賠率 : 1 / 24.99% = 4.00客勝賠率 : 1 / 26.309% = 3.80得到跟Bet360一樣的賠率了 用機率表示的原因?因為 賠率(期望值)的倒數應該是和對應的投注成正比的.因為表示發生的機會越高. 玩家勝出的機會也是越高的.應該會有很多人來投注該選項, 對應的投注量也就很大.表示莊家要賠錢的風險也越高. Margin = 106.86%其中的1是本金, 莊家要返還給玩家的, 剩下的才是莊家要賺的部份.所以 1 / 106.86% = 93.57% 就是一場比賽的理論返還率.top 100 bookmakers rankingmargin calculator 操盤同盤口的margin鮮少會在期間作異動, 因為賠率代表著風險, 也代表著銷量.所以大的莊家幾乎margin不會改變, 變得是該盤的賠率. 凱利指數公式?(各莊家的平均勝率*陪率 來計算) 怎來的? 不重要!目的在於體現 冷門出現的可能性凱利指數越低的, 莊家覺得越容易出現 ;越高的表示月不容易開出 換言之 &gt; 1 都不容易開出 Handicap / Spread (讓分盤)盤口 = 讓球把假設的入球數字加給比較不被看好的隊伍上 ;換句話說就是被看好的隊伍最後分數扣掉該數字.只開出一個讓球盤, 俗稱單票多個讓球盤, 俗稱套票8種讓分的盤口2種讓分的盤口 讓分有分成 * 讓半顆跟整數顆的讓分盤 * 目的 -&gt; 沒有平手 ; 平手要去別的玩法(ex 1x2, double chance) * 平手則投注作廢, 退回本金 * 讓0 : 賭輸贏 * 讓半球 : 讓球方以任何分數勝出, 就算贏(1:0) ; 平手,輸掉都算輸(1:1) * 讓一球 : 讓球方以兩球以上勝出, 就算贏(3:1) ; 讓球方分數-1而平手, 退回本金(2:1) ; 其餘都是輸(1:1/0:1) * 讓0.25跟0.75顆的亞洲讓分盤 * 0.25 : 平手退回本金/2 (基本不影響球隊輸贏) * 0.75 : 讓球隊伍分數-1, 為平手退回本金/2舉例 :|讓分盤口|比賽結果|主隊盤口贏|客隊盤口贏||————|———–|—————|————–||0(平手盤)| 1:0 | 主贏 | 客輸||0| 1:1 | refund(走盤) | refund ||0| 0:1 | 主輸 | 客贏||-0.25(平手/半球) | 1:0(淨勝 &gt;= 1) | 主贏 | 客輸||-0.25 | 1:1 | 贏半 | 輸半||-0.25 | 0:1 | 主輸 | 客贏||-0.5(半球) | 1:0(淨勝 &gt;= 1) | 主贏 | 客輸||-0.5 | 1:1 | 主輸 | 客贏||-0.5 | 0:1 | 主輸 | 客贏||-0.75(半球/1球) | 2:0(淨勝 &gt;= 2) | 主贏 | 客輸||-0.75 | 1:0(淨勝 = 1) | 贏半 | 輸半||-0.75 | 1:1 | 主輸 | 客贏||-0.75 | 0:1 | 主輸 | 客贏||-1(1球) | 2:0(淨勝 &gt;= 2) | 主贏 | 客輸||-1 | 1:0(淨勝 = 1) | refund | refund||-1 | 0:0 | 主輸 | 客贏||-1 | 0:1 | 主輸 | 客贏||-1.5(球半)|.. |.. |..||-2 (2球) | ..|.. |..| 亞洲盤透過讓球盤, 讓兩個相差懸殊的球隊, 有機會在一個相對公平的平台上較勁, 從而拉平了雙方客觀上的實力差距.主要是基於歐洲賠率為基礎開發出來的玩法.早期由澳門博彩公司開發出來的, 後來印尼為主的沙巴體育, 菲律賓的明升, 歐洲的BET365、立博等陸續開出了讓分盤, 而為了拓展亞洲市場所以稱為亞洲盤. 上盤/下盤 上盤 : 讓球的一方 (主場球隊/比較被看好的球隊) 下盤 : 受讓的一方 升盤/降盤 升盤 : 該場從讓1.5變成 讓1.5/2, 上升了一個盤口 降盤 : 該場從最初的1.5變成了1/1.5, 下降了一個盤口 盤口來回震盪, 表示兩邊投注金額變化很大盤口幾乎沒震盪, 表示兩邊payoff是平衡的.最常發生在快開踢前, 表示場外較量異常激烈. 水位雙方的獲勝賠率, 一組比例數據, 莊家獲取利潤的手段雙方水位和 正常都&lt; 2, 大概在1.8-1.9之間, 這距離1-2的差額就是莊家的直觀利潤.舉例要是水位和=1.9; 兩邊賠率一樣兩邊各被下注1000萬, 則最後比賽結束時, 莊家能收入100萬元. 初盤一開始在早盤所開出的1x2和odds最能體現兩隊之間的實力差距; 或是莊家對於兩隊的態度 即時開踢前的1x2其賠率走勢 終賠(最終賠率)就賽果反應在賠率上囉也是最終人會買的時刻, 因為幾乎可以胸有成竹的去投注.但也可能提早關盤.終盤幾乎各家都會對齊, 只差在水位策略的細微調整. 賠率種類 HongKong Odds [0, 100] &gt; 0 的正數, 不包含本金 HK -&gt; ML &gt; 1 : -1 / (odds) &lt;= 1 : odds HK -&gt; DEC odds + 1 HK -&gt; INDO &gt; 1 : odds &lt;= 1 : -1 * (1/odds) HK -&gt; American &lt; 1 : -1 * (100 / odds) &gt;= 1 : 100 * odds MalaY Odds : [-1, 1]玩弱隊 負數(輸少) : 從餘額扣除 期望金額(-1*賠率)的錢, 贏就是贏回跟期望金額一樣的錢 ; 換句話說, 我如果想要贏得期望金額這樣的金錢, 我需要投注 期望金額(-1*賠率), 如果贏了, 返回期望金額 正數(贏少) : 跟HK一樣 返還投注金額*賠率 ML -&gt; HK : 負數 : 1 / (-1 * odds) 正數 : -1 * 1/odds-1_ Stake Odds Win Lose Draw 100 0.8 80 -100 0 100 -0.71 100 -71 0 Decimal Odds (歐洲賠率) [1, 100] *&gt; 1 的正數, 包含本金 DEC -&gt; HK odds -1 Indo Odds : 玩強隊 [-100, -1] , [1, 100] &gt;= 1 (贏多) : 投注100$, 贏了, 返還金額 = 投注金額*賠率 ; 輸了賠100$ * &lt; -1 (輸多) : 賠率-1.25 , 期望金額100$, 要從餘額扣除100*1.25 = 125$, 這樣贏了才能獲得 100$的期望金額; 輸掉就賠125$, 125 &gt; 100$, 所以叫輸多 Fractional Odds American Odds &lt; 1 : 賠率113, 想淨勝100$, 要投入113$ Myanmar Odds +60 -50 Odds ConverterSettle","categories":[],"tags":[{"name":"Sportsbook","slug":"Sportsbook","permalink":"https://tedmax100.github.io/tags/Sportsbook/"}]},{"title":"TechWeekly","slug":"Weekly","date":"2019-07-14T16:38:08.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/07/15/Weekly/","link":"","permalink":"https://tedmax100.github.io/2019/07/15/Weekly/","excerpt":"","text":"Every Day :GoCN Every Saturday :Flutter Every Monday :前端精讀 Every ThursdayGoNode Every FridayJavaScript Every SundayTechbridge","categories":[{"name":"TechWeekly","slug":"TechWeekly","permalink":"https://tedmax100.github.io/categories/TechWeekly/"}],"tags":[{"name":"TechWeekly","slug":"TechWeekly","permalink":"https://tedmax100.github.io/tags/TechWeekly/"}]},{"title":"Go Module & Go Vendor","slug":"Go-Module-Go-Vendor","date":"2019-07-14T07:32:19.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/07/14/Go-Module-Go-Vendor/","link":"","permalink":"https://tedmax100.github.io/2019/07/14/Go-Module-Go-Vendor/","excerpt":"","text":"Go Module基礎出現原因 GOPATH不符合一般開發者的習慣; 大家習慣用maven, node module之類的方式. GOPATH無法有效管理板依賴, 沒有辦法表明所依賴的包的版本. 環境準備 Go version &gt;= 1.11 GO111MODULE=on GoMod effect immport package 可以在$GOPATH之外的地方建立專案 該專案Go Module開啟後, 下載的package會放在$GOPATH/pkg/mod下. $GOPATH/bin的功能依然保持 Go Mod Commands有兩種方式能定義一個正確的Go module 12345678// 在$GOPATH/src的目錄下, 建立合理的module路徑// 進入該module目錄, 執行下面命令go mod init [module name]///```bash// 在任意地方, 建立好module路徑// 在該目錄下, 執行go mod init [folder/]module name 就會在該專案下生出了go.mod文件了. Syntax of go.mod module 定義模組路徑 go 定義go version require 指定依賴的功能包和其版本或是[預設是最新版] exclude 忽略該功能包和其版本 replace 替換依賴的功能包123456module my/packagego 1.12require other/thing v1.0.2require new/thing/v2 v2.3.4exclude old/thing v1.2.3replace bad/thing v1.4.5 =&gt; good/thing v1.4.5 Go Mod Require 安裝一下logrus1go get github.com/sirupsen/logrus go.mod的內容 123module modtestgo 1.12require github.com/sirupsen/logrus v1.4.2 // indirect 此時把v1.4.2 改成v1.4.1執行 1go mod download go.mod的內容 123module modtestgo 1.12require github.com/sirupsen/logrus v1.4.1 // indirect 也會發生$GOPATH/pkg/mod/github.com/sirupsen目錄下,多了logrus@v1.4.1和1.4.2版本的源碼 Go Mod Excludego.mod的內容 12345module modtestgo 1.12require github.com/sirupsen/logrus v1.4.2 // indirectexclude github.com/gin-gonic/gin v1.4.0 1go get github.com/gin-gonic/gin 會發現應該是要下載當前最新板的v1.4.0的gin; 但因為有exclude gin 1.4.0 ;所以改成下載v1.3.9 go.mod的內容 12345678910111213module modtestgo 1.12require ( github.com/gin-contrib/sse v0.1.0 // indirect github.com/gin-gonic/gin v1.3.0 // indirect github.com/golang/protobuf v1.3.2 // indirect github.com/mattn/go-isatty v0.0.8 // indirect github.com/sirupsen/logrus v1.4.2 github.com/ugorji/go v1.1.7 // indirect gopkg.in/go-playground/validator.v8 v8.18.2 // indirect gopkg.in/yaml.v2 v2.2.2 // indirect)exclude github.com/gin-gonic/gin v1.4.0 如果exclude指定gin的依賴功能包, 該功能包會避開該版號作安裝 Go Mod Replace如果有package被replace, 則編譯時會使用對應的項目來作取代. 與require類似, 可以指向令一個repo 又或是指向本地的一個目錄 gomodtest 1234// go.modmodule modtestgo 1.12require github.com/sirupsen/logrus v1.4.2 // indirect 1234567891011121314// modtest.gopackage gomodtestimport ( log \"github.com/sirupsen/logrus\")func Init() &#123; log.Info(\"godmodtest init\")&#125;func Exec() &#123; log.Info(\"godmodtest exec\")&#125; **gomaintest 1234// go.modmodule github.com/tedmax100/gomaintestgo 1.12replace github.com/tedmax100/modtest =&gt; ../gomodtest 12345678910// main.gopackage mainimport ( modtest \"github.com/tedmax100/modtest\")func main() &#123; modtest.Exec()&#125; 執行結果 notes Replace和Exclude都只對當前這module有影響, 對其他功能包不會去影響到 ;其他功能包自己的replace也不會影響到這包.","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"}]},{"title":"Go Package","slug":"Go-Package","date":"2019-07-14T07:31:31.000Z","updated":"2020-12-20T14:54:05.073Z","comments":true,"path":"2019/07/14/Go-Package/","link":"","permalink":"https://tedmax100.github.io/2019/07/14/Go-Package/","excerpt":"​","text":"​Everything you need to know about packages in Go 這次聊Package, 主要是因為接著都會需要對業務面向作模組的拆分.或者對功能作拆分, 甚至是第三方套件的引入.一個專案只要不是只有一個main.go, 就一定會有其他的package Package(包)程式碼的目錄, 可以重複利用程式的方案, 方便維護。Go默認提供很多package, 像是fmt、is等。開發者也可以創建自己的package。 package要求所有檔案的第一行添加package名稱，標示該文件所歸屬的package。 1package 包名稱 一個目錄下的同級檔案屬於同一個package package名稱可以與目錄不同名稱, 但盡可能一樣 main package為應用程式執行的entry point; 若沒有main package則無法編譯成可執行的檔案在bin下 package name, Go團隊建議簡單扁平為原則。 所以盡量避免下划線、中划線和參雜大寫字母。 Creating a package 可執行包(executable package) 可自己執行，表示有main package 工具包(utility package) 不可自己執行，但是可以給可執行包做擴展應用的作用 123456789101112// main.gopackage mainimport ( \"fmt\" . \"hello/math\")func main() &#123; fmt.Println(\"hello\") fmt.Println(Average([]float64&#123;1, 2&#125;))&#125; 12345678910// math/math.gopackage mathfunc Average(xs []float64) float64 &#123; total := float64(0) for _, x := range xs &#123; total += x &#125; return total / float64(len(xs))&#125; 1234# 編譯hello package cd $GOPATH/src/hello; go install;# 因為有main package, 所以會安裝到$GOPATH/bin 作為可執行包 1234# 編譯hello package cd $GOPATH/src/hello/math; go install;# 因為沒有main package, 所以會安裝到$GOPATH/pkg下 作為工具包 Import package使用import package，Go會先在 $GOROOT/src下尋找指定的package。若找不到就往$GOPATH/src目錄下尋找。找不到就會報出編譯錯誤。 12345678910package mainimport ( // fmt位於$GOROOT/src下，找到! \"fmt\" // gin並不在$GOROOT/src, 接著找$GOPATH/src找github.com這目錄，找到往內找gin-gonic目錄，再找gin package \"github.com/gin-gonic/gin\" // . \"github.com/go-sql-driver/mysql\") Nested package在一個package內嵌套令一個package; 使用上只要指名路徑關係. 12345678910111213// math/math/extend/min.gopackage extendfunc init() &#123; fmt.Println(\"extend ==&gt; init()\")&#125;func Min(a float64, b float64) float64 &#123; if a &gt;= b &#123; return a &#125; return b&#125; 12345678910111213141516171819202122// math/math.gopackage mathimport ( \"fmt\" \"hello/math/extend\")func init() &#123; fmt.Println(\"math ==&gt; init()\")&#125;func Average(xs []float64) float64 &#123; total := float64(0) for _, x := range xs &#123; total += x &#125; return total / float64(len(xs))&#125;func Min(a float64, b float64) float64 &#123; return extend.Min(a, b)&#125; 1234567891011121314151617// main.gopackage mainimport ( \"fmt\" . \"hello/math\")func init() &#123; fmt.Println(\"main ==&gt; init()\")&#125;func main() &#123; fmt.Println(\"hello\") fmt.Println(Average([]float64&#123;1, 2&#125;)) fmt.Println(Min(1, 2))&#125; Package Initialization 工廠模式自動註冊-管理多個packge 12345678910111213141516171819202122232425// base/factory.gopackage base// define interface for Classtype Class interface &#123; Do()&#125;var ( // 存放註冊好的 類別工廠資訊 factoryByName = make(map[string]func() Class))// 註冊一個類別工廠func Register(name string, factory func() Class) &#123; factoryByName[name] = factory&#125;// 根據name創建對應的類別func Create(name string) Class &#123; if f, ok := factoryByName[name]; ok &#123; return f() &#125; panic(\"name not found\")&#125; 12345678910111213141516171819// ex1/reg.gopackage ex1import ( \"fmt\" \"github.com/tedmax100/factory/base\")type Class1 struct &#123;&#125;func (c *Class1) Do() &#123; fmt.Println(\"class1\")&#125;func init() &#123; base.Register(\"Class1\", func() base.Class &#123; return new(Class1) &#125;)&#125; 123456789101112131415161718192021// ex2/reg.gopackage ex1import ( \"fmt\" \"github.com/tedmax100/factory/base\")type Class2 struct &#123;&#125;func (c *Class2) Do() &#123; fmt.Println(\"class2\")&#125;func init() &#123; base.Register(\"Class2\", func() base.Class &#123; return new(Class2) &#125;)&#125; 1234567891011121314151617// main.gopackage mainimport ( \"github.com/tedmax100/factory/base\" _ \"github.com/tedmax100/factory/ex1\" _ \"github.com/tedmax100/factory/ex2\")//因為上面使用匿名導入了ex1 &amp; ex2 package.//main()執行前, 這兩個package的init()會被調用, 而註冊了class1 &amp; class2func main() &#123; c1 := base.Create(\"Class1\") c1.Do() c2 := base.Create(\"Class2\") c2.Do()&#125; 鐵人賽連結","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"},{"name":"iT邦鐵人賽11Th","slug":"iT邦鐵人賽11Th","permalink":"https://tedmax100.github.io/tags/iT邦鐵人賽11Th/"}]},{"title":"Go環境安裝","slug":"Go環境安裝","date":"2019-07-14T07:30:26.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/07/14/Go環境安裝/","link":"","permalink":"https://tedmax100.github.io/2019/07/14/Go環境安裝/","excerpt":"","text":"Download pageInstall doc Install the GO on Linux123456789# Download filewget https://dl.google.com/go/go1.12.7.linux-amd64.tar.gz# Extract it into /usr/localtar -C /usr/local -xzf go1.12.7.linux-amd64.tar.gz# Add /usr/local/go/bin to the Path environment variableexport PATH=$PATH:/usr/local/go/bin# Check installationgo env Upgrade Go123456# Download filewget https://dl.google.com/go/go$VERSION.linux-amd64.tar.gz# Extract it into /usr/localtar -C /usr/local -xzf go$VERSION.linux-amd64.tar.gz# Add /usr/local/go/bin to the Path environment variableexport PATH=$PATH:/usr/local/go/bin Upgrade by shell scriptupdate-golang WorkspacesWorkspacesSetting GoPath在GoPath所顯示的目錄下創建以下資料夾 src : go source file pkg : 編譯產生的文件, .a檔案(一包object file) ; 暫態緩存文件 bin : 編譯後可執行檔案1mkdir -p $GOPATH/src $GOPATH/pkg $GOPATH/bin First Go Program123mkdir -p $GOPATH/src/hellocd $GOPATH/src/hellocode . 以VsCode開啟該目錄 1234567package mainimport \"fmt\"func main() &#123; fmt.Println(\"hello\")&#125; 12345# 編譯產生可執行的二進制檔案, 會被安裝到$GOPATH/bin底下go install hello# 執行$GOPATH/bin/hello&gt; hello","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"}]},{"title":"Rx簡介","slug":"Rx簡介","date":"2019-07-14T04:21:13.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/07/14/Rx簡介/","link":"","permalink":"https://tedmax100.github.io/2019/07/14/Rx簡介/","excerpt":"","text":"When to use Rx使用Rx來精心地安排非同步和事件流的計算經常為了處理單一事件或是非同步的計算，而把程式的結構搞得非常的複雜，通常會設計狀態機來循序處理。還得處理每一個節點的成功跟失敗端點。這讓程式非常難以了解跟維護。 Rx的出現，使得這些計算跟處理成為一等公民(First-class citizens)。提供了一些模型和可組合的API來處理這些非同步操作。 Sample : 1234567891011121314151617181920var scheduler = new ControlScheduler(this);var keyDown = Observale.FromEvent&lt;KeyEventHandler, KeyEventArgs&gt;( d =&gt; d.Invoke, h =&gt; textBox.keyUp += h, h =&gt; textBox.KeyUp -= h);var dictionarySuggest = keyDown.Select( _ =&gt;textBox1.Text) .Where(text =&gt;!string.IsNullOrEmpty(text)) .DistingctUntilChanged() .Throttle(TimeSpan.FromMilliseconds(250), scheduler) .SelectMany( text =&gt; AsyncLookupInDictionary(text) .TakeUntil(keyDown) );dictionarySuggest.Subscribe( results =&gt; listView1.Items.AddRange(results.Select( result =&gt;new ListViewItem(result)).ToArray() ), error =&gt;LogError(error)); 這範例展示了UI如何接收用戶的鍵入並接收顯示。透過Rx建立了一個可觀察的序列(Observable sequence)，依附在KeyUp事件下。然後每個事件的上層，嵌入了幾個filter和projection， 確保事件只有透過事件觸發時，會發射event stream和唯一的值。像是KeyUp事件每次都會戳一次，但是其他動作並不會。並且透過Throttle操作子，確保在250ms區間內的行為只會觸發一次，透過延遲觸發節省昂貴的查找。 在傳統的作法上，Throttling的做法通常是透過timer callback來實作，但是timer本身很可能就會錯誤並拋出exceptions。一旦用戶鍵入並過濾完畢，就可以執行字典查找了，但通常這會透過Http來做請求，所以這個操作本身就是個async操作。SelectMany操作子允許輕鬆的組合多個async操作，不只組合了成功的狀態，也能追蹤每個單獨操作中出現的異常。在以往，這通常是引入不同的callback，如果用戶在操作時，仍然繼續鍵入新的值，通常會希望不會在看到之前操作的結果，因此舊的查詢結果就不必再顯示出來。TakeUntil操作確保，一旦偵測到新的KeyDown，就會忽略字典的查找。 最後我們訂閱這個observable sequence的結果，我們掛載了2個函式在訂閱的呼叫上 接收成功的計算結果 接收異常 使用Rx開始來處理非同步序列的資料Rx 遵循著以下幾個文法 OnNext* (OnCompleted|OnError)?。這些文法允許多個信息隨著時間的推移而倒入，使得Rx適用於能操作單個信息的操作，甚至於多個信息。 Sameple : 123456789101112131415161718192021222324//open a 4GB file for async reading in block of 64kvar inFile = new FileStream(@\"d:\\temp\\4GBfile.txt\", FileMode.Open, FileAccess.Read, FileShare.Read, 2 &lt;&lt; 15, true);//open a file for async writing in blocks of 64kvar outFile = new FileStream(@\"d:\\temp\\Encrypted.txt\", FileMode.OpenOrCreate, FileAccess.Write, FileShare.None, 2 &lt;&lt; 15, true);inFile.AsyncRead(2 &lt;&lt; 15) .Select(Encrypt) .WriteToStream(outFile) .Subscribe( _ =&gt;Console.WriteLine(\"Successfully encrypted the file.\"), error =&gt; Console.WriteLine( \"An error occurred while encrypting the file :&#123;0&#125;, error.Message ) ); 在這範例中，4GB的檔案，被整個讀取，並且透過加密存到另一個檔案。讀取整份檔案進去記憶體，透過加密跟寫檔出來，這是個非常高成本的操作。取而代之，我們依靠Rx可以產生許多個信息的event stream。以64K的區塊來非同步讀取文件，這產生了一個observable sequence。然後我們分別加密每個區塊，一旦區塊經過加密，就會立即的被發送到下一個管線，已被保存到另一份文件中。WriteToStream操作就是一個可以處理多個信息的非同步操作。 The Rx ContractIObservable和IObserver只用來這些方法的參數和回傳型別。Rx類別對這兩個介面做了比.net更多的假設。這些假設使得所有Rx類型的producer和consumbers都應該遵從的行為契約。這份契約使得去推論和證明程式的正確性。 Rx的假設文法信息被送到IObserver介面時必須遵從的文法 :OnNext* (OnCompleted |OnError)?這組文法允許observable sequences去送出任意數量的OnNext信息到 被訂閱的observer實例中。或是單一結果的成功(OnCompleted), 或是任何的失敗(OnError)。 單一信息能很明確的指示出這一個observer sequence的消費者可以安全地執行清理操作。單一的失敗信息，能確保多個observable sequences可以終止。 Sample : 1234567var count = 0;xs.Subscribe(v =&gt; &#123; count++ ; &#125;, e =&gt; Console.WriteLine(e.Message), () =&gt;Console.WriteLine(\"OnNext has been called &#123;0&#125; times.\"), count); 這範例我們能安全的假設一旦呼叫了OnComplete，OnNext中的調用變數不會被改變。 假設observer實例可以被當作Rx給序列化呼叫由於Rx是使用發布-訂閱模式，在.net中是支援multi threadss的，因此不同的信息可能同時到達不同的thread被處理。如果observale sequenc的消費者就不得不再每個地方來處理這問題，此時程式就需要實行大量的內文管理，來避免併發問題。這種方式寫的程式非常難以維護，且效能可能很低落。 由於不是所有的observable sequence都有信息是來自不同的執行緒的上下文，因此只有下述這種obervale sequence的producer才需要做序列化，確保消費者，可以安全的假設信息是以序列化的方式到達。 Sample : 12345var count = 0;xs.Subscribe(v=&gt;&#123; count++; Console.WriteLine(\"OnNext has been called &#123;0&#125; times\", count)&#125;); 在這範例中，不需要對count做任何lock或是讀寫互斥鎖的實作，因為只有OnNext的呼叫可以ˇ隨時得讀取和寫值到count。 確保在OnError和OnCompleted之後，資源會被清除上面指出了，只要OnError或是OnCompleted被調用後，就不會再有信息被送達。因此可以確保在OnError或是OnCompleted被觸發後，清除任何訂閱使用的資源。 Sample : 1234567Observavle.Using( () =&gt; new FileStream(@\"d:\\temp\\test.txt\", FileMode.Create), fs =&gt; Observable.Range(0, 10000) .Select(v =&gt; Encoding.ASCII.GetBytes(v.ToString())) .WriteToStream(fs)) .Subscribe(); 這範例中使用了Using去建立資源，這資源將會被disposed在unsubscription被呼叫之後。 盡最大努力去退訂所有未完成的工作當unsubscribe被呼叫後，observable sequence將會盡最大的努力去阻止所有未完成的工作。這也意味著還沒開始的排隊作業都不會被啟用。任何已經在進行中的工作都可能完成。因為放棄正在進行中的工作並不是一個安全的行為。只是這些工作的結果並不會被發送到任何以前訂閱的觀察者的實例中了。 Sample 1 : 1Observable.Timer(TimeSpan.FromSeconds(2)).Subscribe(...)Displose() 在這範例中，訂閱由Timer建立出來的oberservable sequence將在ThreadPool scheduler去形成一個排隊列緒，在2秒內去發送OnNext信息。訂閱之後立即取消，由於排成計畫尚未開始，因此將從scheduler中刪除。 Sample 2 : 1234Observable.Start(() =&gt; &#123; Thread.Sleep(TimeSpan.FromSeconds(2)); return 5;&#125;).Subscribe(...).Dispose(); 在這範例之中，Start操作子，立即安排lambda function做完參數。訂閱後將observer實例作為此執行的監聽器。由於一旦訂閱被執行，它將繼續運行並且忽略返回值5。","categories":[],"tags":[{"name":"Rx","slug":"Rx","permalink":"https://tedmax100.github.io/tags/Rx/"}]},{"title":"Decorator_Pattern","slug":"Decorator-Pattern","date":"2019-04-23T06:09:19.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/04/23/Decorator-Pattern/","link":"","permalink":"https://tedmax100.github.io/2019/04/23/Decorator-Pattern/","excerpt":"","text":"做武器系統今天想模仿暗黑破壞神的武器系統那樣 利用前綴詞為武器加上能力。D2魔法前綴詞表 首先我先建立一個基礎類別，然後各種武器(刀、劍、斧 等等)繼承於它。 12345678910export abstract class BaseWeapon &#123; private name: string; private attackPower: number; constructor(name: string, attackPower: number) &#123; this.name = name; this.attackPower = attackPower; &#125; public Name = (): string =&gt; this.name; public AttackPower = (): number =&gt; this.attackPower;&#125; 再來建立了一個劍和匕首類別 123456789101112131415import &#123; BaseWeapon &#125; from \"./BaseWeapon\";export class Sword extends BaseWeapon &#123; constructor() &#123; super(\"Sword\", 9); &#125; public Name = (): string =&gt; super.Name(); public AttackPower = (): number =&gt; super.AttackPower();&#125;export class Gull extends BaseWeapon &#123; constructor() &#123; super(\"Gull\", 2); &#125; public Name = (): string =&gt; super.Name(); public AttackPower = (): number =&gt; super.AttackPower();&#125; 然後透過繼承生成出了Flery Gull、Flery Sword、Static Gull、Static Sword 123456789101112131415161718192021222324252627282930import &#123; Gull &#125; from \"./Gull\";import &#123; Sword &#125; from \"./Sword\";export class FleryGull extends Gull &#123; constructor() &#123; super() &#125; public Name = (): string =&gt; `烈焰的$&#123;super.Name&#125;`; public AttackPower = (): number =&gt; super.AttackPower() + 16;&#125;export class FlerySword extends Sword &#123; constructor() &#123; super() &#125; public Name = (): string =&gt; `烈焰的$&#123;super.Name&#125;`; public AttackPower = (): number =&gt; super.AttackPower() + 16;&#125;export class StaticGull extends Gull &#123; constructor() &#123; super() &#125; public Name = (): string =&gt; `靜電的$&#123;super.Name&#125;`; public AttackPower = (): number =&gt; super.AttackPower() + 4;&#125;export class StaticSword extends Sword &#123; constructor() &#123; super() &#125; public Name = (): string =&gt; `靜電的$&#123;super.Name&#125;`; public AttackPower = (): number =&gt; super.AttackPower() + 4;&#125; 12345678let sword = new Sword();console.log(`$&#123;sword.Name&#125; : $&#123;sword.AttackPower&#125;`);let gull = new Gull();console.log(`$&#123;gull.Name&#125; : $&#123;gull.AttackPower&#125;`);let flerySword = new FlerySword();console.log(`$&#123;flerySword.Name&#125; : $&#123;flerySword.AttackPower&#125;`);let staicGull = new StaticGull();console.log(`$&#123;staicGull.Name&#125; : $&#123;staicGull.AttackPower&#125;`); 1234Sword : 9Gull : 2烈焰的Sword : 25靜電的Gull : 6 Class Diagram But!!!這才2種武器，2個特效，我已經有4個類別(2*2)。 2層繼承。當我前綴又再一層時，或者有後綴的出現，整個很難維護。再這情境上，我很可能會有一把是”靜電的烈焰”或”烈焰的靜電”這樣在現在設計上是不同類別，太多本質相似的類別需要維護了。 整理發生幾個現象 : 繼承層數過多、類別數量激增繼承超過兩層，可以想想是不是自己設計上出了問題，因為這樣維護成本只會越來越繁重。 為解決這些問題，增加一個抽象方法或介面類別來封裝武器類別。從上面可發現，我第二層跟第三層的類別基本上都是有共同的介面去實作一些行為。 Components: (要被裝飾物件) 123456789101112131415161718192021222324252627export interface BaseWeapon &#123; Name(): string; AttackPower(): number; Attack(): void;&#125;export class Sword implements BaseWeapon &#123; private name: string; private attackPower: number; constructor() &#123; this.name = \"Sword\"; this.attackPower = 9; &#125; public Name = (): string =&gt; this.name; public AttackPower = (): number =&gt; this.attackPower; public Attack = (): void =&gt; console.log(`$&#123;this.name&#125;打出了$&#123;this.attackPower&#125;點傷害!`);&#125;export class Gull implements BaseWeapon &#123; private name: string; private attackPower: number; constructor() &#123; this.name = \"Gull\"; this.attackPower = 2; &#125; public Name = (): string =&gt; this.name; public AttackPower = (): number =&gt; this.attackPower; public Attack = (): void =&gt; console.log(`$&#123;this.name&#125;打出了$&#123;this.attackPower&#125;點傷害!`);&#125; Decorators : 要加上的動態職責，需要有跟Components一樣的介面。 12345678910111213141516171819202122232425262728export abstract class WeaponDecorator implements BaseWeapon&#123; protected name: string; protected attackPower: number; protected weapon: BaseWeapon; constructor(name: string, attackPower: number, weapon: BaseWeapon) &#123; this.name = name; this.attackPower = attackPower; this.weapon = weapon; &#125; public Name = (): string =&gt; this.name + this.weapon.Name(); public AttackPower = (): number =&gt; this.attackPower + this.weapon.AttackPower(); public Attack = (): void =&gt; console.log(`$&#123;this.Name()&#125;打出了$&#123;this.AttackPower()&#125;點傷害!`);&#125;export class FleryDecorator extends WeaponDecorator&#123; constructor(weapon: BaseWeapon) &#123; debugger; if(weapon.Name().indexOf(\"烈焰的\") === -1) super(\"烈焰的\", 16, weapon); else super(\"\", 0, weapon); &#125;&#125;export class StaticDecorator extends WeaponDecorator&#123; constructor(weapon: BaseWeapon) &#123; if(weapon.Name().indexOf(\"靜電的\") === -1) super(\"靜電的\", 4, weapon); else super(\"\", 0, weapon); &#125;&#125; 12345678910const sword = new Sword(); const flerySword = new FleryDecorator(sword); flerySword.Attack(); const staticFleryword = new StaticDecorator(flerySword); staticFleryword.Attack(); const gull = new Gull(); const staticGull = new StaticDecorator(gull); staticGull.Attack(); const fleryStaticGull = new FleryDecorator(staticGull); fleryStaticGull.Attack(); 1234烈焰的Sword打出了25點傷害!靜電的烈焰的Sword打出了29點傷害!靜電的Gull打出了6點傷害!烈焰的靜電的Gull打出了22點傷害! Class Diagram :可以看到繼承關係被簡化了，組件跟功能之間變成組合關係。 裝飾者模式的定義Attach additional responsibilities to an object dynamically keeping the same interface.Decorators provide a flexible alternative to subclassing for extending functionality.(動態的給一個對象添加一些額外的職責，就功能面來說，裝是者模式 比 增加子類別靈活) Compoent抽象類別(BaseWeapon): 原有類別的抽象類或是一組介面ConcreteCompoent : 被裝飾的具体對象，需要去實現Compoent。Decorator : 也是一個抽象類別，實現Compontet，且裡面一定要有一個變數指向Componet抽象物件實體。 舉例: WeaponDecorator中的protected weapon: BaseWeapon 。ConcreteDecorator : Decorator的實作。主要就把基本的東西裝飾成其他東西。 Pros : ConcreteDecorator跟ConcreteComponent可以獨立發展，而不會相互耦合。In other words, 兩方不需要知道彼此的存在。Decorator類是從外部來擴展Component類別的功能，而Decorator也不知道具體的物件。舉例: Decorator依賴的其實是Compoenent的抽象或介面，且是組合關係。 是繼承關係的一種替代方案。看Decorator，不管裝飾多少層，返回的對象還是Component的抽象。實現的是is-a的關係。 可以動態的擴展一個類別的功能，就是該模式的定義。 裝飾者可以擴充Component的狀態，或是修改原有實作方法。 Cons : 除錯比較困難，多層裝飾下，因為會像是剝洋蔥一樣，可能要撥到最裡面那層，才發現出了問題。 ###使用場景 需要擴展一個類別的功能，又或者需要付加給它時。 需要動態的給一個對象增加功能，或者是動態的撤回。 需要為一大群兄弟類別進行改裝或加裝功能時。 使用Curry的概念來練習123456789101112131415161718192021222324252627class Sword &#123; private name: string; private attackPower: number; constructor() &#123; this.name = \"Sword\"; this.attackPower = 9; &#125; public Name = (): string =&gt; this.name; public AddPrefixAndAttackPower = (prefix: string, power: number) =&gt; &#123; this.name = prefix + this.name; this.attackPower += power; &#125; public AttackPower = (): number =&gt; this.attackPower; public Attack = (): void =&gt; console.log(`$&#123;this.name&#125;打出了$&#123;this.attackPower&#125;點傷害!`);&#125;interface PrefixValue &#123; prefix: string, attachPower: number&#125;const Prefix = (prefixValue: PrefixValue) =&gt; &#123; return function(sword: Sword) &#123; sword.AddPrefixAndAttackPower(prefixValue.prefix, prefixValue.attachPower); return sword; &#125;&#125;const FleryValue: PrefixValue = &#123;prefix:\"烈焰的\", attachPower: 16&#125;;Prefix(FleryValue)(new Sword()).Attack(); 1烈焰的Sword打出了25點傷害! 與Proxy的差異?等Proxy pattern寫完文章，再來一起比較。 ES6的Decorator?todo XD","categories":[],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://tedmax100.github.io/tags/Design-Pattern/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://tedmax100.github.io/tags/TypeScript/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://tedmax100.github.io/tags/JavaScript/"}]},{"title":"Multi and LuaScript for Redis","slug":"Multi-and-LuaScript-for-Redis","date":"2019-03-16T06:03:05.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/03/16/Multi-and-LuaScript-for-Redis/","link":"","permalink":"https://tedmax100.github.io/2019/03/16/Multi-and-LuaScript-for-Redis/","excerpt":"","text":"Multi? What is it?主要執行multi和exec包圍起來的部分，當multi命令發出，redis會進入transaction狀態，redis會進入blocking，不再處理其他請求，直到發出multi的session發出exec命令為止。被multi和exec包圍起來的命令們進入獨享redis的過程，直到執行完成。因為是transction，所以命令要全部執行完畢，不然就是都不執行。如果exec命令送出前，client斷線，redis會清空transction queue，所有命令都不會執行。一但client送出了exec命令，所有命列就會被執行，就算client斷線了也無訪。 如果transction過程中，要執行3個命令 1、2、3，其中2出錯了，不會像db那樣整個rollback，依然會執行到完。 透過這種方式，redis就能避免多個client同時訪問，出現讀寫不一致的情況，來完成atomic transction操作。 還有DISCARD (取消transcation)、WATCH(監控某個KEY，只要被更動，則transction無法被觸發，exec會得到nil)由於Multi是把命令逐條發送給redis server，server還會回應QUEUED，並且最後還要回應執行結果，所以封包數量上其實比平常都多，效率也近乎最低的。 Pipeline?一次執行多條命令，無關atomic，網路封包數量也最少。有機會再筆記。 Why use Lua Script to access Redis? 當需要對redis下多個命令，且每一個命令就是一次網路傳輸。 多個指令中，後面的指令依賴前一個操作的結果時。 Redis依然是 單執行緒下執行依序執行這些操作。 如果Lua script本身內容很多，可以先把lua script載入redis, redis會返回一組SHA字串，以後就直接傳遞這SHA字串即可替代原內容。 可以組合多個命令，且該次執行本身也是atomic操作。 支援base、table(array)、string、match、debug、cjson、cmspack。 1234情境 :HotYoutubers 是以sorted set結構存放，檢查要是youtuber不再名單內，則新增要是在名單內了，則score + 1 Initial Data 12345678910const youtubers = ['理科太太', '赤井Akai', 'D Rebound 99', '融融歷險記', '志祺七七X圖文不符', '閃亮胖時代','只會玩刀鋒', 'Ken桑', '尬酒螺仔', '我們Our channel'];const voteCnt = [10000, 9999, 8999, 8000, 8001, 9383, 5345, 6864, 1384, 5131];const newYoutubers = ['华农兄弟'];const key = \"HotRanks\";const youtuberListKey = \"Youtubers\";const promiseArray: any[] = [];youtubers.map(d =&gt; promiseArray.push(d));await Promise.all(youtubers.map(d) =&gt; &#123; redisClient.SADD(\"KEYA\", d);&#125;); 不使用Multi 1234567891011121314151617client.zscan(key, \"0\" , \"MATCH\", youtubers[0], (err, reply) =&gt; &#123; if(err)&#123; console.error(&#123; error: err, key: key, target: youtubers[0] &#125;) return ; &#125; if(reply[1].length &gt; 0) &#123; console.log(`$&#123;youtubers[0]&#125; increase score`); client.zincrby(key, 1, youtubers[0]); &#125; else &#123; console.log(\"add new youtuber\"); client.zadd(key, 1, youtubers[0]); &#125;&#125;); 網路封包 : 5個封包 使用Multi 1234567891011121314151617181920212223242526272829303132333435 client .multi() .zscan(key, \"0\" , \"MATCH\", youtubers[0]) .zincrby(key, 1, youtubers[0]) .zrevrange(key, 0 , 10) .exec((err, replies) =&gt; &#123; if(err)&#123; console.error(&#123; error: err, key: key, target: youtubers[0] &#125;) return ; &#125; console.dir(replies); if(replies[0][1].length &gt; 0) &#123; console.log(`$&#123;youtubers[0]&#125; increase score`); &#125; else &#123; console.log(\"add new youtuber\"); &#125; &#125;)結果 :[ [ '0', [ '理科太太', '10007' ] ], '10008', [ '理科太太', '赤井Akai', '閃亮胖時代', 'D Rebound 99', '志祺七七X圖文不符', '融融歷險記', 'Ken桑', '只會玩刀鋒', '我們Our channel', '尬酒螺仔' ] ]理科太太 increase score 封包數量 : 3個, 一個是multi起transaction,並把命令們丟進去queue，等到exec被發出調用，一次返回全部命令的結果。 But!!!不方便做到更複雜的需求!雖然zincrby在item不存在時，會幫忙新增item，並給上分數。但要是想先檢查youtube set內內是否存在此youtuber時就很難了。 使用Lua Script 來完成! 先檢查youtuber清單 “Youtubers” youtuber存在，則增加分數 youtuber不存在，則回傳nil Notes :Lua的array都是從1開始的。 client.eval(luaScript, 2, key, youtuberListKey, newYoutubers[0]; 這段的2是告訴redis有兩個Key在KEYS[]當中，而在這所引外的都會是在ARGV[]當中了。 宣告變數是用local這關鍵字宣告 lua的null是nill 如果變數x是table(即arry)類型，要使用 則使用#x 來使用; 例如取得x的陣列長度 #x.length 想要對table類型做歷尋有以下方式 使用ipair探索table中的陣列部分, for k, v in ipair(變數x) do ; k就是k, v則是value, ipair 使用pairs探索table中所有資料, for k, v in ipair(變數x) do ; k就是k, v則是value, ipair 123456789101112131415161718192021222324252627282930const luaScript = 'local youtuber = redis.call(\"HEXISTS\", KEYS[2], ARGV[1]) \\if(youtuber == 0) then \\ return nil \\else \\ return redis.call(\"zincrby\", KEYS[1], 1, ARGV[1]) \\end ';client.eval(luaScript, 2, key, youtuberListKey, newYoutubers[0], (err, replies) =&gt; &#123; if(err)&#123; console.error(&#123; error: err, key: key, target: youtubers[0] &#125;) return ; &#125; console.dir(replies); &#125;)// 結果 : nullclient.eval(luaScript, 2, key, youtuberListKey, youtubers[0], (err, replies) =&gt; &#123; if(err)&#123; console.error(&#123; error: err, key: key, target: youtubers[0] &#125;) return ; &#125; console.dir(replies); &#125;)// 結果 : '10010' 封包數量 : 3, 同Multi But!!!每次執行都要送這些腳本以及編譯，有沒有方法省掉呢?Yes!!!先把script透過script load載入，會得到一串hash string。以後執行evalsha跟這hash string即可。 1234567891011121314151617let hashScript: string;client.script('load', luaScript, (err, res) =&gt; &#123; console.dir(res); // 'aa838cb2f4f84408889222a7af3bec845f126ba8' hashScript = res;&#125;)client.evalsha(hashScript, 2, key, youtuberListKey, youtubers[0], (err, replies) =&gt; &#123; if(err)&#123; console.error(&#123; error: err, key: key, target: youtubers[0] &#125;) return ; &#125; console.dir(replies); &#125;) Redis能做到的事情蠻多的，不只是能當快取，透過Lua腳本，也能簡單的做些關聯查詢。只是它畢竟是單執行緒，要是被這任務卡住太久，就喪失快取的意義了。 日後有機會再筆記PUB/SUB，我在實務上的簡單應用。最主要的還是他的叢集架設與資料同步/備份的部分。","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://tedmax100.github.io/tags/Redis/"},{"name":"Lua","slug":"Lua","permalink":"https://tedmax100.github.io/tags/Lua/"}]},{"title":"Strtegy Pattern","slug":"Strtegy-Pattern","date":"2019-02-23T05:57:02.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/02/23/Strtegy-Pattern/","link":"","permalink":"https://tedmax100.github.io/2019/02/23/Strtegy-Pattern/","excerpt":"","text":"小故事劉備去東吳招親前，諸葛亮預測東吳會刁難劉備，甚至吞掉荊州西川，因此諸葛亮特授予趙雲三個錦囊，說是按照天機拆開解決棘手問題。 三個妙計是: 找喬國老幫忙(走後門) 求吳國太放行(訴苦) 孫夫人斷後(親情攻擊) 這三個妙計都是告訴照雲要怎麼去執行，也就是說三個計謀都有一個方法是”執行“。具體執行什麼內容，每個妙計會有所不同。 類別圖 : 12345678910111213interface IStrategy &#123; // 執行錦囊 operate(): void;&#125;class BackDoor implements IStrategy &#123; public operate = () =&gt; console.log(\"找喬國老幫忙，讓吳國太施予壓力\");&#125;class GivenGreenLight implements IStrategy &#123; public operate = () =&gt; console.log(\"找吳國太開綠燈，給予放行\");&#125;class BlockEnemy implements IStrategy &#123; public operate = () =&gt; console.log(\"孫夫人斷後，擋住追兵\");&#125; 還需要裝著計策的錦囊，以及一個執行人 趙雲。 1234567891011121314151617181920212223class Context &#123; private strategy: IStrategy; constructor(strategy: IStrategy) &#123; this.strategy = strategy; &#125; public operate = () =&gt; this.strategy.operate();&#125;// ZhaoYun(() =&gt; &#123; let context: Context; console.log(\"--剛到吳國拆第一個--\"); context = new Context(new BackDoor()); context.operate(); console.log(\"------------------\"); console.log(\"--劉備樂不思蜀，拆第二個--\"); context = new Context(new GivenGreenLight()); context.operate(); console.log(\"------------------\"); console.log(\"--孫權小兵殺來，拆第三個--\"); context = new Context(new BlockEnemy()); context.operate(); console.log(\"------------------\");&#125;)() 策略模式的定義Define a family of algorithms, encapsulate each one, and make them interchangeable.(定義一組算法，將每個算法封裝起來，並且使它們之間可以互換。) 12345678910111213141516171819202122interface IStrategy &#123; doSomething(): void;&#125;class ConcreteStrategy1 implements IStrategy &#123; public doSomething = () =&gt; console.log(1);&#125;class ConcreteStrategy2 implements IStrategy &#123; public doSomething = () =&gt; console.log(2);&#125;class Context &#123; private strategy: IStrategy; constructor(_strategy: IStrategy) &#123; this.strategy = _strategy; &#125; public doAnything = () =&gt; this.strategy.doSomething();&#125;(() =&gt; &#123; let strategy = new ConcreteStrategy1(); let context: Context = new Context(strategy); context.doAnything();&#125;)() 回顧 使用了 OO的繼承跟多態。 要定義哪個行為，是抽象策略介面。Pros : 算法可以自由切換 : 只要有實現抽象策略，就成為了策略家族的一個成員，通過封裝腳色對其進行封裝，保證對外提供”可自由切換”的策略。 去除多重條件判斷 : 因為多重條件不容易維護閱讀，且改壞的機率很大。使用了策略模式後，可能由其他模塊決定採用什麼策略，對外提供的訪問接口就是封裝類別，簡化了操作，也避免掉條件判斷。 擴展性良好 : 只要新增一個策略成員並且實現接口就能, 類似於一個可反覆拆裝的插件，為此這模式符合了OCP原則。Cons : 策略類別太多 = 類別膨脹, 可重複利用程度非常小。 所有策略類別都需要對外暴露: 上層模組一定要知道有哪些策略，才能決定怎麼使用。這樣違反了LKP原則(最少知識原則); 但可以用工廠模式、代理模式或是享元模式解決。 使用場景 多個類別只有在算法或是行為上稍有不同的場景 算法需要自由切換的場景 需要屏蔽算法規則的場景 ; 調用者不必了解太多細節，能依據策略名稱就能知道怎使用，然後反饋給他一個極果，就結束了。 如果策略超過4個，應該要考慮混和模式，解決策略類別過長跟對外暴露的問題。 策略模式的例子加減乘除計算器Version 1 12345678910111213141516171819202122class Calculator &#123; private static readonly ADD_SYMBOL: string = \"+\"; private static readonly SUB_SYMBOL: string = \"-\"; public exec = (a: number, b: number, symbol: string) =&gt; &#123; let result: number = 0; if(symbol === Calculator.ADD_SYMBOL)&#123; result = this.add(a, b); &#125;else if (symbol === Calculator.SUB_SYMBOL) &#123; result = this.sub(a, b); &#125; return result; &#125; private add = (a: number, b: number) =&gt; a + b; private sub = (a: number, b: number) =&gt; a - b;&#125;(() =&gt; &#123; let a = 1; let symbol:string = \"+\"; let b = 2; let cal = new Calculator(); console.log(cal.exec(a, b, symbol));&#125;)() Version 2使用三元運算子簡化主邏輯 1234567891011121314151617181920212223242526272829302345678910111213141516class Calculator &#123; private static readonly ADD_SYMBOL: string = \"+\"; private static readonly SUB_SYMBOL: string = \"-\"; public exec = (a: number, b: number, symbol: string) =&gt; symbol === Calculator.ADD_SYMBOL ? a+b : a-b; &#125;(() =&gt; &#123; let a = 1; let symbol:string = \"+\"; let b = 2; let cal = new Calculator(); console.log(cal.exec(a, b, symbol));&#125;)() Version 3 引入策略模式由上下文角色決定具體策略; 並且封裝角色保證策略時可以相互替換 1234567891011121314151617181920212223242526272829interface Calculator &#123; exec(a: number, b: number): number;&#125;class Add implements Calculator &#123; constructor() &#123;&#125; public exec = (a: number, b: number): number =&gt; a+b; &#125;class Sub implements Calculator &#123; constructor() &#123;&#125; public exec = (a: number, b: number): number =&gt; a-b; &#125;class Context &#123; private cal: Calculator; constructor(_cal: Calculator) &#123; this.cal = _cal; &#125; public exec = (a: number, b: number, symbol: string) =&gt; this.cal.exec(a,b);&#125;(() =&gt; &#123; const ADD_SYMBOL: string = \"+\"; const SUB_SYMBOL: string = \"-\"; let a = 1; let symbol:string = \"+\"; let b = 2; let context: Context; if (symbol === ADD_SYMBOL) context = new Context(new Add()); else if (symbol === SUB_SYMBOL) context = new Context(new Sub()); console.log(context!.exec(a, b, symbol));&#125;)() Version 4 引入策略列舉","categories":[],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://tedmax100.github.io/tags/Design-Pattern/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://tedmax100.github.io/tags/TypeScript/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://tedmax100.github.io/tags/JavaScript/"}]},{"title":"Factory Pattern Cont’d","slug":"Factory-Pattern-Cont’d","date":"2019-02-20T05:48:39.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/02/20/Factory-Pattern-Cont’d/","link":"","permalink":"https://tedmax100.github.io/2019/02/20/Factory-Pattern-Cont’d/","excerpt":"","text":"Simple Factory Method (簡單工廠模式)也稱為靜態工廠模式，去掉了抽象工廠類別，簡單實現，但缺點 工廠類的擴展就困難了，會不符合開閉原則。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354interface Human &#123; // 取得膚色 getColor(): void; //說話 talk() : void;&#125;class BlackHuman implements Human&#123; public getColor = () =&gt; &#123; console.log(\"黑人膚色是黑色的。\"); &#125; public talk = () =&gt; &#123; console.log(\"黑人會說話，一般人聽不懂\"); &#125;&#125;class YellowHuman implements Human&#123; public getColor = () =&gt; &#123; console.log(\"黃種人膚色是黃色的。\"); &#125; public talk = () =&gt; &#123; console.log(\"黃種人會說話，說的都是2byte的文字\"); &#125;&#125;class WhiteHuman implements Human&#123; public getColor = () =&gt; &#123; console.log(\"白人膚色是白色的。\"); &#125; public talk = () =&gt; &#123; console.log(\"白人會說話，說的都是1byte的文字\"); &#125;&#125;class HumanFactory &#123; public static createHuman&lt;T extends Human&gt;(type: (new () =&gt; T)): T &#123; let human: any = &#123;&#125;; // let testType: new() =&gt; T| undefined ; debugger; try &#123; human = new type();//(&lt;any&gt;Object).assign(human, new type()); &#125;catch(exp) &#123; console.error(exp); &#125; return human as T; &#125;&#125;(() =&gt; &#123; let whiteUhman = HumanFactory.createHuman&lt;WhiteHuman&gt;(WhiteHuman); whiteUhman.getColor(); whiteUhman.talk(); let balckhman = HumanFactory.createHuman&lt;BlackHuman&gt;(BlackHuman); balckhman.getColor(); balckhman.talk(); let yellowHuman = HumanFactory.createHuman&lt;YellowHuman&gt;(YellowHuman); yellowHuman.getColor(); yellowHuman.talk();&#125;)(); Multiple Factorys往往在複雜的業務項目上，會遇到一個產品類，有超多種的實現類。每個實現類的初始化方法都不太依樣，如果寫在一個工廠方法之中，一定會導致該方法複雜無比。要讓結構清晰，就替每個產品定義一個創造者，然後由調用者去選擇與哪個工廠方法做關聯。好處 創建類別職責清晰，且結構簡單，但是可擴展性和維護帶來一定影響。因為多一個產品，就要堆一個工廠類，還得考慮對象之間的關係。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162namespace MultipleFactories &#123; interface Human &#123; // 取得膚色 getColor(): void; //說話 talk() : void;&#125;class BlackHuman implements Human&#123; public getColor = () =&gt; &#123; console.log(\"黑人膚色是黑色的。\"); &#125; public talk = () =&gt; &#123; console.log(\"黑人會說話，一般人聽不懂\"); &#125;&#125;class YellowHuman implements Human&#123; public getColor = () =&gt; &#123; console.log(\"黃種人膚色是黃色的。\"); &#125; public talk = () =&gt; &#123; console.log(\"黃種人會說話，說的都是2byte的文字\"); &#125;&#125;class WhiteHuman implements Human&#123; public getColor = () =&gt; &#123; console.log(\"白人膚色是白色的。\"); &#125; public talk = () =&gt; &#123; console.log(\"白人會說話，說的都是1byte的文字\"); &#125;&#125;abstract class AbstractHumanFactory &#123; public abstract createHuman(): Human ;&#125;class YellowHumanFactory extends AbstractHumanFactory &#123; public createHuman = (): YellowHuman =&gt; &#123; return new YellowHuman(); &#125;&#125;class BlackHumanFactory extends AbstractHumanFactory &#123; public createHuman = (): BlackHuman =&gt; &#123; return new BlackHuman(); &#125;&#125;class WhiteHumanFactory extends AbstractHumanFactory &#123; public createHuman = (): WhiteHuman =&gt; &#123; return new WhiteHuman(); &#125;&#125;(() =&gt; &#123; let whiteUhman = new WhiteHumanFactory().createHuman(); whiteUhman.getColor(); whiteUhman.talk(); let balckhman = new BlackHumanFactory().createHuman(); balckhman.getColor(); balckhman.talk(); let yellowHuman = new YellowHumanFactory().createHuman(); yellowHuman.getColor(); yellowHuman.talk();&#125;)();&#125; Lazy initialization 延遲初始化一個物件被消費完成後，不立刻釋放，而是保持其初始狀態，等待被再度使用。這是工廠模式的一種擴展應用。 123456789101112131415161718192021class Product &#123;&#125;class ConcreteProduct1 extends Product &#123;&#125;class ConcreteProduct2 extends Product&#123;&#125;class ProductFactory &#123; private static prMap: Map&lt;string, Product&gt; = new Map(); public static createProduct: Product = (type: string): Product|undefined =&gt; &#123; let product = null; if(ProductFactory.prMap.has(type)) &#123; product = ProductFactory.prMap.get(type); &#125;else&#123; if(type === \"Product1\") &#123; product = new ConcreteProduct1(); &#125;else&#123; product = new ConcreteProduct2(); &#125; // 把物件 放到緩存中 ProductFactory.prMap.set(type, product); &#125; return product; &#125;&#125; 舉例，像是Conneection Pool都會要求設置MaxConnection最大連線數量，該數量就是記憶體中instance的數量。 Conclusion很多官方與第三方套件之中都包含工廠方法，且工廠方法還能與其他模式混搭使用(模板模式、單例、原型模式等)，有多更適合的設計。","categories":[],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://tedmax100.github.io/tags/Design-Pattern/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://tedmax100.github.io/tags/TypeScript/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://tedmax100.github.io/tags/JavaScript/"}]},{"title":"Factory Pattern","slug":"Factory-Pattern","date":"2019-02-19T05:45:41.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/02/19/Factory-Pattern/","link":"","permalink":"https://tedmax100.github.io/2019/02/19/Factory-Pattern/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031/* 定義人類與人種 */interface Human &#123; // 取得膚色 getColor(): void; //說話 talk() : void;&#125;class BlackHuman implements Human&#123; public getColor = () =&gt; &#123; console.log(\"黑人膚色是黑色的。\"); &#125; public talk = () =&gt; &#123; console.log(\"黑人說話，一搬人聽不懂\"); &#125;&#125;class YellowHuman implements Human&#123; public getColor = () =&gt; &#123; console.log(\"黃種人膚色是黃色的。\"); &#125; public talk = () =&gt; &#123; console.log(\"黃種人會說話，說的都是2byte的文字\"); &#125;&#125;class WhiteHuman implements Human&#123; public getColor = () =&gt; &#123; console.log(\"白人膚色是白色的。\"); &#125; public talk = () =&gt; &#123; console.log(\"白人會說話，說的都是1byte的文字\"); &#125;&#125; 1234567891011121314151617/* 抽象人類工廠，透過泛型對createHuman的輸入參數產生限制 : 1. class型別 ; 2. 必須實現Human */abstract class AbstractHumanFactory &#123; public abstract createHuman&lt;T extends Human&gt;(type: (new () =&gt; T)): T ;&#125;// 實踐工廠class HumanFactory extends AbstractHumanFactory &#123; public createHuman&lt;T extends Human&gt;(type: (new () =&gt; T)): T &#123; let human: any = &#123;&#125;; try &#123; human = new type();//(&lt;any&gt;Object).assign(human, new type()); &#125;catch(exp) &#123; console.error(exp); &#125; return human as T; &#125;&#125; 12345678910111213執行 創物者(() =&gt; &#123; let creator: AbstractHumanFactory = new HumanFactory(); let whiteUhman = creator.createHuman&lt;WhiteHuman&gt;(WhiteHuman); whiteUhman.getColor(); whiteUhman.talk(); let balckhman = creator.createHuman&lt;BlackHuman&gt;(BlackHuman); balckhman.getColor(); balckhman.talk(); let yellowHuman = creator.createHuman&lt;YellowHuman&gt;(YellowHuman); yellowHuman.getColor(); yellowHuman.talk();&#125;)(); 123456白人膚色是白色的。白人會說話，說的都是1byte的文字黑人膚色是黑色的。黑人會說話，一般人聽不懂黃種人膚色是黃色的。黃種人會說話，說的都是2byte的文字 Definition :Define an interface for creating an object, but let subclasses decide which class to instantiate Factroy Method lets a class defer instantiation to subclasses.定義一個用於創建對象的介面，讓子類別決定實例化哪一個類別，使一個類別的實例化延遲到其子類別 Pros : 良好的封裝性，結構清晰，一個對象的建立是有條件約束的，降低耦合性。 拓展性優秀，增加業務產品類別十，只要擴展一個工廠類，就能”擁抱變化”。 封裝屏蔽產品類，產品類的實現如何變化，調用者根本不需要關心，他只關心產品的接口。 滿足 迪米特法則(最小知識原則), 滿足依賴倒置原則，滿足里氏替換原則。 萬物皆對象，所以萬物也就是產品類。 Example : JDBC, 從MySQL切換到Oracle，就是更換一下驅動名稱。 MailServer 有 POP3、IMAP、HTTP，把這三種定義為產品類，定義介面IConnectMail，再定義工廠方法，按照不同條件，選擇不同連接方式，做到完美的拓展。 單元測試, 測試類別A，類別有關連到類別B，用工廠方法把類別B虛擬出來，就能Mock依賴物件。","categories":[],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://tedmax100.github.io/tags/Design-Pattern/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://tedmax100.github.io/tags/TypeScript/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://tedmax100.github.io/tags/JavaScript/"}]},{"title":"Rx and Pormise","slug":"Rx-and-Pormise","date":"2019-02-14T04:59:23.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/02/14/Rx-and-Pormise/","link":"","permalink":"https://tedmax100.github.io/2019/02/14/Rx-and-Pormise/","excerpt":"","text":"Reactive Programing (響應式編程)Def : 一種面向(data flow)數據流和(propagation of change)變化傳播的編程風格。 propagation of change 變化傳播最初的資料是否會隨著後續對應變量的變化而變化。 在inperative programming中A+B=C 2+3=52+4=5 not 6當B的資料發生改變之後，C的數值必沒有隨著B的改變而改變。 在Reactive Programing中A+B=C2+3=52+4=6 在MVVM中，存在一種M到V的綁定關係當Model由model1變為model2時，View也隨之進行了變化，從view1變成view2.所以MVVM框架，也實現了RX中的propagation of change概念。 data flow(stream)監聽一系列的事件流，並對這一系列事件進行 映射(Map)、過濾(Filter)、合併(Merge)等處理後，在響應整個事件流的callback(回調)，該過程便是 面相數據流的編程。 數據流被封裝在一個叫做Observable的實例中，通過觀察者模式，對數據流進行統一的訂閱，並在中間插入像filter這樣的操作，從而對Observable所封裝的數據流進行處理。 1myObservable.filter(fn).subscribe(callback); ReactiveX微軟開發維護的Reactive Programing套件。結合了 觀察者模式、迭代器模式、函數式編程(Functional Programming)。 ObservableRx核心概念!!所有產生出來的非同步數據都先包裝程Observable對象，Observable對象是把這些非同步數據轉換成 data stream的形式。所以這些Observable對象等同於data stream的源頭，後續操作都圍繞著這些被轉換的流動數據展開的。上圖最上方的箭頭(時間軸)表示了最初的Observable對象，這個對象發出了3個數據，這3個可能是點擊事件的數據，也可能是response的數據。經過map處理後，原來的Observable對象會變成一個新的Observable對象，並且原來的3個數據會轉換成新的數據在新的Observable對象數據流裡流動。 概念雷同於 工廠生產線上的 生產流水線。Observable對象相當於半成品，map相當於流水線上的工人，加工後變成成品。 RX 是 借鑒了集合的操作思想，把複雜的非同步數據流處理問題，簡化成同步的集合處理問題。換言之，開發者能透過Observable，操作集合一樣操作複雜的非同步數據流。 OperatorOperator是實現了迭代器模式、函數式編程的利器。Operator是Observable的操作方式。每一個數據流，都能透過某個operator對該Observable對象進行操作。大部分operator操作完後，會返回一個新的Observable對象給下一個operator處理。也因此，這樣方便在各個operator間透過鍊式寫法編寫。 123let newObservable = observable .debounceTime(500) .take(2); Compare With Promise能用promise的場景, RxJs都適用，因為RxJs是作為promise的超集合存在的。 12345let promise = new Promise((resolve, reject) =&gt; &#123; // some code if(/* 異步執行成功 */) resolve(value); reject(error);&#125;); 123456let observable = new Observable((observer) =&gt; &#123; observer.next(value1); observer.next(value2); observer.error(err);&#125;) Pormise只能針對單一的非同步事件進行resolve()，但在Observable中，不僅能處理單一的非同步事件(就是調用observer的next())，而且能以streaming形式響應多個非同步事件。還有對於Promise中的all()、race()等，RxJs都有對應的解決方案。 12let newPromise = Promise.all(promiseReq1, promiseReq2);let newObservable = Rx.Observable.forkJoin(obsReq1, obsReq2);","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://tedmax100.github.io/tags/JavaScript/"},{"name":"Rx","slug":"Rx","permalink":"https://tedmax100.github.io/tags/Rx/"}]},{"title":"AWS CloudFront","slug":"AWS-CloudFront","date":"2018-12-15T04:56:46.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2018/12/15/AWS-CloudFront/","link":"","permalink":"https://tedmax100.github.io/2018/12/15/AWS-CloudFront/","excerpt":"","text":"AWS CloudFront CloudFront加快靜態和動態web內容分配給用戶的Web服務。 透過全球數據中心(edge location)來傳輸內容。當user向CloudFront請求提供內容時，user會被陸游到提供最低延遲的edge location，以最佳的速度傳送內容。如果內容已經存在edge location十，則cloudfront將直接提供它。(但我們的情境不需要去快取資料)如果請求的內容不再edge，則會對web server進行查找。 配置CloudFront配置source server，CloudFront將從這些server獲取資料。source server儲存的對象是當下最終的版本。建立CloudFront distribution，user通過你的網站或api在請求資料時，告訴cloudfront從那些source server來獲取資料。還需要指定cloudfront是否記錄所有請求以及該分配建立後立即啟用。將配置發送到所有edge location。 Optional configuration:可以配置source server對response添加header;header能設置希望資料再edge location保留的時限。默認是保留24hr。minimum expiration = 0s HTTP MethodsPOST/PUT/PATCH/OPTIONS/DELETE，將直接從edge location站點直接會到連source server，並不會流過regional edge location做快取查找。 指定對象在CloudFront edge location的expirationValues That You Specify When You Create or Update a Web Distribution Lab CloudFront + S3 : Staging config : Restrict Bucket Access： 選擇”Yes”，因為希望網站是向CloudFront存取，而不是向S3。 Query String Forwarding and Caching : only for APICertifacate type : TLS11","categories":[],"tags":[{"name":"AWS","slug":"AWS","permalink":"https://tedmax100.github.io/tags/AWS/"}]},{"title":"JS Clean Code訓練營","slug":"JS-Clean-Code訓練營","date":"2018-10-09T04:46:57.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2018/10/09/JS-Clean-Code訓練營/","link":"","permalink":"https://tedmax100.github.io/2018/10/09/JS-Clean-Code訓練營/","excerpt":"","text":"12345678910111213第一天 :有效的单元测试识别依赖隔离依赖前端逻辑的常见剥离方式Stub与Mock处理Callback和Promise第二天 : 小步重构识别代码臭味处理代码臭味的技巧良好设计的基本原则消除重复，降低复杂度 Day1 :Lesson 1:1 .FizzBuzz 數學歸納法: n =1 =&gt; n+1 ok一個it test, 通常證明2個test case Vue_Header profileCaption test Lesson 2:單元測試的好處: “提早”得知程式碼是否有漏洞; 提早設置check point。 回歸測試 自動運行 說明文件 建立可重複利用的元件 任何測試案例應該是獨立的 使用者角度去做測試案例 private method不應該被特別測試，因為第7點的關係，使用者只在意公開方法，且私有方法一定會被公開方法給使用到。 基本上單元測試，都是黑盒測試，因為只在意輸出入。 單元測試要快 使用類似jest的框架，整合模擬測試ui上的行為 Lesson 3 :物件導向設計原則: 組件 應該要具備 高內聚、低耦合 的特性 物件導向的繼承關係，就是高耦合 只要function內有new()，也是高耦合 Stub : state changeMock : behavior test (called, parameter…) Lesson 4:一一一一一一一一一一一一一一一一一一一UT —————————–&gt; IT Unit Test: 速度快 程式少 定位問題簡單 代碼依賴剝離 成本高 無網路、文檔讀寫、外部第三方套件、跟運行環境無關的、與配置無關 Integration Test: 速度慢 程式多 定位問題多 代碼依賴剝離 成本低 前端的UI 異步執行 Refactoring moment.js(會修改自身，產生副作用) -&gt; date.js budget.js if 有return , else也return remove else 重複的邏輯 -&gt; extract method 可讀性低 || 註解 (因為怕看不懂，所以加註解) code smell 長方法 long method代碼行數過長 (code standard by group define) 多種數據結構 使用同一個數據 表達同一件事情。startDate &amp; endDate 進來後被轉成兩種不同的變數。 duplicate logic(code) temporary variable(Field) -&gt; Inline Temp 令人費解的命名 (不把型別加入命名中) -&gt; *Rename method clearly intention 資料謎團 data clump 抽象干擾 Abstraction Distraction 特性忌妒 Feature Envy 基礎型別偏執 primitive obssession how use inline option delete useless codes delete duplicate codes ; 先讓疑似重複的部分盡可能變得一樣，別一開始就提取代碼。 extract method rename covert param to object create data class change signature use loadash to make code to be clearly intention Refactor vs Rewrite Refactor: 行為與之前一樣，但代碼可讀性更高 Rewrite : 行為未必與之前一樣。 異動範圍大小 流程與結構的不同 Day2被提取出來的私有class，與私有方法，只要是只有被測試公開方法給涵蓋，且只有這些再用，就不必再額外寫測試。除非它後來有其他其他未被涵蓋測試的公開方法給引用。除非後來因為這些被提取的部分出bug，再補充其測試。 Refactor 擁抱變化 從legacy code 實現 演進式設計 建築 vs software design 藍圖 –build–&gt; 建築 代碼 –build–&gt; 軟體 UML 用來與人溝通，一致化想法用的語言，並非藍圖 JS 不一定適合套用design pattern, 只有少數的pattern適用 Legacy code type : new feature stable (已經上無數補丁，正在運行中) unused Lesson 2 MVC vs MVP MVC的進入點是controller -&gt; Model -&gt; Controller -&gt; View MVP的進入點式VIEW -&gt; Presenter -&gt; Model -&gt; Presenter -&gt; View Tell, Don’t ask -&gt; Design principle 防衛性編程 12345678fun A(xxx) &#123; if(A) ... return ___;&#125;let a = A(param);if(a) &#123; ....&#125; 在進入口做防範驗證，內部邏輯別做太多返回值的判斷。 調用者保證參數有效，被調用者保證返回值有效 Design Contract 給予 default value; 別用null 表達某一種邏輯 Null object pattern architecture view model presenter business model dto、dao Smells 註解 不適當的訊息 Inappropriate Information : 註釋只應該描述有關代碼跟設計的技術性訊息，不該帶作者、最後修改時間等。 因為GIT上會記錄。 廢棄的註解 Obsolete Comment:不正確或無關的註解。 冗餘註解 糟糕的註解 註解掉的代碼 方法 過多的參數 Too Many Arguments : 盡量少，沒參數最好，超過3個就要避免。 輸出參數 Output Arguments: appendFooter(s) 不如把footer設定在物件屬性內，再呼叫report.appendFoorer() 標示參數 Flag Arguments 123//pseudo-codeclass Concert... public Booking book (Customer aCustomer, boolean isPremium) &#123;...&#125; 12public Booking regularBook(Customer aCustomer) &#123;...&#125;public Booking premiumBook(Customer aCustomer) &#123;...&#125; * 死方法 Dead Function 一般問題 重複 DRY (Don’t Repeat Yourself): 資料庫正規化，物件導向繼承 接口提供過多 Too Much Information 特性依戀 Feature Envy: 類別的方法只對類中的屬性跟方法有興趣，不該依靠其他類中的變數跟方法。顯然是「內聚力」不夠的一種現象","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://tedmax100.github.io/tags/JavaScript/"},{"name":"CleanCode","slug":"CleanCode","permalink":"https://tedmax100.github.io/tags/CleanCode/"}]},{"title":"Introduce to RabbitMQ","slug":"Introduce-to-RabbitMQ","date":"2017-12-13T04:29:48.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2017/12/13/Introduce-to-RabbitMQ/","link":"","permalink":"https://tedmax100.github.io/2017/12/13/Introduce-to-RabbitMQ/","excerpt":"RabbitMQ Tutorials","text":"RabbitMQ Tutorials What is RabbitMQ?RabbitMQ是實現AMQP的一種微服務，用於分散是系統之中來儲存轉發訊息，便於使用，方便擴展，又有高可用性。目的能替系統之間做雙向解耦。當生產者產出大量資料要送出時，消費者若無法快速消費掉，這時候就需要一個中介層，來保存這些數據。 AMQP的工作流程如下圖 : message被publisher 發送給exchange，exchange常常被比喻為郵局或是郵箱。然後exchange根據收到的message以及規則分發給綁定的queue。最後AMQP代理會將message投遞給訂閱此queue的consumer，或是消費者依照需求自行獲取。 因為網路是不可靠的，接收消息的服務也有可能在處理時失敗，所以AMQP包含的一了message acknowledgement的概念:當一個message從queue當中投遞給consumer後，consumer會通知broker，這個message可以從queue當中刪除。 某些情況下，當message無法被成功投遞時，message或許會被返回給producer並且被丟棄。或者代理執行了延期操作，message會被放入Dead-Letter exchange中。此時producer可選選擇某些參數來處理這些特殊情況。 一個Log系統，能用MQ來簡化工作，一個consumer進行訊息的正常處理，另一個consumer對訊息做log紀錄，只要在系統中，起兩個consumer並把queue以相同的方式binding到同一個exchange即可。 剩下的訊息分派工作全由MQ負責完成。 Concept and Feature Broker就是MQ service本身 Producer發送message的程序 Consumer一個等待從queue當中獲取message的程序 Virtual Host一個broker內可以設置多個Vhost，做為不同用戶的權限分離，或是不同的業務規劃。Vhost之間相互隔離，不同Vhost之間無法共享exchange/queue。 Exchange交換機，指定消息按照什麼規則，路由到哪個queue。有direct、topic、headers、fanout 四種type能設置,不同type的exchange路由行為是不同的。 Queue每個message都會被投遞到一個或是多個queue當中，等待被投遞。類似於郵筒的概念，message都會被存放在此。queue本身是一個很大的message buffer，可以有很多個producer發送，但都會傳到同一個queue且可以有多個consumer獲取資料。 Channel在客戶端的每個connection中，可以建立多個channel,每個channel表示一個session， 客戶端只能透過channel才能執行AMQP的命令。之所以需要channel因為TCP連線的建立跟釋放都是十分昂貴的，如果一個客戶端的每個線程都需要與broker交換訊息，每一個線程都建立一個TCP connection的話，OS也無法承受每秒建立如此多的TCP connection。所以RabbitMQ建議同一個發送串行資料的線程共用Channel和connection。 Binding把exchange和queue按照路由規則綁釘起來。Exchange在跟多個queue binding後會生成一張routing table， Routing Key路由的關鍵字，exchange根據這關鍵字，來進行訊息投遞 AMQP entitiesQueue + Exchange + Binding = AMQP entities Task QueuesTask queues工作隊列，是為了避免等待一些占用大量資源、費時的操作。只要把task當作訊息丟進queue中，就會有運行的worker取出任務然後處理，當運行多個workers時，任務就會在彼此之間分配。 Message Acknowledgment通常沒特別設置ack在queue的時候，只要message一投遞出去，立刻就為從queue之中移除。此時如果worker運行到一半掛掉，正在處理的message就會遺失了。如果不想遺失任何message，當前worker掛掉時，我們希望任務會重新指派給其他worker。 因此，RabbitMQ提供了acknowledements。worker會通過一個ack訊號，告訴RabbitMQ已經收到了並且處理完該條訊息，然後MQ就會刪除該訊息。 如果worker掛了，沒有發送ack，則MQ就會認為message沒有被完全處理，就會重新發送給其他worker，這樣就不會遺失任何message。 但由於message沒有timeout的概念，只能等worker跟MQ斷開連線，這樣MQ就會重送了。message acknowledement預設是關閉的，只要把auto_ack = true即可。 1234567891011var consumer = new EventingBasicConsumer(channel);consumer.Receved += (model, ea) =&gt;&#123; var body = ea.body; var message = Encoding.UTF8.GetString(body); Console.WriteLine($\"&#123;received &#123;message&#125;&#125;\"); int dots = message.Split('.').Length - 1; Thread.Sleep(dots * 1000); Console.WriteLine(\"Done\"); channel.BasicAck(deliveryTag : ea.DeliveryTag, multiple:false);&#125;;channel.BasicAck(queue:\"task_queue\", autoAck:True, consumer :consumer); Increase throuput and performance關閉ack能提升MQ的效能 Message DurabilityMessage Durability訊息持久化，MQ預設並不會對queue和message做持久化的設置，因此必須先把queue和message設置為durable。 首先先聲明queue為durable，這樣確保MQ重啟後，queue不會被遺失。MQ也不允許使用不同參數定義一個同名的queue。因此producer和consumer的設置必須一樣。 12345channel.QueueDeclare(queue:\"task_queue\", durable :true, exclusive:false, autoDelete:false, arguments:null); 接著設置message persistence 12var properties = channel.CreateBasicProperties();properties.Persistent = true; Note on message persistence把message 設置為persistence，並不能完全保證不會丟失。因為只是告訴MQ要把message存入硬碟，MQ也不是所有message都寫入硬碟，可能只是放在記憶體暫存。 Fair DispatchMQ只管把第n-th消息投遞給第n-th個worker，並不關心worker有沒有ack。可以設置prefetch_count=1，告訴MQ，同一時間，別送超過1條訊息給同一位worker，直到他已經處理完上一條message並送出ack。這樣MQ就會把消息分發給下一位worker。 1channel.basicqos(0, 1, false); Publish/Subscribepub/sub目的是要把一個message分發給多個consumer。這個模型的核心概念是，producer並不會直接發送訊息給queue，而是把消息發送給exchange。 exchange在這裡就是負責從producer接收消息，一邊把消息推送到queue。exchange必須知道如何處理它接受到的消息，是要推送到指定的queue還是多個queue，或是忽略，這些規則是透過exchange type來定義。 Exchange Type direct 直連 fanout 廣播 topic 主題 headers 表頭1channel.ExchangeDeclare(\"logs\", \"fanout\"); Note for default exchangeMQ預設就存在一組default exchagne，名稱是空字串”” Temporary queues在task queue的情境下，給個worker同樣的queue name，這時候會透過round robin做輪詢派送。但是現在要的是每個人都能收到同樣的訊息，因此需要的是一個全新、空的queue，來跟exchagne綁定。能透過自己定義隨機的queue name或是，讓MQ來幫我們選擇一個隨機的queue name。 1var queueName = channel.QueueDeclare().QueueName; 這時拿到的queue name就會類似amq.gen-JzTY20BRgKO-HjmUJj0wLg。 Bindings有了fanout exchange和數個queue，這時就要設置exchange和queue之間的關聯。 123channel.QueueBind(queue:queueName, exchagne:\"logs\", routingKey:\"\"); Note for routing keyfanout type下，routing key是會被忽略的。 RoutingRouting key的設置，能使得queue只訂閱消息的子集合。綁定的時候可以設置routingKey又或是稱為bindingKey，為了避免跟BasicPublish的routingKey搞混。 123channel.QueueBind(queue:queueName, exchange:\"direct_logs\", routingKey:\"black\"); 使用exchange和routing key來進行精確配對，從而確保消息該投遞到哪個queue。 這裡第一個queue用orange作為綁定鍵，另一個queue用black和green。這樣所有orange的消息都會被路由到C1, 而black/green則會被路由到C2，其他message通通被丟棄。 Multiple Bindings多個queue使用同樣的routingKey也是可行的。 C1和C2都使用black做綁定。這樣跟fanout type的行為雷同，只要是black的訊息，C1跟C2都會收到，但其他一樣被丟棄。 Scene : Log System將log依據不同級別作為rougingKey來選擇接收者跟處理方式。建立exchange 1channel.ExchangeDeclare(exchange: \"direct_logs\", type: \"direct\"); 發送log訊息, serverity是info、warning、error其中一個 12345var body = Encoding.UTF8.GetBytes(message);channel.BasicPublish(exchange: \"direct_logs\", routingKey: severity, basicProperties: null, body: body); subscribing 1234567var queueName = channel.QueueDeclare().QueueName;foreach(var severity in args)&#123; channel.QueueBind(queue: queueName, exchange: \"direct_logs\", routingKey: severity);&#125; TopicsDirect exchange有些限制，沒辦法基於多個標準來執行路由操作。有時會希望不只是訂閱基於嚴重程度的日誌，也希望訂閱其他種日誌。這時就需要topic exchange。 發送到topic exchange的訊息不可以設置routingKey，它的routingKey是一個由.分隔開的單字列表。這些單字是什麼都能，跟message有關係的詞彙是最好的。例如:”stock.usd.nyse”, “quick.orange.rabbit”，單字個數可以任意個，但不能超過255 bytes。routingKey中也能使用類似regular expression表達個數: 表示一個單字 表示任意數量的單字一個攜帶有quick.orange.rabbit的消息會被投遞到C1跟C2。攜帶著lazy.orange.elephant的也是。quick.orange,fox只會投遞給C2。lazy.pink.rabbit只會給C2投遞1次。quick.brown.fox的將會被丟棄。orange和quick.orange.male.rabbit的都會被丟棄掉。lazy.orange.male.rabbit將會被投遞到C2。 topic exchange是很powerful的，它可以表現出其他exchnge type的行為。 當一個queue的routingKey是#時，這個queue將會無視message的routingKey，接收全部message。 當*和#都未出現在routingKey時，這時候就跟direct type是一樣的行為。 Questions bindingKey為*的queue會取到一個routingKey為空字串的消息嗎? bindingKey為#.的queue會收到一個routingKey為*..的消息嗎? 它會收到routingKey為一個單字的消息嗎? a.*.#和a.#的區別? RPC遠端過程調用Remote Procedure Call(RPC)如果需要將一個函式運行在遠端服務上並且等待結果時，這時就需要RPC。 透過RabbitMQ來建造一個RPC System，一個client和一個RPC Server。 client interface 1234var rpcClient = new RPCClient();Console.WriteLine(\"Request fib()\");var response = rpcClient.Call(\"30\");Console.WriteLine($\"Got &#123;0&#125;\", response); RabbitMQ Cluster and High AvailableRabbitMQ Cluser設置要求所有機器上的Erlang和RabbitMQ版本需要都相同，機器上Erlang的Cookie也相同","categories":[],"tags":[{"name":"MQ","slug":"MQ","permalink":"https://tedmax100.github.io/tags/MQ/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://tedmax100.github.io/tags/RabbitMQ/"}]},{"title":"Rx_IEnumberbale和IObservable","slug":"Rx-IEnumberbale和IObservable","date":"2017-11-26T04:25:25.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2017/11/26/Rx-IEnumberbale和IObservable/","link":"","permalink":"https://tedmax100.github.io/2017/11/26/Rx-IEnumberbale和IObservable/","excerpt":"","text":"Rx可以做的事情Rx可以處理很多內容，例如async處理、event、IEnumberable等，例如 :MouseClick event、MousePosition等等的事情還有對於時間的處理，例如Timer，可以想成是指定時間間隔會發生的事件的值。還有async，可以想像成某個時間點，才開始進行的處理，且處理完成後，才會得到某個值。 Rx和LinqRx最基本的介面是IObservable(T) (被觀察者)，它與.NET常見的IEnumerable是不同的。但是能跟用Linq查找的方法一樣來查找。 12345678using System.Reactive.Linq;//LinQ to Objectsvar ix = from x in Enumerable.Range(1,10) where x % 2 == 0 select x * x;var rx = from x in Observable.Range(1,10) where x % 2 == 0 select x * x; Rx裡雖然增加了不少新的方法，但是大部分的同名方法操作跟定義上都跟原本的一樣，這降低了很多學習成本。雖然介面不同，但是都可以用Linq expression來達成同樣的效果。所以IObservable/IObserver 和 IEnumerable/IEnumerator，可以視前者為後者的反轉。 這段Code將描述IObserver介面如何反轉IEnumberator介面的。 123456789101112131415161718192021222324252627282930313233//簡化過的IEnumerator&lt;T&gt;public interface IEnumberator&lt;T&gt;&#123; T current&#123;get;&#125; bool MoveNext(); //void Reset(); Reset現在一般不使用&#125;//MoveNext改回傳bool,再調用currentpublic interface IEnumberator&lt;T&gt;&#123; //MoveNext回傳T的instance //如果結束的話，則不回傳(== void) //異常的話，拋出 //因此有3種類型的回傳 T|void|Excecption GetNext(void);&#125;//根據對偶性(Duality)，將參數和回傳值互換位置//以前都是被動式的去取Pull，現在則是主動的拿到Push，//所以改用Gotpublic interface IEnumeratorDual&lt;T&gt;&#123; void GotNext(T|void|Exception);&#125;//進而按照Pull的3種回傳類型，分開定義介面public interface IEnumeratorDual&lt;T&gt;&#123; void GotNext(T); void GotVoid(void); void GotException(Exception);&#125;//最後視現在用的IObserver&lt;T&gt;介面public interface IObserver&lt;T&gt;&#123; void OnNext(T value); void OnComplete(); void OnError(Exception error);&#125; 所以IObservable和IEnumberator視可以相互轉換的，兩人可透過彼此的擴充方法相互轉換。且這些擴充方法，在Rx中都已經定義了。通過這突，可以清楚的了解IEnumerable是Pull,而IObservable是Push。 Event use Rx123456789//監聽Mouse move eventpublic static IObservable&lt;MouseEventArgs&gt; MouseMoveAsObservable(this Form form)&#123; return Observable.FromEventPattern&lt;MouseEventArgs&gt;(from, \"MouseMode\").Select(e =&gt;e.EventArgs);&#125;public void TextChangeAsObservable()&#123; //等待1秒後若沒在收到新的資料，就用最近收到的資料來處理 Observable.FromEventPattern&lt;EventArgs&gt;(textBox, \"TextChanged\").Select(_ =&gt;textBox.Text) .Throttle(TimeSpane.FromSeconds(1));&#125; Throttle可以設定一定的時間間隔，過濾掉一些不必要的輸入，上面範例中，一秒內無論發生多少次變化，只有最後一次的值才會被push出去。 Async By Rx12345678910111213141516171819202122232425var req = WebRequest.Create(\"http://hoge/\"); req.BeginGetResponse(ar =&gt; &#123; try &#123; var res = req.EndGetResponse(ar); var url = new StreamReader(res.GetResponseStream()).ReadToEnd(); var req2 = WebRequest.Create(url); // 在前面請求的結果上，再發請請求 req2.BeginGetResponse(ar2 =&gt; &#123; //再多次請求的處理下，往往需要在每一層加上try-catch try &#123; var res2 = req2.EndGetResponse(ar2); var str = new StreamReader(res2.GetResponseStream()).ReadToEnd(); Dispatcher.BeginInvoke(new Action(() =&gt; MessageBox.Show(str))); &#125; catch (WebException e) &#123; Dispatcher.BeginInvoke(new Action(() =&gt; MessageBox.Show(e.ToString()))); &#125; &#125;, null); &#125; catch (WebException e) &#123; Dispatcher.BeginInvoke(new Action(() =&gt; MessageBox.Show(e.ToString()))); &#125; &#125;, null); 1234567891011121314151617WebRequest.Create(\"http://hoge/\") .DownloadStringAsysnc() .SelectMany(url =&gt; WebRequest.Create(url).DownloadStringAsync()) .ObserveOnDisaptcher() .Subscribe( str =&gt;MeesageBox.Show(str), e =&gt; MessageBox.Show(e.ToString()); )public static class WebRequestExtensions&#123; return Observable.FromAsyncPattern&lt;WebResponse&gt;(request.BeginGetResponse, request.EndGetResponse)() .Select(res =&gt; &#123; using(var stram = res.GetResponseStream()) using(var sr = new StreamReader(stream))&#123; return sr.ReadToEnd(); &#125; &#125;);&#125; 使用Rx能把Lambda expression的call back改寫成Method Chain，降低閱讀複雜度。","categories":[],"tags":[{"name":"Rx","slug":"Rx","permalink":"https://tedmax100.github.io/tags/Rx/"}]},{"title":"State Pattern","slug":"State-Pattern","date":"2017-11-21T05:51:52.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2017/11/21/State-Pattern/","link":"","permalink":"https://tedmax100.github.io/2017/11/21/State-Pattern/","excerpt":"","text":"實作電梯電梯的動作: 開門、關門、運行、停止 123456789101112interface ILift &#123; open(): void; close(): void; run(): void; stop(): void&#125;class Lift implements ILift &#123; public open = () =&gt; console.log(\"電梯門打開\"); public close = () =&gt; console.log(\"電梯門關閉\"); public run = () =&gt; console.log(\"電梯上下運行\"); public stop = () =&gt; console.log(\"電梯停止\");&#125; 1234567891011(() =&gt;&#123; const lift: ILift = new Lift(); lift.open(); lift.close(); lift.run(); lift.stop();&#125;)()電梯門打開電梯門關閉電梯上下運行電梯停止 But!!!電梯是有狀態的, 有前提條件的。 不可能在運行時突然開門，或是停止了不開門的情況。所以動作執行都有前置條件，也就是在特定狀態下才能做特定事務。| | Open | Close | Run | Stop ||———-|——|——-|—–|——|| 開門狀態 | x | o | x | x || 關門狀態 | o | x | o | o || 運行狀態 | x | x | x | o || 停止狀態 | o | x | o | x | Version 1 : 加上前置條件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697enum LiftState &#123; OPENING_STATE = 1, CLOSING_STATE= 2, RUNNIG_STATE = 3, STOPPING_STATE = 4&#125;interface ILift &#123; setState(state: LiftState): void; open(): void; close(): void; run(): void; stop(): void&#125;class Lift implements ILift &#123; private state: LiftState; constructor() &#123; this.state = LiftState.STOPPING_STATE; &#125; public setState = (value: LiftState) =&gt; this.state = value; public open = () =&gt; &#123; switch (this.state) &#123; case LiftState.OPENING_STATE : break; case LiftState.CLOSING_STATE : this.openWithoutLogic(); this.setState(LiftState.OPENING_STATE); break; case LiftState.RUNNIG_STATE : break; case LiftState.STOPPING_STATE : this.openWithoutLogic(); this.setState(LiftState.OPENING_STATE); break; &#125; &#125; public close = () =&gt; &#123; switch (this.state) &#123; case LiftState.OPENING_STATE : this.closeWithoutLogic(); this.setState(LiftState.CLOSING_STATE); break; case LiftState.CLOSING_STATE : break; case LiftState.RUNNIG_STATE : break; case LiftState.STOPPING_STATE : break; &#125; &#125;; public run = () =&gt; &#123; switch (this.state) &#123; case LiftState.OPENING_STATE : break; case LiftState.CLOSING_STATE : this.runWithoutLogic(); this.setState(LiftState.RUNNIG_STATE); break; case LiftState.RUNNIG_STATE : break; case LiftState.STOPPING_STATE : this.runWithoutLogic(); this.setState(LiftState.RUNNIG_STATE); break; &#125; &#125; public stop = () =&gt; &#123; switch (this.state) &#123; case LiftState.OPENING_STATE : break; case LiftState.CLOSING_STATE : this.stopWithoutLogic(); this.setState(LiftState.STOPPING_STATE); break; case LiftState.RUNNIG_STATE : this.stopWithoutLogic(); this.setState(LiftState.STOPPING_STATE); break; case LiftState.STOPPING_STATE : break; &#125; &#125; private closeWithoutLogic = () =&gt; console.log(\"電梯門關閉...\"); private openWithoutLogic = () =&gt; console.log(\"電梯門開啟...\"); private runWithoutLogic = () =&gt; console.log(\"電梯上下運行...\"); private stopWithoutLogic = () =&gt; console.log(\"電梯停止了...\");&#125;(() =&gt;&#123; const lift: ILift = new Lift(); lift.open(); lift.close(); lift.run(); lift.stop();&#125;)()電梯門開啟...電梯門關閉...電梯上下運行...電梯停止了... 思考問題實現類別Lift邏輯很饒舌，充斥著很多switch或是if-else。難以閱讀維護。擴展性很差，當狀態越多(通電狀態、斷電狀態)，都要增加條件。非常規狀態難以實踐，故障、檢修等狀態。 會違反單一職責原則。 轉換思考角度剛剛都是以電梯的方法跟方法執行的條件去分析。現在換個角度思考，電梯在具有這些狀態時能夠做什麼事情， 也就是說電梯處於某個具體狀態時，思考這個狀態是由什麼動作觸發而產生的，以及在這狀態下電梯還能做什麼事情? 停止狀態怎來的? 當然是因為執行了stop()停止狀態下，還能做什麼? 運行? 開門?所以只要實現電梯在一個狀態下的兩個任務模型即可 : 這個狀態如何產生的這個狀態下還能做什麼(怎過度狀態) Version 2 : 抽象與撥離Context 12345678910111213141516import &#123; LiftState &#125; from './state';export class Context &#123; private liftState?: LiftState; constructor() &#123; this.liftState = undefined; &#125; public getLiftState = () =&gt; this.liftState!; public setLiftState = (liftState: LiftState) =&gt; &#123; this.liftState = liftState; this.liftState.setContext(this); &#125; public open = () =&gt; this.liftState!.open(); public close = () =&gt; this.liftState!.close(); public run = () =&gt; this.liftState!.run(); public stop = () =&gt; this.liftState!.stop();&#125; LiftState 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import &#123; Context &#125; from \"./Context\";let context = new Context();export abstract class LiftState &#123; public setContext = (_context: Context) =&gt; context = _context; public abstract open(): void; public abstract close(): void; public abstract run(): void; public abstract stop(): void;&#125;export class OpenningState extends LiftState &#123; constructor() &#123; super(); &#125; public close = () =&gt; &#123; context.setLiftState(new ClosingState()); context.getLiftState().close(); &#125; public open = () =&gt; console.log(\"電梯門開啟...\"); public run = () =&gt; &#123;&#125;; public stop = () =&gt; &#123;&#125;;&#125;export class ClosingState extends LiftState &#123; constructor() &#123; super(); &#125; public close = () =&gt; console.log(\"電梯門關閉...\"); public open = () =&gt; &#123; context.setLiftState(new OpenningState()); context.getLiftState().open(); &#125; public run = () =&gt; &#123; context.setLiftState(new RunningState()); context.getLiftState().run(); &#125;; public stop = () =&gt; &#123; context.setLiftState(new StoppingState()); context.getLiftState().stop(); &#125;;&#125;export class RunningState extends LiftState &#123; constructor() &#123; super(); &#125; public close = () =&gt; &#123;&#125;; public open = () =&gt; &#123;&#125;; public run = () =&gt; console.log(\"電梯上下運行...\"); public stop = () =&gt; &#123; context.setLiftState(new StoppingState()); context.getLiftState().stop(); &#125;;&#125;export class StoppingState extends LiftState &#123; constructor() &#123; super(); &#125; public close = () =&gt; &#123;&#125;; public open = () =&gt; &#123; context.setLiftState(new OpenningState()); context.getLiftState().open(); &#125;; public run = () =&gt; &#123; context.setLiftState(new RunningState()); context.getLiftState().run(); &#125; public stop = () =&gt; console.log(\"電梯停止了...\");&#125;(() =&gt;&#123; const context = new Context(); context.setLiftState(new ClosingState()); context.open(); context.close(); context.run(); context.stop();&#125;)()電梯門開啟...電梯門關閉...電梯上下運行...電梯停止了... 回顧 Client場景變簡單了，只要給初始狀態，調用相關方法，完全不用考慮狀態的切換變更。也就是說只看到行為的發生改變，並不用知道是狀態變化引起的改變。 各場景的程式碼縮短了，因為切成各個子類別; 也取消了switch…case的判斷。 符合”開閉原則”, 因為要增加狀態，除了要增加子類別，也要修改原有的類別，只是要在原有的方法上增加新的方法，而不更動原有的。 符合單一職責, 現在各狀態式單獨的類別，只有與這狀態相關的因素能做修改。 狀態模式的定義Allow an object to alter its behavior when its internal state changes. The object will appear to change its class. (當一個對象內在狀態改變時，允許其改變行為，這個對象則看起來像是改變了類別) State - 抽象狀態 interface或abstact class, 負責對象狀態定義，並且封裝環境腳色用來實現狀態切換。 ConcreateState - 具體狀態 自己的狀態行為管理，跟趨向狀態處理; 當下狀態要做的事情，以及過渡到其他狀態。 Context - 環境腳色 定義client要得介面，並且負責具體狀態的切換。 Pros : 結構清晰 : 避免過多switch…case或if…else，增加可維護性 遵循設計原則 : 實現”開閉原則” 和 “單一職責” 封裝性良好 : 狀態變換放置到內部實現，外部不用知道 Cons : 子類別太多 = 類別膨脹 使用場景 行為隨著狀態改變而改變 條件、分之判斷語句的替代 組合技建造者+狀態模式 : 將狀態間切換的一定順序用建造者做構建。","categories":[],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://tedmax100.github.io/tags/Design-Pattern/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://tedmax100.github.io/tags/TypeScript/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://tedmax100.github.io/tags/JavaScript/"}]},{"title":"Docker入門_01","slug":"Docker入門-01","date":"2017-11-12T16:01:59.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2017/11/13/Docker入門-01/","link":"","permalink":"https://tedmax100.github.io/2017/11/13/Docker入門-01/","excerpt":"What is Docker?","text":"What is Docker? Docker從廣義上是個服務容器(Application Container)，基本上跟一般系統中執行的Process並無不同，特別的是它負責操作鏡像檔案(images)。所以Docker+構建昇成出來的image file == Docker Container。 Windows上的Docker有何不同Docker在Windows上安裝好時，會自動安裝一個Docker專用的Linux虛擬機，透過Hyper-V來管理。透過這個Linux虛擬基在背後提供和運行Container的方式來達成使用。 也正因為如此，所以目前找到的打包好的image file都是以Linux為主的原因了。所以基本上，Docker上的容器都是跑在Linux內核中，只是單獨包成一隻應用程式檔，掛載進去Docker的進程內。 Docker images鏡像 ，就類似於VM中的快照，但容量卻小上許多，Docker透過ID或是容易識別的別名+tag來抓到唯一的目標鏡像檔。ImagesID是一個64bit長度的字串，但通常只要使用前4碼即可。 Ubuntu上安裝DockerLink","categories":[{"name":"Docker","slug":"Docker","permalink":"https://tedmax100.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://tedmax100.github.io/tags/Docker/"}]},{"title":"PixiJS-簡介","slug":"PixiJS-簡介","date":"2017-06-05T15:59:50.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2017/06/05/PixiJS-簡介/","link":"","permalink":"https://tedmax100.github.io/2017/06/05/PixiJS-簡介/","excerpt":"PixiJS - PixiJs 簡介Pixi.js is a rendering library that will allow you to create rich, interactive graphics, cross platform applications, and games without having to dive into the WebGL API or deal with browser and device compatibility.","text":"PixiJS - PixiJs 簡介Pixi.js is a rendering library that will allow you to create rich, interactive graphics, cross platform applications, and games without having to dive into the WebGL API or deal with browser and device compatibility. PixiJS官網上的說明這是一個套件，能讓玩家創造出豐富的、互動的、跨平台的應用/遊戲。開發者不必深入理解WebGL的API或是處理瀏覽器的相容性問題的一個容易上手的套件。 利用texture(紋理)來準備遊戲圖形，使用Proton粒子引擎做到particle effect(粒子效果)，以及如何將Pixi整合到自己做的遊戲引擎中。當然它不只適用於遊戲，也能用來創建任何交互式的應用程式。 安裝小弟安裝學習的版本是V4.0.0直接使用官網提供的CDN載點Pixi Link 1234567891011121314&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt; &lt;script src=\"pixi.min.js\"&gt;&lt;/script&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; var type = \"WebGL\" if(!PIXI.utils.isWebGLSupported())&#123; type = \"canvas\" &#125; PIXI.utils.sayHello(type) &lt;/script&gt;&lt;/body&gt;","categories":[],"tags":[{"name":"JavaSCript","slug":"JavaSCript","permalink":"https://tedmax100.github.io/tags/JavaSCript/"},{"name":"Pixi","slug":"Pixi","permalink":"https://tedmax100.github.io/tags/Pixi/"}]},{"title":"JS30 - JavaScript Drum Kit","slug":"JS30-JavaScript-Drum-Kit","date":"2017-06-04T15:49:37.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2017/06/04/JS30-JavaScript-Drum-Kit/","link":"","permalink":"https://tedmax100.github.io/2017/06/04/JS30-JavaScript-Drum-Kit/","excerpt":"","text":"#核心需求 根據鍵盤的KeyCode，來撥放對應的聲音 改變觸發的物件樣式 實現思維 在元素上綁定keydown event 對應事件的處理流程 給每個div元素綁定transitioned event 綁定事件 獲取所有classname為key的元素 去除樣式的事件處理流程 123windows.addEventListener('keydown', function(e)&#123; console.log(e);&#125;);","categories":[],"tags":[{"name":"JavaSCript","slug":"JavaSCript","permalink":"https://tedmax100.github.io/tags/JavaSCript/"},{"name":"JS30Day","slug":"JS30Day","permalink":"https://tedmax100.github.io/tags/JS30Day/"}]}]}