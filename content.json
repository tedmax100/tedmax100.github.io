{"meta":{"title":"雷N's Blog","subtitle":"時間花在哪, 成就就在那. 充足的努力, 才能看起來毫不費力","description":"後端開發、軟體工程、運維佈署","author":"Nathan雷N","url":"https://tedmax100.github.io","root":"/"},"pages":[{"title":"about","date":"2019-07-14T07:18:51.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"about/index.html","permalink":"https://tedmax100.github.io/about/index.html","excerpt":"","text":"汪洋中的一位迷途攻城屍 個人學習筆記及讀書心得"},{"title":"categories","date":"2019-07-14T16:26:19.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"categories/index.html","permalink":"https://tedmax100.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Container 3兄弟-Heap","slug":"3兄弟-Heap","date":"2020-12-20T14:16:31.000Z","updated":"2020-12-20T14:17:15.614Z","comments":true,"path":"2020/12/20/3兄弟-Heap/","link":"","permalink":"https://tedmax100.github.io/2020/12/20/3兄弟-Heap/","excerpt":"","text":"HeapHeap(堆積)其實是一個Complete Binary Tree(完全二元樹).Go的Heap特性是 各個節點都自己是其子樹的根, 且值是最小的.同個根節點的左子樹的值會小於右子樹.所以根節點的值是最小的, 位於索引0的位置.也有另一種是最大的(max heap), 只是Go這裡是最小的(min heap).定義 : n個元素 k1, k2,…ki…kn, 並且若且唯若滿足下列關係時稱為heapki &lt;= k2i, ki &lt;= k(2i+1) 或者 ki &gt;= k2i, ki &gt;= k(2i+1), i = 1,2,3…,n/2又因為最小(或最大)的值, 取出該值都只要O(1)的時間. 通常該結構是用來實現(priority queue)優先隊列的方法之一. 能對任務工作作優先等級的排序用.底層還是以陣列形式表示 Dijkstra’s algorithm也是能用Heap做實現. Heap Interface這裡會提到接口interface, 之後會更詳細的介紹interface的部份 只要實現這些接口, 就可以操作heap提供的各種方法了.可以看得出來heap接口繼承了sort.Interface, 而sort.Interface內又有三個方法需要實現.繼承後面會有更詳細的部份介紹.總之就是要實現這5個方法就行了. 12345678910111213141516type Interface interface &#123; sort.Interface Push(x interface&#123;&#125;) // add x as element Len() Pop() interface&#123;&#125; // remove and return element Len() - 1.&#125;// sort.Interfacetype Interface interface &#123; // Len is the number of elements in the collection. Len() int // Less reports whether the element with // index i should sort before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int)&#125; 初始化Heap1heap.Init(customizeHeap) Heap內建的操作方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 一個滿足以上全部接口的堆積結構, 在操作前都要先執行Init()做初始化排序. // 複雜度O(log n), n = Len(), 因為是二元搜尋樹的查找func Init(h Interface) &#123; // heapify n := h.Len() for i := n/2 - 1; i &gt;= 0; i-- &#123; down(h, i, n) &#125;&#125;// 對Array增加一個新元素在最後面// 並透過up()重新排序把元素作上升, 來滿足min heap的要求.// 複雜度O(log n), n = Len()func Push(h Interface, x interface&#123;&#125;) &#123; h.Push(x) // 會呼叫我們自定義好的Push() up(h, h.Len()-1)&#125;// 刪除並且返回Len()-1位置的元素(Array最後一個的元素)// 等同於對Array做了取[:n-1]的動作, 等於是把第一個元素跟最後一個做了互換後, 透過down(), 把新的根節點下沉到適合的位置, 用來滿足min heap的要求.// Pop()跟Remove(h, 0 )是一樣的func Pop(h Interface) interface&#123;&#125; &#123; n := h.Len() - 1 h.Swap(0, n) down(h, 0, n) return h.Pop() // 會呼叫我們自定義好的Pop()&#125;// 如果heap中有元素的值被修改, 則透過Fix()重新排序, down() &amp; up()也會被呼叫.// 複雜度O(log n), n = Len()func Fix(h Interface, i int) &#123; if !down(h, i, h.Len()) &#123; up(h, i) &#125;&#125;// 刪除heap中第i個元素, 並且重新排序// 複雜度O(log n), n = Len()func Remove(h Interface, i int) interface&#123;&#125; &#123; n := h.Len() - 1 if n != i &#123; h.Swap(i, n) if !down(h, i, n) &#123; up(h, i) &#125; &#125; return h.Pop()&#125;// 把元素下沉到對應的子樹合適的位置上func down(h Interface, i0, n int) bool &#123;...&#125;// 把元素上升到對應的子樹合適的位置上func up(h Interface, j int) &#123;...&#125; 實現自定義的int Heap首先定義一個類型或是結構, 並且實現那5個方法.取官網的範例來說明 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package mainimport ( \"container/heap\" \"fmt\")// An IntHeap is a min-heap of ints.type IntHeap []int// 返回元素個數func (h IntHeap) Len() int &#123; return len(h) &#125;// 比較大小, 只要索引i的元素&lt;索引j的元素, 就會返回true, 否則返回false, 因為是Min Heap, 所以都在比小// Max Heap就是反過來比大, 但這方法名還是叫Less不能改就是了XDfunc (h IntHeap) Less(i, j int) bool &#123; return h[i] &lt; h[j] &#125;// 交換h[i]跟h[j]的元素, Golang對swap的寫法很簡單, 不必在創建temp變數在那裡賦值.func (h IntHeap) Swap(i, j int) &#123; h[i], h[j] = h[j], h[i] &#125;// 新增元素func (h *IntHeap) Push(x interface&#123;&#125;) &#123; *h = append(*h, x.(int))&#125;// Pop出最後一個元素func (h *IntHeap) Pop() interface&#123;&#125; &#123; old := *h n := len(old) // 把最後一個賦值給x x := old[n-1] // 建立一組新的slice , 取原有的slice 開始到n-1個元素, 並賦值 *h = old[0 : n-1] return x&#125;func main() &#123; h := &amp;IntHeap&#123;2, 1, 5&#125; heap.Init(h) heap.Push(h, 3) heap.Push(h, 4) heap.Push(h, 9) fmt.Printf(\"minimum: %d\\n\", (*h)[0]) // first : 1 for h.Len() &gt; 0 &#123; fmt.Printf(\"%d \", heap.Pop(h)) &#125; // 2 3 4 5 9 // 把上面走訪heap整段註解掉 // 修改第1個元素的值 // 會把原本h[1]的元素, 移動到適當的位置去 (*h)[1] = 6 // 讓heap重新排序 heap.Fix(h, 1) for h.Len() &gt; 0 &#123; fmt.Printf(\"%d \", heap.Pop(h)) &#125; // 2 4 5 6 9&#125; 實現Priority Queue官網範例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package mainimport ( \"container/heap\" \"fmt\")// 元素結構type Item struct &#123; value string // 元素的值 priority int // 元素的優先權值 index int // 紀錄索引值&#125;// PriorityQueue, 本質上是一個*item的Arraytype PriorityQueue []*Item// sort.Interface的實現// 返回元素個數func (pq PriorityQueue) Len() int &#123; return len(pq) &#125;// 因為希望Pop出來的是priority值最大的元素, 所以這裡的邏輯是反著寫// 其實這就是個Max Heap, 根節點的priority的值大於其他.func (pq PriorityQueue) Less(i, j int) bool &#123; return pq[i].priority &gt; pq[j].priority&#125;// 交換pq[i]跟pq[j]的元素, 這裡還要互換兩個元素彼此的indexfunc (pq PriorityQueue) Swap(i, j int) &#123; pq[i], pq[j] = pq[j], pq[i] pq[i].index = i pq[j].index = j&#125;// heap.Interface的實現// 新增元素在Array最後func (pq *PriorityQueue) Push(x interface&#123;&#125;) &#123; n := len(*pq) item := x.(*Item) // 這裡用類型斷言, 日後會補充 item.index = n // 設定新增進來元素的index *pq = append(*pq, item)&#125;// Pop出Array最後1個元素func (pq *PriorityQueue) Pop() interface&#123;&#125; &#123; old := *pq n := len(old) item := old[n-1] old[n-1] = nil // 把元素設置為沒有指向任何東西, 等GC來回收原來指向所配置出來的空間 item.index = -1 // 保險起見, 把pop出去的元素index設置成-1 *pq = old[0 : n-1] // 從old slice來取 0 ~ n-1的元素來形成新的slice, 並賦值給*pq return item&#125;// 更新元素的值和優先權, 並且重新排序func (pq *PriorityQueue) update(item *Item, value string, priority int) &#123; item.value = value item.priority = priority heap.Fix(pq, item.index)&#125;func main() &#123; items := map[string]int&#123; \"banana\": 3, \"apple\": 2, \"pear\": 4, &#125; pq := make(PriorityQueue, len(items)) i := 0 for value, priority := range items &#123; pq[i] = &amp;Item&#123; value: value, priority: priority, index: i, // 依照清單個數, 依序給index &#125; i++ &#125; // 初始化Heap heap.Init(&amp;pq) // 新增一個新元素 item := &amp;Item&#123; value: \"orange\", priority: 1, &#125; heap.Push(&amp;pq, item) // 修改該元素 pq.update(item, item.value, 5) // 依序Pop出來 for pq.Len() &gt; 0 &#123; item := heap.Pop(&amp;pq).(*Item) fmt.Printf(\"%.2d:%s \", item.priority, item.value) &#125;&#125;// 05:orange 04:pear 03:banana 02:apple 初始化完成時的heap跟Array 新增orange, 並修改優先權後, 明顯orange被上升到合適的位置了 依序Pop出來 我發現Array位置沒改對…原諒我, 懶得修圖了 - .-但二元樹是對的!’LeetCode 23 可以嘗試用heap來實現小弟我日後補上 鐵人賽連結","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"},{"name":"iT邦鐵人賽11Th","slug":"iT邦鐵人賽11Th","permalink":"https://tedmax100.github.io/tags/iT邦鐵人賽11Th/"}]},{"title":"Container 3兄弟-List","slug":"3兄弟-List","date":"2020-12-20T13:26:42.000Z","updated":"2020-12-20T14:17:18.050Z","comments":true,"path":"2020/12/20/3兄弟-List/","link":"","permalink":"https://tedmax100.github.io/2020/12/20/3兄弟-List/","excerpt":"Go有提供幾種 List、Heap、Ring來依序玩看看","text":"Go有提供幾種 List、Heap、Ring來依序玩看看 List 因為上篇講Array &amp; Slice, 這兩種底層都需要連續的記憶體空間來配置.List則是可以非連續空間的容器, 也可以支援快速增刪元素.List由多個節點所組成的, 節點之間透過一些變數紀錄彼此的關係.且List並沒有限制每個節點的元素類型. 所以可以是任意類型.但後續轉換時就要注意. List有多種實現方式 : Single Linked List Double Linked List : Go內建這個類型, 相較於single linked list, 在增刪元素時不需要移動元素, 可以原地增刪. 還能夠雙向走訪. 這是List 的source code, 可以看到有next, prev這兩個ptr, 指向前後各一個元素的位置.呼叫Init()時, prev, next都指向root節點. 123456789101112131415161718192021222324252627282930313233// Element is an element of a linked list.type Element struct &#123; // Next and previous pointers in the doubly-linked list of elements. // To simplify the implementation, internally a list l is implemented // as a ring, such that &amp;l.root is both the next element of the last // list element (l.Back()) and the previous element of the first list // element (l.Front()). next, prev *Element // The list to which this element belongs. list *List // The value stored with this element. Value interface&#123;&#125;&#125;// List represents a doubly linked list.// The zero value for List is an empty list ready to use.type List struct &#123; root Element // sentinel list element, only &amp;root, root.prev, and root.next are used len int // current list length excluding (this) sentinel element&#125;// Init initializes or clears list l.func (l *List) Init() *List &#123; l.root.next = &amp;l.root l.root.prev = &amp;l.root l.len = 0 return l&#125;// New returns an initialized list.func New() *List &#123; return new(List).Init() &#125; 初始化List12345// 透過New(), New會去呼叫Init()變數名稱 := list.New()// 透過聲明來初始化var 變數名稱 list.List 插入新元素PushFront、PushBack 可以在List的最前面或最後面增加元素.PushFront 是對目前List的root節點前面在多一個元素; 看原始碼會發現呼叫了insertValue(), 第二個參數是root, 然後又呼叫了insert(&amp;Element, root), 第一個參數是新增的元素, 第二個參數是該新增元素要插入在誰的後面, 這裡是安插在root後面.PushBack 是對目前List的尾巴節點後面多一個元素. InsertBefore、InsertAfter則是在被標記的元素前或後增加元素. 原始碼 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// insert inserts e after at, increments l.len, and returns e.func (l *List) insert(e, at *Element) *Element &#123; n := at.next at.next = e e.prev = at e.next = n n.prev = e e.list = l l.len++ return e&#125;// insertValue is a convenience wrapper for insert(&amp;Element&#123;Value: v&#125;, at).func (l *List) insertValue(v interface&#123;&#125;, at *Element) *Element &#123; return l.insert(&amp;Element&#123;Value: v&#125;, at)&#125;// PushFront inserts a new element e with value v at the front of list l and returns e.func (l *List) PushFront(v interface&#123;&#125;) *Element &#123; l.lazyInit() return l.insertValue(v, &amp;l.root)&#125;// PushBack inserts a new element e with value v at the back of list l and returns e.func (l *List) PushBack(v interface&#123;&#125;) *Element &#123; l.lazyInit() return l.insertValue(v, l.root.prev)&#125;// InsertBefore inserts a new element e with value v immediately before mark and returns e.// If mark is not an element of l, the list is not modified.// The mark must not be nil.func (l *List) InsertBefore(v interface&#123;&#125;, mark *Element) *Element &#123; if mark.list != l &#123; return nil &#125; // see comment in List.Remove about initialization of l return l.insertValue(v, mark.prev)&#125;// InsertAfter inserts a new element e with value v immediately after mark and returns e.// If mark is not an element of l, the list is not modified.// The mark must not be nil.func (l *List) InsertAfter(v interface&#123;&#125;, mark *Element) *Element &#123; if mark.list != l &#123; return nil &#125; // see comment in List.Remove about initialization of l return l.insertValue(v, mark)&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package mainimport ( \"container/list\" \"fmt\")func traverse(list *list.List) &#123; // 走訪list fmt.Printf(\"root -&gt; \") for el := list.Front(); el != nil; el = el.Next() &#123; fmt.Printf(\"%v -&gt; \", el.Value) &#125;&#125;func main() &#123; // 宣告一個List, 並且初始化 list := list.New() // 最後面新增20 list.PushBack(20) // 最前面新增10 list.PushFront(\"10\") // 最後面新增25, 並且保存該新增元素到變數上 element := list.PushBack(25) // 在該元素後面新增26 list.InsertAfter(\"26\", element) // 在該元素前面新增26 list.InsertBefore(24, element) traverse(list) fmt.Println(\"\\n---------------------\") // element 換到第一個元素的後面 list.MoveAfter(element, list.Front()) traverse(list) fmt.Println(\"\\n---------------------\") // element 換到第一個元素的前面 list.MoveBefore(element, list.Front()) traverse(list) fmt.Println(\"\\n---------------------\") // element 換到最後面 list.MoveToBack(element) traverse(list) fmt.Println(\"\\n---------------------\") // element 換到最前面 list.MoveToFront(element) traverse(list) fmt.Println(\"\\n---------------------\") // 移除該元素 list.Remove(element) traverse(list)&#125;/*root -&gt; 10 -&gt; 20 -&gt; 24 -&gt; 25 -&gt; 26 -&gt; ---------------------root -&gt; 10 -&gt; 25 -&gt; 20 -&gt; 24 -&gt; 26 -&gt; ---------------------root -&gt; 25 -&gt; 10 -&gt; 20 -&gt; 24 -&gt; 26 -&gt; ---------------------root -&gt; 10 -&gt; 20 -&gt; 24 -&gt; 26 -&gt; 25 -&gt; ---------------------root -&gt; 25 -&gt; 10 -&gt; 20 -&gt; 24 -&gt; 26 -&gt; ---------------------root -&gt; 10 -&gt; 20 -&gt; 24 -&gt; 26 -&gt; */ 走訪List走訪List需要配合Front()取得第一個元素, 開始往下走訪.每次就呼叫目前元素的Next(), 只要元素不是nil 就能繼續往下走.也能逆向往前走, 改用Prev()就可. 取得List長度1list.Len() List vs Slice比較新增元素、插入元素、走訪的速度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package mainimport ( \"container/list\" \"fmt\" \"time\")func main() &#123; t := time.Now() sli := make([]int, 10) for i := 0; i &lt; 1*100000*1000; i++ &#123; sli = append(sli, 1) &#125; fmt.Println(\"Slice 新增元素耗費：\" + time.Now().Sub(t).String()) // 比较走訪 t = time.Now() for _ = range sli &#123; &#125; fmt.Println(\"走訪Slice耗費:\" + time.Now().Sub(t).String()) // 比較插入元素 t = time.Now() slif := sli[:100000*500] slib := sli[100000*500:] slif = append(slif, 10) slif = append(slif, slib...) fmt.Println(\"Slice 的插入元素耗費 : \" + time.Now().Sub(t).String()) // 比較刪除元素 t = time.Now() index := 100000 _ = append(sli[:index], sli[index+1:]...) fmt.Println(\"Slice 的刪除元素耗費 : \" + time.Now().Sub(t).String()) sli = make([]int, 10) // ---------Slice end, start list fmt.Println(\"------------------------------\") t = time.Now() l := list.New() for i := 0; i &lt; 1*100000*1000; i++ &#123; l.PushBack(1) &#125; fmt.Println(\"List 新增元素耗費: \" + time.Now().Sub(t).String()) t = time.Now() for e := l.Front(); e != nil; e = e.Next() &#123; &#125; fmt.Println(\"走訪List耗費:\" + time.Now().Sub(t).String()) var em *list.Element i := 0 // 找到1/3處的元素 for e := l.Front(); e != nil; e = e.Next() &#123; i++ if i == l.Len()/3 &#123; em = e break &#125; &#125; // 因為是記算插入元素的速度, 所以忽略查找的時間 t = time.Now() l.InsertAfter(2, em) fmt.Println(\"List 的插入元素耗費 : \" + time.Now().Sub(t).String()) // 比較刪除元素 t = time.Now() l.Remove(em) fmt.Println(\"List 的刪除元素耗費:\" + time.Now().Sub(t).String())&#125;/*Slice 新增元素耗費：1.749752738s走訪Slice耗費:35.548381msSlice 的插入元素耗費 : 46.402953msSlice 的刪除元素耗費 : 92.097862ms------------------------------List 新增元素耗費: 17.721431965s走訪List耗費:364.763942msList 的插入元素耗費 : 2.17µsList 的刪除元素耗費:73ns*/ 結論對於資料量很多的情境下,如果很頻繁的插入或是刪除, List的成本低到幾乎可以不計算.但如果頻繁的新增或是走訪查找, Slice的效能高過List許多. 首圖是參考該文章的, 該文有講單鏈, 雙鏈跟環鏈, 有機會再分享 鐵人賽連結","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"},{"name":"iT邦鐵人賽11Th","slug":"iT邦鐵人賽11Th","permalink":"https://tedmax100.github.io/tags/iT邦鐵人賽11Th/"}]},{"title":"Array & Slice","slug":"Array","date":"2020-12-20T13:09:04.000Z","updated":"2020-12-20T13:09:57.269Z","comments":true,"path":"2020/12/20/Array/","link":"","permalink":"https://tedmax100.github.io/2020/12/20/Array/","excerpt":"Array","text":"Array 123// n 陣列元素數量// type 陣列元素類型var array變數 [n]type 長度是固定的, 聲明後無法被改變 長度是陣列類型的一部份, 所以兩個長度不同但元素類型相同的陣列, 是不同的類型, ex: [2]int 跟[3]int是不同的類型.初始化方式1234567891011121314a := [3]int&#123;1,2,3&#125; b := [...]int&#123;1,2,3,4&#125; //透過初始化給的元素數量來給定長度c := [3]int&#123;2:100, 1:200&#125; //透過索引初始化元素, 沒被初始化的就是該類型的預設值d := [...]struct &#123; name: string age uint8&#125; &#123; &#123; \"user1\", 5 &#125;, &#123; \"user2\", 18 &#125;,&#125;// 多維度陣列aa := [2][3]int&#123;&#123;1,2,3&#125;, &#123;4,5,6&#125;&#125;bb := [...][3]int&#123;&#123;1,2,3&#125;, &#123;4,5,6&#125;&#125; //只有第一個維度能用... 操作方法12345678910111213// 取值data := aa[1] //透過索引取用//賦值aa[1] = 2 //透過索引賦值// 走訪陣列每個元素for k, v := range d &#123; fmt.Println(k, v)&#125;/*0 &#123;user1, 5&#125;1 &#123;user2, 18&#125;*/ Array的傳遞123456789101112131415161718192021222324package mainimport \"fmt\"func main() &#123; arrA := [2]int&#123;&#125; var arrB [2]int arrB = arrA fmt.Printf(\"arrA : %p , %v\\n\", &amp;arrA, arrA) fmt.Printf(\"arrB : %p , %v\\n\", &amp;arrB, arrB) arr(arrA)&#125;func arr(x [2]int) &#123; fmt.Printf(\"pass Array : %p , %v\\n\", &amp;x, x)&#125;/*arrA : 0xc000016100 , [0 0]arrB : 0xc000016110 , [0 0]pass Array : 0xc000016150 , [0 0]*/ 3個都是[2]int的記憶體位置都不同, 這很明顯Go在Array的賦值和傳參數都是value type,靠複製整個Array的, 因此如果是1億數量的int64陣列, 一個元素佔64bits, 那這陣列就要800MB, 這樣copy 瞬間會需要1.6GB的記憶體空間. 所以也能改成方法參數傳指針, 來避掉這問題. 123456789101112131415161718192021222324252627package mainimport ( \"fmt\" \"time\")func main() &#123; arrA := [2]int&#123;1, 2&#125; fmt.Printf(\"arrA : %p , %v\\n\", &amp;arrA, arrA) arr(&amp;arrA) arrA[0]++ fmt.Printf(\"arrA : %p , %v\\n\", &amp;arrA, arrA)&#125;func arr(x *[2]int) &#123; fmt.Printf(\"pass Array : %p , %v\\n\", x, *x) time.Sleep(time.Second) (*x)[0]++&#125;/*arrA : 0xc00008e010 , [1 2]pass Array : 0xc00008e010 , [1 2]arrA : 0xc00008e010 , [3 2]*/ 會看到都是操作同一個位置的陣列了.但會引發另一個問題, 原來陣列的指針指向改變了, 函數內的也會更著變動. 這兩個問題, Slice都能有效的處理解決. Slice 動態分配大小的Array, 可以不必事先指定大小.雖然是這樣講, 但他其實是一個結構, 透過ptr指向引用的底層Array. 123456789// type 元素類型// array 指向array的指針// len 目前slice中有多少元素數量// cap 可容納多少個元素type slice struct &#123; array unsafe.Pointer len int cap int&#125; 初始化方式 從現有的array或是slice生出新的slice 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package mainimport ( \"fmt\" \"reflect\")func main() &#123; var arr = [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125; // 取開始到中間的所有元素 slice0 := arr[:5] fmt.Println(slice0) // 取中間到尾部的所有元素 slice1 := arr[5:] fmt.Println(slice1) // 取中間區間的所有元素 slice2 := arr[2:7] fmt.Println(slice2) // 取所有元素, 表示原有的slice slice3 := arr[:] fmt.Println(slice3) // 重置slice, 清空擁有的元素 slice4 := arr[0:0] fmt.Println(slice4) fmt.Println(\"-------------------\") slice := arr[1:3] fmt.Println(reflect.TypeOf(arr)) fmt.Println(reflect.TypeOf(slice)) fmt.Println(len(slice), cap(slice)) fmt.Println(arr) fmt.Println(slice) fmt.Println(\"-------------------\") slice[0] = 0 fmt.Println(arr) fmt.Println(slice)&#125;/*[0 1 2 3 4][5 6 7 8 9][2 3 4 5 6][0 1 2 3 4 5 6 7 8 9][]-------------------[10]int[]int2 9[0 1 2 3 4 5 6 7 8 9][1 2]-------------------[0 0 2 3 4 5 6 7 8 9][0 2]*/ 宣告slice 1234567891011121314151617181920212223242526package mainimport ( \"fmt\")func main() &#123; // 宣告字串slice var numList []int // 宣告一個空slice var numEmptyList = []int&#123;&#125; fmt.Println(numList, numEmptyList) fmt.Println(len(numList), len(numEmptyList)) fmt.Println(numList == nil) fmt.Println(numEmptyList == nil)&#125;/*[] []0 0truefalse*/ 這裡第18行是true, 是因為numList只是宣告, 還沒真正實例化第19行則是有被實例化被分配到記憶體內了.因為slice還是個struct動態結構, 所以只能和nil作比較. 使用make()1234// type 元素類型// size 為slice先分配多少個元素的預設值進去// cap 預分配的數量, 只是能提前分配空間, 降低之後多次分配空間的效能問題.make([]type, size, cap) 透過make()生成的slice, 一定會實例化配置記憶體,但透過從其他slice指定開始和結束位置的slice, 只是把新的slice指向舊的slice已經分配好的空間, 只是新的slice註明開始跟結束位子而已, 此時新的slice並不會真的去跟記憶體要一個新的連續空間來宣告新array. 123456789101112131415161718192021package mainimport ( \"fmt\")func main() &#123; // 宣告int slice, 壹開始2個都先分配2元素進去 a := make([]int, 2) // 會發現b, 它的預先配置在記憶體的位置大小, 其實已經是能塞10個元素的配置了 b := make([]int, 2, 10) fmt.Println(a, b) fmt.Println(len(a), len(b)) fmt.Println(cap(a), cap(b))&#125;/*[0 0] [0 0]2 22 10*/ 透過append()添加元素append()能為slice動態添加數個元素.當slice不能容納足夠多的元素時, slice就會進行擴容.“擴容”往往發生在append()被調用時.擴容時,容量的擴展規律按照容量的2倍在擴容, 例如1、2、4、8. 123456789101112131415161718192021222324252627package mainimport ( \"fmt\")func main() &#123; // 宣告一個len 和cap 都是0的slice numbers := make([]int, 0) for i := 0; i &lt; 10; i++ &#123; numbers = append(numbers, i) fmt.Printf(\"len: %d, cap: %d, ptr: %p\\n\", len(numbers), cap(numbers), numbers) &#125;&#125;/*len: 1, cap: 1, ptr: 0xc000016100len: 2, cap: 2, ptr: 0xc000016130len: 3, cap: 4, ptr: 0xc000018560len: 4, cap: 4, ptr: 0xc000018560len: 5, cap: 8, ptr: 0xc00001a340len: 6, cap: 8, ptr: 0xc00001a340len: 7, cap: 8, ptr: 0xc00001a340len: 8, cap: 8, ptr: 0xc00001a340len: 9, cap: 16, ptr: 0xc00006e080len: 10, cap: 16, ptr: 0xc00006e080*/ 可以很明顯看到, 當原來的cap滿的時候, 會產生擴容現象. 舉個生活例子來說明這len和cap以及擴容.公司發展初期, 資金少, 人員配置也少, 只需要小小的辦公室就能容納所有員工.隨著業務的擴展和收入的增加, 就需要擴編, 但現有辦公室大小是固定的, 無法改變它.所以公司決定！ 換個更大的辦公室, 每次搬家就要把所有人搬遷到新的辦公處.員工就是slice中的元素辦公室就是配置好的記憶體空間, 大小是固定的搬家就是重新配置不論搬家多少次, 公司名稱都是固定的, 表示外部使用這slice的變數名稱是不會修改的,但因為搬家後地址發生變化, 所以slice內部array指向的地址會有所修改. 123456// 添加多個元素numbers = append(numbers, 1, 2, 3) // 透過令一個slice來添加多個元素 nums := []int&#123;4,5,6,7&#125; numbers = append(numbers, nums...) More example12345678910111213141516package mainimport ( \"fmt\")func main() &#123; a := make([]int, 0, 10) b := append(a, 1) _ = append(a, 2) fmt.Println(b[0])&#125;// 2// 因為b.ptr = a.ptr, 且a的cap有10,足夠插入新元素, // 第9行執行完, 會發現a的len還是0// 執行了 第10行後, 當然append a就會把第0個元素的值給修改掉了. 1234567891011121314package mainimport ( \"fmt\")func main() &#123; a := make([]int, 10, 20) b := a[5:] fmt.Println(len(b), cap(b))&#125;// 5 15// 因為b等於是對a作重新slice, 只取a的第5到結束的值. 那就是10-5 = 5, 所以len(b)=5// cap同上, 指針指到的是a.ptr的第5個元素, 20-5= 15 123456789101112131415161718192021222324package mainimport ( \"fmt\")func doAppend(a []int) &#123; b := append(a, 0) fmt.Println(b)&#125;func main() &#123; a := []int&#123;1, 2, 3, 4, 5&#125; doAppend(a[0:2]) fmt.Println(a)&#125;// [1 2 0]// [1 2 0 4 5]// 調用doAppend時, 傳入2個元素, 但這操作卻把外部的a的第3個元素也改掉了// 只要把第14行的程式改成doAppend(a[0:2:2])// [1 2 0]// [1 2 3 4 5]// 結果就會正確了, 因為[0:2:2]最後的2就是指定重新切片後的capacity, 這時候指定是2.// 所以append操作時發現cap &gt;2, 就會重新分配記憶體來存放, 這樣就不會改到原本的了 透過copy()複製slice到令一個sliceGo內建copy()方法, 可以快速的把slice 作copy 12// 回傳有多少個元素被複製過去 func copy(dst, src []Type) int 123456789101112131415161718192021222324252627282930313233package mainimport ( \"fmt\")func main() &#123; numbers := make([]int, 0) for i := 0; i &lt; 10; i++ &#123; numbers = append(numbers, i) &#125; copyA := make([]int, len(numbers)) fmt.Println(\"copy cnt:\", copy(copyA, numbers)) fmt.Println(\"copied data:\", copyA) copyB := make([]int, 3) fmt.Println(\"copy cnt:\", copy(copyB, numbers[2:5])) fmt.Println(\"copied data:\", copyB) copyC := make([]int, 3) fmt.Println(\"copy cnt:\", copy(copyC, numbers)) fmt.Println(\"copied data:\", copyC)&#125;/*copy cnt: 10copied data: [0 1 2 3 4 5 6 7 8 9]copy cnt: 3copied data: [2 3 4]copy cnt: 3copied data: [0 1 2]*/ copyA宣告的容量是來源的既有元素數量, 所以能完整copy來源所有元素. copyB只宣告了3個容量的slice, 之前提過slice可以取開始和結束區間, 這裡用這方式來取值作copy copyC一樣容量只有3, 但要複製來源所有元素時, 卻因為容量不夠, 所以沒法複製全部. 又因為擴容只會發生在append, 因此這例子不會自動擴容, 導致後半段資料全被切掉. 刪除slice中的元素因為slice並沒有提供刪除專用的api.所以只能用本身特性來刪除元素.本質操作上就是, 以被刪除的元素位置為分界點, 將該元素的前後兩個部份作拼接. 12345678910111213141516171819202122package mainimport ( \"fmt\")func main() &#123; numbers := [...]int&#123;1, 2, 3, 4, 5&#125; fmt.Println(numbers) index := 2 fmt.Println(numbers[:index], numbers[index+1:]) deletedNumbers := append(numbers[:index], numbers[index+1:]...) fmt.Println(deletedNumbers)&#125;/*[1 2 3 4 5][1 2] [4 5][1 2 4 5]*/ 因為slice如果頻繁刪除新增裡面的元素的話,是會頻繁的搬動位置, 這點對效能損耗較高.可能就要考慮其他資料結構來實做. 鐵人賽連結","categories":[],"tags":[]},{"title":"第一隻Go程式","slug":"第一隻Go程式","date":"2020-12-20T08:50:06.000Z","updated":"2020-12-20T13:10:15.261Z","comments":true,"path":"2020/12/20/第一隻Go程式/","link":"","permalink":"https://tedmax100.github.io/2020/12/20/第一隻Go程式/","excerpt":"安裝Go跟開發環境Golang下載Install docVsCode","text":"安裝Go跟開發環境Golang下載Install docVsCode Install the GO on Linux123456789# Download filewget https://dl.google.com/go/go1.12.7.linux-amd64.tar.gz# Extract it into /usr/localtar -C /usr/local -xzf go1.12.7.linux-amd64.tar.gz# Add /usr/local/go/bin to the Path environment variableexport PATH=$PATH:/usr/local/go/bin# Check installationgo env 其他名稱會在後面講package時會稍微提到. Upgrade Go123456# Download filewget https://dl.google.com/go/go$VERSION.linux-amd64.tar.gz# Extract it into /usr/localtar -C /usr/local -xzf go$VERSION.linux-amd64.tar.gz# Add /usr/local/go/bin to the Path environment variableexport PATH=$PATH:/usr/local/go/bin Upgrade by shell scriptupdate-golang WorkspacesWorkspacesSetting GoPath在GoPath所顯示的目錄下創建以下資料夾 src : go source file pkg : 編譯產生的文件, .a檔案(一包object file) ; 暫態緩存文件 bin : 編譯後可執行檔案1mkdir -p $GOPATH/src $GOPATH/pkg $GOPATH/bin Hello Go123mkdir -p $GOPATH/src/hellocd $GOPATH/src/hellocode . 以VsCode開啟該目錄 1234567package mainimport \"fmt\"func main() &#123; fmt.Println(\"Hello Go\")&#125; 12345# 編譯產生可執行的二進制檔案, 會被安裝到$GOPATH/bin底下go install hello# 執行$GOPATH/bin/hello&gt; Hello Go Main packageGo每支檔案都會需要宣告這是屬於哪個package的, 相當於C#的namespace概念.主要的會有一個叫做main的package包, 做為這隻可執行程式的入口包.如果該專案沒有main包時, 就沒法被編譯成可執行檔案.所以如果是要做成共享套件, 就可以不必有main包的存在於該專案內. main裡面會有main方法作為程式的執行進入點. 123456789101112// main包宣告package main// 匯入fmt包import ( \"fmt\" ) // main 方法, 作為執行程式的入口 func main() &#123; fmt.Println(\"Hello IThome\") &#125; import用來導入其他的包, 要用雙引號作為字串來使用. 單行匯入 12import \"包A\"import \"包B\" 多行匯入, 宣告順序不影響真正的匯入結果 1234import ( \"包A\" \"包B\") 要是我有一個包在$GOPATH/src/底下的資料夾路徑是這樣的 github.com ithome packageA那我要引入 packageA的話要按照$GOPATH開始計算的路徑, 使用/進行路徑分隔.也因為跟資料夾路徑有關, 所以建議上都是把資料夾名稱跟package名稱取名成一致.123import ( \"github.com/ithome/packageA\") 安裝第三方套件今天想安裝mysql套件, 他的遠端路徑是 github.com/go-sql-driver/mysql依照 /作路徑分隔的話.第一段表示網域名稱第二段表示作者或者是機構名稱第三段則是專案名稱 透過go get指令, 透過這指令下載原始碼並且編譯.由於go get需要GOPATH已經被設置, Go1.8之後GOPATH預設在用戶目錄的go資料夾下. 1go get github.com/go-sql-driver/mysql go get 參數說明: -d 只有下載, 不會安裝 -v verbose, 顯示下載編譯時的log -u 更新既有的依賴包 有了基本包的概念, 就能寫簡單的範例了. 12# 安裝logrus這log套件go get github.com/sirupsen/logrus go/src/packagedemo/mylib/add.go 12345package mylibfunc Add(a, b int) int &#123; return a + b&#125; go/src/packageDemo/main.go 123456789101112package mainimport ( \"fmt\" \"packagedemo/mylib\" // 這裡使用log 這別名來取代logrus這包名 log \"github.com/sirupsen/logrus\")func main() &#123; fmt.Println(mylib.Add(1,2)) log.Info(\"IThome Iron man\")&#125; 執行 1234go run main.go# 輸出 :# 3# INFO[0000] IThome Iron man 鐵人賽連結","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"},{"name":"iT邦鐵人賽11Th","slug":"iT邦鐵人賽11Th","permalink":"https://tedmax100.github.io/tags/iT邦鐵人賽11Th/"}]},{"title":"學Golang的緣由","slug":"學Golang的緣由","date":"2020-12-20T08:17:50.000Z","updated":"2020-12-20T13:10:25.504Z","comments":true,"path":"2020/12/20/學Golang的緣由/","link":"","permalink":"https://tedmax100.github.io/2020/12/20/學Golang的緣由/","excerpt":"學Golang的緣由","text":"學Golang的緣由 這是小弟第一次參加鐵人賽, 來挑戰一下自我.開始學著寫Golang的原因是因為寫了幾年NodeJS跟C#,但Node真的一個專案打包成docker image超臃腫.就嘗試找一個也支援高併發, 性能優, 方便部屬的語言,但希望它的執行檔大小能是超小的, 且各種OS都支援.就選擇Golang這語言了.就下班加減學一點學一點, 至今也看了兩三個月.一些東西紀錄在自己的部落格當作筆記 Go語言特性 Google開發並負責維護的開源專案! 靜態、編譯型, 自帶GC和併發處理的語言, 能編譯出目標平台的可執行檔案, 編譯速度也快. 全平台適用, Arm都能執行 上手容易, 我覺得跟C比較真的頗容易, 但跟JS比我覺得還是差一些 原生支援併發 (goroutine), 透過channel進行通信 關鍵字少, 30個左右吧 用字首大小寫, 判別是否是public / private 沒用到的import 或者是 變數, 都會在編譯時期給予警告 沒有繼承! 適合寫些工具, 像是hugo、fzf、Drone、Docker 適合其他語言大部分的業務, RestAPI, RPC, WebSocket 內含測試框架 不必在煩惱 到底要i++還是++i了, 因為在Go裡沒有++i, 也不能透過i++賦值給其他的變數 從Node到GolangHello WorldNodeJS 1console.log(\"hello world\"); 1&gt; node app.js Golang的對等寫法 12345678package mainimport ( \"fmt\")func main() &#123; fmt.Println(\"hello world\")&#125; 1&gt; go run main.go Array 和 Slice1const names = [\"it\", \"home\"]; 1names := []string &#123; \"it\", \"home\"&#125; 印出後面幾個字的子字串12let game = \"it home iron man\";console.log(game.substr(8, game.length)); 12game := \"it home iron man\"fmt.Println(game[8: ]) 流程控制123456789101112const gender = 'female';switch (gender) &#123; case 'female': console.log(\"you are a girl\"); break; case 'male': console.log(\"your are a boy\"); break; default: console.log(\"wtf\");&#125; 123456789gender := \"female\"switch gender &#123;case \"female\": fmt.Println(\"you are a girl\")case \"male\": fmt.Println(\"your are a boy\")default: fmt.Println(\"wtf\")&#125; 看得出來Go省略了break這關鍵字 LoopJavascript有for loop, while loop, do while loopGo只有for loop 就能模擬上面三個 12345678910111213for i := 0; i &lt; 10; i++ &#123; fmt.Println(i)&#125;// key value pairskvs := map[string]string&#123; \"name\": \"it home\", \"website\": \"https://ithelp.ithome.com.tw\",&#125;for key, value := range kvs &#123; fmt.Println(key, value)&#125; Object123456const Post = &#123; ID: 10213107 Title: \"下班加減學點Golang\", Author: \"Nathan\", Difficulty: \"Beginner\",&#125; 12345678910111213type Post struct &#123; ID int Title string Author string Difficulty string&#125;p := Post &#123; ID: 10213107, Title : \"下班加減學點Golang\", Author: \"Nathan\", Difficulty:\"Beginner\",&#125; Go能透過定義抽象的struct與其屬性, 在實例化也能透過map[string]interface來定義 123456Post := map[string]interface&#123;&#125; &#123; \"ID\": 10213107, \"Title\" : \"下班加減學點Golang\", \"Author\": \"Nathan\", \"Difficulty\":\"Beginner\",&#125; 從上面幾個例子就能看的出來Node跟Go語法結構上很類似,所以學過Node再來學Go好像就沒那麼難了 XD之後會慢慢補充Go的更多東西. 謝謝各位 下班加減學點Golang與Docker-鐵人賽連結 鐵人賽連結","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"},{"name":"iT邦鐵人賽11Th","slug":"iT邦鐵人賽11Th","permalink":"https://tedmax100.github.io/tags/iT邦鐵人賽11Th/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-12-20T07:56:16.169Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2020/12/20/hello-world/","link":"","permalink":"https://tedmax100.github.io/2020/12/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Docker Multi Stage Build","slug":"Docker-Multi-Stage-Build","date":"2019-08-07T16:06:18.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/08/08/Docker-Multi-Stage-Build/","link":"","permalink":"https://tedmax100.github.io/2019/08/08/Docker-Multi-Stage-Build/","excerpt":"Docker 17.05版的發布了Multi-stage build, 讓image肥大的問題有了優雅的解法.","text":"Docker 17.05版的發布了Multi-stage build, 讓image肥大的問題有了優雅的解法. Our Go program :1234567package mainimport \"fmt\"func main() &#123; fmt.Println(\"Hello world!\")&#125; Single-stage buildDockerfile : 12345FROM golang:alpineWORKDIR /appADD . /appRUN cd /app &amp;&amp; go build -o goappENTRYPOINT ./goapp 12# build imagedocker build -t main . 1docker images | grep main 352MB的鏡像大小, 這對於要快速佈署是相當的肥大的.因為Go只需要編譯完成的binary檔, Go image其實只是輔助編譯source code用的.所以透過Multi-Stage build 來減少程式的鏡像檔大小. Multi-Stage Build適用在需要編譯環境的應用上(GO, C, JAVA…)至少都會需要兩個環境的Docker image: 編譯環境鏡像 完整的編譯引擎, 依賴庫等等 運行環境鏡像 編譯好的二進制檔, 用來執行app, 因為沒有編譯環境, 所以體機會小上很多使用multi-stage build, 可以使用單一的dockerfile, 降低維護複雜度. 12345678910# build stageFROM golang:alpine AS build-envADD . /srcRUN cd /src &amp;&amp; go build -o goapp#final stageFROM alpineWORKDIR /appCOPY --from=build-env /src/goapp /app/ENTRYPOINT ./goapp 7.58MB More ExamplesImport “time” main.go123456789101112131415161718package mainimport ( \"fmt\" \"time\")func main() &#123; location, err := time.LoadLocation(\"Europe/Berlin\") if err != nil &#123; fmt.Println(err) &#125; t := time.Now().In(location) fmt.Println(\"Time in Berlin:\", t.Format(\"02.01.2006 15:04\"))&#125; build 完之後執行會出錯 搜尋該錯誤 panic: time: missing Location in call to Time.In搜尋Google後得知, 原來時區位置是從本地文件讀取出的.可以透過安裝tzdata, 在/usr/share/zoneinfo產生各時區的資訊; 或者複製機器上的修改Dockefile 1234567891011121314# build stageFROM golang:alpine AS build-envADD . /srcWORKDIR /srcRUN go build -o goapp#final stageFROM alpineWORKDIR /app# RUN apk add --no-cache tzdata# COPY --from=build-env /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/COPY --from=build-env /usr/share/zoneinfo /usr/share/zoneinfoCOPY --from=build-env /src/goapp /app/ENTRYPOINT ./goapp Go ModuleApp Code + go.mod + go.sum 12345678910111213141516// main.gopackage mainimport ( \"github.com/gin-gonic/gin\")func main() &#123; r := gin.Default() r.GET(\"/ping\", func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; \"message\": \"pong\", &#125;) &#125;) r.Run()&#125; 1. Build Golang App準備官方的Golang image, 並且取別名為builder-env, 方便在之後的階段來使用設定工作目錄,因為我是用go module作套件依賴管理,這裡把路徑設定成跟我們開發環境中一樣, 都是GOPATH下(go/src)的路徑.複製代碼, 並且安裝依賴, 編譯go app 12345FROM golang AS build-envWORKDIR /go/src/github.com/tedmax100/docker-multistage-build-demoCOPY . .ENV GO111MODULE=onRUN CGO_ENABLED=0 GOOS=linux go build -o main 2. Deployment image使用scratch 來作基礎image把編譯好的程式放在裡面;scratch大小 比alpine還小.如果app 需要SSL/TLS來進行訪問, 則需要複製ca-certificates 12345FROM scratchWORKDIR /bin# COPY --from=build-env /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ca-certificates.crtCOPY --from=build-env /go/src/github.com/tedmax100/mahjong .CMD [\"./main\"] 僅產生出15.Mb的image docker build透過–rm 刪除中間過程產生的容器 1docker build --rm -t main . docker run1docker run --rm -d -p 8081:8080 main source code","categories":[{"name":"Docker","slug":"Docker","permalink":"https://tedmax100.github.io/categories/Docker/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"},{"name":"Docker","slug":"Docker","permalink":"https://tedmax100.github.io/tags/Docker/"}]},{"title":"Go-Context","slug":"Go-Context","date":"2019-07-28T14:42:02.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/07/28/Go-Context/","link":"","permalink":"https://tedmax100.github.io/2019/07/28/Go-Context/","excerpt":"","text":"Context允許傳遞”Context”在goroutine之中, 手動/超時來中止routine樹等操作.讓所有基於該context或其衍生的子context都會收到通知, 就能進行結束操作, 最後釋放goroutine. 優雅的解決goroutine啟動之後難以控制的問題. 常見的有timeout、deadline 或 只是停止工作. Context Interface123456789type Context interface &#123; Deadline() (deadline time.Time, ok bool) Done() &lt;-chan struct&#123;&#125; Err() error Value(key interface&#123;&#125;) interface&#123;&#125;&#125; Deadline 獲取設置好的截止時間 ; 第二個bool返回值表示有沒有設置截止時間 Done 返回一個 readonly channel, 如果該channel可以被讀取, 表示parent context 發起了cancel請求, 就能透過Done方法收到訊號後, 作結束操作. Err 返回取消的錯誤原因, 為什麼context被取消 Value 獲得該Context上綁定的值, 是一組KV pair, 該值通常是thread safe的 建立Context1234// 通常使用context.Background()作為樹的root, 該方法只會返回一個空的context// 就是接收請求用// 不可cancel, 沒有設置deadline 和帶任何value的contextctx := context.Background() 123// 如果不需要一個全局的context, 可以用TODO一樣只會返回一個空的context// 就是接收請求用ctx := context.TODO() 建立sub context這四個With方法, 都要接收一個parent context參數.能理解成sub context對parent context的繼承; 反過來說就是基於parent context的衍生.這樣層層下去就能創建一個context tree, 每個節點都能有任意個sub node, 層級也能有任意多個. 123// 透過這樣的方式建立一個可被取消的sub context, 然後當作參數傳給goroutine使用// func WithValue(parent Context, key, val interface&#123;&#125;) Contextctx := context.WithValue(context.Background(), key, \"test\") 12// func WithCancel(parent Context) (ctx Context, cancel CancelFunc)ctx, calcel := context.WithCancel(context.Background()) 1234// 跟WithCancel很像, 只是多個截止時間, 表示時間到了會自動取消context; // 但也能手動cancel// func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(2 * time.Second)) 123// 開始執行後多少時間自動取消context// func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)ctx, cancel := context.WithTimeout(context.Background(), 2 * time.Second) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( \"context\" \"fmt\" \"time\")func main() &#123; ctx, cancel := context.WithCancel(context.Background()) go watch(ctx, \"goroutine1\") go watch(ctx, \"goroutine2\") go watch(ctx, \"goroutine3\") time.Sleep(3 * time.Second) fmt.Println(\"notify stop goroutines by the context\") cancel() time.Sleep(5 * time.Second)&#125;func watch(ctx context.Context, name string) &#123; for &#123; select &#123; case &lt;-ctx.Done(): fmt.Println(name, \"finish the goroutine\") return default: fmt.Println(name, \"goroutine working...\") time.Sleep(1 * time.Second) &#125; &#125;&#125;/*goroutine1 goroutine working...goroutine2 goroutine working...goroutine3 goroutine working...goroutine1 goroutine working...goroutine3 goroutine working...goroutine2 goroutine working...goroutine2 goroutine working...goroutine1 goroutine working...goroutine3 goroutine working...notify stop goroutines by the contextgoroutine2 finish the goroutinegoroutine3 finish the goroutinegoroutine1 finish the goroutine*/","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"}]},{"title":"Odds, Margin, Market","slug":"Odds-Margin-Market","date":"2019-07-18T15:05:15.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/07/18/Odds-Margin-Market/","link":"","permalink":"https://tedmax100.github.io/2019/07/18/Odds-Margin-Market/","excerpt":"","text":"歐賠各大家娛樂網的分析結果 * 歷史紀錄的統計 * 人氣形勢 * 歷史淵源 * 戰意、球隊凝聚力 * 主客場戰績 * 近況 * 過往戰績 * 核心球員受傷、心理、生理等狀況 * 聯賽特性 * 排名 * 突發事件Poisson線上計算根據上面各家自己算出來的主勝、客勝、和局的機率。 再把各機率取倒數, 得到賠率(期望值)主勝賠率: 1/0.5198 = 1.92客勝賠率: 1/0.2339 = 4.2753和局賠率: 1/0.2462 = 4.0617但這跟圖上的會不同，因為同上的會有margin做細微調整. 毛利 margin / 抽水(house edge)其中 100 / 93.57% = 106.861則margin = 6.861% 上面的各選項機率 * 106.861 會得到0.5198 * 106.861 = 55.546%0.2339 * 106.861 = 24.994%0.2462 * 106.861 = 26.309% 主勝賠率 : 1 / 55.546% = 1.80和賠率 : 1 / 24.99% = 4.00客勝賠率 : 1 / 26.309% = 3.80得到跟Bet360一樣的賠率了 用機率表示的原因?因為 賠率(期望值)的倒數應該是和對應的投注成正比的.因為表示發生的機會越高. 玩家勝出的機會也是越高的.應該會有很多人來投注該選項, 對應的投注量也就很大.表示莊家要賠錢的風險也越高. Margin = 106.86%其中的1是本金, 莊家要返還給玩家的, 剩下的才是莊家要賺的部份.所以 1 / 106.86% = 93.57% 就是一場比賽的理論返還率.top 100 bookmakers rankingmargin calculator 操盤同盤口的margin鮮少會在期間作異動, 因為賠率代表著風險, 也代表著銷量.所以大的莊家幾乎margin不會改變, 變得是該盤的賠率. 凱利指數公式?(各莊家的平均勝率*陪率 來計算) 怎來的? 不重要!目的在於體現 冷門出現的可能性凱利指數越低的, 莊家覺得越容易出現 ;越高的表示月不容易開出 換言之 &gt; 1 都不容易開出 Handicap / Spread (讓分盤)盤口 = 讓球把假設的入球數字加給比較不被看好的隊伍上 ;換句話說就是被看好的隊伍最後分數扣掉該數字.只開出一個讓球盤, 俗稱單票多個讓球盤, 俗稱套票8種讓分的盤口2種讓分的盤口 讓分有分成 * 讓半顆跟整數顆的讓分盤 * 目的 -&gt; 沒有平手 ; 平手要去別的玩法(ex 1x2, double chance) * 平手則投注作廢, 退回本金 * 讓0 : 賭輸贏 * 讓半球 : 讓球方以任何分數勝出, 就算贏(1:0) ; 平手,輸掉都算輸(1:1) * 讓一球 : 讓球方以兩球以上勝出, 就算贏(3:1) ; 讓球方分數-1而平手, 退回本金(2:1) ; 其餘都是輸(1:1/0:1) * 讓0.25跟0.75顆的亞洲讓分盤 * 0.25 : 平手退回本金/2 (基本不影響球隊輸贏) * 0.75 : 讓球隊伍分數-1, 為平手退回本金/2舉例 :|讓分盤口|比賽結果|主隊盤口贏|客隊盤口贏||————|———–|—————|————–||0(平手盤)| 1:0 | 主贏 | 客輸||0| 1:1 | refund(走盤) | refund ||0| 0:1 | 主輸 | 客贏||-0.25(平手/半球) | 1:0(淨勝 &gt;= 1) | 主贏 | 客輸||-0.25 | 1:1 | 贏半 | 輸半||-0.25 | 0:1 | 主輸 | 客贏||-0.5(半球) | 1:0(淨勝 &gt;= 1) | 主贏 | 客輸||-0.5 | 1:1 | 主輸 | 客贏||-0.5 | 0:1 | 主輸 | 客贏||-0.75(半球/1球) | 2:0(淨勝 &gt;= 2) | 主贏 | 客輸||-0.75 | 1:0(淨勝 = 1) | 贏半 | 輸半||-0.75 | 1:1 | 主輸 | 客贏||-0.75 | 0:1 | 主輸 | 客贏||-1(1球) | 2:0(淨勝 &gt;= 2) | 主贏 | 客輸||-1 | 1:0(淨勝 = 1) | refund | refund||-1 | 0:0 | 主輸 | 客贏||-1 | 0:1 | 主輸 | 客贏||-1.5(球半)|.. |.. |..||-2 (2球) | ..|.. |..| 亞洲盤透過讓球盤, 讓兩個相差懸殊的球隊, 有機會在一個相對公平的平台上較勁, 從而拉平了雙方客觀上的實力差距.主要是基於歐洲賠率為基礎開發出來的玩法.早期由澳門博彩公司開發出來的, 後來印尼為主的沙巴體育, 菲律賓的明升, 歐洲的BET365、立博等陸續開出了讓分盤, 而為了拓展亞洲市場所以稱為亞洲盤. 上盤/下盤 上盤 : 讓球的一方 (主場球隊/比較被看好的球隊) 下盤 : 受讓的一方 升盤/降盤 升盤 : 該場從讓1.5變成 讓1.5/2, 上升了一個盤口 降盤 : 該場從最初的1.5變成了1/1.5, 下降了一個盤口 盤口來回震盪, 表示兩邊投注金額變化很大盤口幾乎沒震盪, 表示兩邊payoff是平衡的.最常發生在快開踢前, 表示場外較量異常激烈. 水位雙方的獲勝賠率, 一組比例數據, 莊家獲取利潤的手段雙方水位和 正常都&lt; 2, 大概在1.8-1.9之間, 這距離1-2的差額就是莊家的直觀利潤.舉例要是水位和=1.9; 兩邊賠率一樣兩邊各被下注1000萬, 則最後比賽結束時, 莊家能收入100萬元. 初盤一開始在早盤所開出的1x2和odds最能體現兩隊之間的實力差距; 或是莊家對於兩隊的態度 即時開踢前的1x2其賠率走勢 終賠(最終賠率)就賽果反應在賠率上囉也是最終人會買的時刻, 因為幾乎可以胸有成竹的去投注.但也可能提早關盤.終盤幾乎各家都會對齊, 只差在水位策略的細微調整. 賠率種類 HongKong Odds [0, 100] &gt; 0 的正數, 不包含本金 HK -&gt; ML &gt; 1 : -1 / (odds) &lt;= 1 : odds HK -&gt; DEC odds + 1 HK -&gt; INDO &gt; 1 : odds &lt;= 1 : -1 * (1/odds) HK -&gt; American &lt; 1 : -1 * (100 / odds) &gt;= 1 : 100 * odds MalaY Odds : [-1, 1]玩弱隊 負數(輸少) : 從餘額扣除 期望金額(-1*賠率)的錢, 贏就是贏回跟期望金額一樣的錢 ; 換句話說, 我如果想要贏得期望金額這樣的金錢, 我需要投注 期望金額(-1*賠率), 如果贏了, 返回期望金額 正數(贏少) : 跟HK一樣 返還投注金額*賠率 ML -&gt; HK : 負數 : 1 / (-1 * odds) 正數 : -1 * 1/odds-1_ Stake Odds Win Lose Draw 100 0.8 80 -100 0 100 -0.71 100 -71 0 Decimal Odds (歐洲賠率) [1, 100] *&gt; 1 的正數, 包含本金 DEC -&gt; HK odds -1 Indo Odds : 玩強隊 [-100, -1] , [1, 100] &gt;= 1 (贏多) : 投注100$, 贏了, 返還金額 = 投注金額*賠率 ; 輸了賠100$ * &lt; -1 (輸多) : 賠率-1.25 , 期望金額100$, 要從餘額扣除100*1.25 = 125$, 這樣贏了才能獲得 100$的期望金額; 輸掉就賠125$, 125 &gt; 100$, 所以叫輸多 Fractional Odds American Odds &lt; 1 : 賠率113, 想淨勝100$, 要投入113$ Myanmar Odds +60 -50 Odds ConverterSettle","categories":[],"tags":[{"name":"Sportsbook","slug":"Sportsbook","permalink":"https://tedmax100.github.io/tags/Sportsbook/"}]},{"title":"TechWeekly","slug":"Weekly","date":"2019-07-14T16:38:08.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/07/15/Weekly/","link":"","permalink":"https://tedmax100.github.io/2019/07/15/Weekly/","excerpt":"","text":"Every Day :GoCN Every Saturday :Flutter Every Monday :前端精讀 Every ThursdayGoNode Every FridayJavaScript Every SundayTechbridge","categories":[{"name":"TechWeekly","slug":"TechWeekly","permalink":"https://tedmax100.github.io/categories/TechWeekly/"}],"tags":[{"name":"TechWeekly","slug":"TechWeekly","permalink":"https://tedmax100.github.io/tags/TechWeekly/"}]},{"title":"Go Module & Go Vendor","slug":"Go-Module-Go-Vendor","date":"2019-07-14T07:32:19.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/07/14/Go-Module-Go-Vendor/","link":"","permalink":"https://tedmax100.github.io/2019/07/14/Go-Module-Go-Vendor/","excerpt":"","text":"Go Module基礎出現原因 GOPATH不符合一般開發者的習慣; 大家習慣用maven, node module之類的方式. GOPATH無法有效管理板依賴, 沒有辦法表明所依賴的包的版本. 環境準備 Go version &gt;= 1.11 GO111MODULE=on GoMod effect immport package 可以在$GOPATH之外的地方建立專案 該專案Go Module開啟後, 下載的package會放在$GOPATH/pkg/mod下. $GOPATH/bin的功能依然保持 Go Mod Commands有兩種方式能定義一個正確的Go module 12345678// 在$GOPATH/src的目錄下, 建立合理的module路徑// 進入該module目錄, 執行下面命令go mod init [module name]///```bash// 在任意地方, 建立好module路徑// 在該目錄下, 執行go mod init [folder/]module name 就會在該專案下生出了go.mod文件了. Syntax of go.mod module 定義模組路徑 go 定義go version require 指定依賴的功能包和其版本或是[預設是最新版] exclude 忽略該功能包和其版本 replace 替換依賴的功能包123456module my/packagego 1.12require other/thing v1.0.2require new/thing/v2 v2.3.4exclude old/thing v1.2.3replace bad/thing v1.4.5 =&gt; good/thing v1.4.5 Go Mod Require 安裝一下logrus1go get github.com/sirupsen/logrus go.mod的內容 123module modtestgo 1.12require github.com/sirupsen/logrus v1.4.2 // indirect 此時把v1.4.2 改成v1.4.1執行 1go mod download go.mod的內容 123module modtestgo 1.12require github.com/sirupsen/logrus v1.4.1 // indirect 也會發生$GOPATH/pkg/mod/github.com/sirupsen目錄下,多了logrus@v1.4.1和1.4.2版本的源碼 Go Mod Excludego.mod的內容 12345module modtestgo 1.12require github.com/sirupsen/logrus v1.4.2 // indirectexclude github.com/gin-gonic/gin v1.4.0 1go get github.com/gin-gonic/gin 會發現應該是要下載當前最新板的v1.4.0的gin; 但因為有exclude gin 1.4.0 ;所以改成下載v1.3.9 go.mod的內容 12345678910111213module modtestgo 1.12require ( github.com/gin-contrib/sse v0.1.0 // indirect github.com/gin-gonic/gin v1.3.0 // indirect github.com/golang/protobuf v1.3.2 // indirect github.com/mattn/go-isatty v0.0.8 // indirect github.com/sirupsen/logrus v1.4.2 github.com/ugorji/go v1.1.7 // indirect gopkg.in/go-playground/validator.v8 v8.18.2 // indirect gopkg.in/yaml.v2 v2.2.2 // indirect)exclude github.com/gin-gonic/gin v1.4.0 如果exclude指定gin的依賴功能包, 該功能包會避開該版號作安裝 Go Mod Replace如果有package被replace, 則編譯時會使用對應的項目來作取代. 與require類似, 可以指向令一個repo 又或是指向本地的一個目錄 gomodtest 1234// go.modmodule modtestgo 1.12require github.com/sirupsen/logrus v1.4.2 // indirect 1234567891011121314// modtest.gopackage gomodtestimport ( log \"github.com/sirupsen/logrus\")func Init() &#123; log.Info(\"godmodtest init\")&#125;func Exec() &#123; log.Info(\"godmodtest exec\")&#125; **gomaintest 1234// go.modmodule github.com/tedmax100/gomaintestgo 1.12replace github.com/tedmax100/modtest =&gt; ../gomodtest 12345678910// main.gopackage mainimport ( modtest \"github.com/tedmax100/modtest\")func main() &#123; modtest.Exec()&#125; 執行結果 notes Replace和Exclude都只對當前這module有影響, 對其他功能包不會去影響到 ;其他功能包自己的replace也不會影響到這包.","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"}]},{"title":"Go Package","slug":"Go-Package","date":"2019-07-14T07:31:31.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/07/14/Go-Package/","link":"","permalink":"https://tedmax100.github.io/2019/07/14/Go-Package/","excerpt":"","text":"Everything you need to know about packages in Go Package(包)程式碼的目錄, 可以重複利用程式的方案, 方便維護。Go默認提供很多package, 像是fmt、is等。開發者也可以創建自己的package。 package要求所有檔案的第一行添加package名稱，標示該文件所歸屬的package。 1package 包名稱 一個目錄下的同級檔案屬於同一個package package名稱可以與目錄不同名稱, 但盡可能一樣 main package為應用程式執行的entry point; 若沒有main package則無法編譯成可執行的檔案在bin下 package name, Go團隊建議簡單扁平為原則。 所以盡量避免下划線、中划線和參雜大寫字母。 Creating a package 可執行包(executable package) 可自己執行，表示有main package 工具包(utility package) 不可自己執行，但是可以給可執行包做擴展應用的作用 123456789101112// main.gopackage mainimport ( \"fmt\" . \"hello/math\")func main() &#123; fmt.Println(\"hello\") fmt.Println(Average([]float64&#123;1, 2&#125;))&#125; 12345678910// math/math.gopackage mathfunc Average(xs []float64) float64 &#123; total := float64(0) for _, x := range xs &#123; total += x &#125; return total / float64(len(xs))&#125; 1234# 編譯hello package cd $GOPATH/src/hello; go install;# 因為有main package, 所以會安裝到$GOPATH/bin 作為可執行包 1234# 編譯hello package cd $GOPATH/src/hello/math; go install;# 因為沒有main package, 所以會安裝到$GOPATH/pkg下 作為工具包 Import package使用import package，Go會先在 $GOROOT/src下尋找指定的package。若找不到就往$GOPATH/src目錄下尋找。找不到就會報出編譯錯誤。 12345678910package mainimport ( // fmt位於$GOROOT/src下，找到! \"fmt\" // gin並不在$GOROOT/src, 接著找$GOPATH/src找github.com這目錄，找到往內找gin-gonic目錄，再找gin package \"github.com/gin-gonic/gin\" // . \"github.com/go-sql-driver/mysql\") Nested package在一個package內嵌套令一個package; 使用上只要指名路徑關係. 12345678910111213// math/math/extend/min.gopackage extendfunc init() &#123; fmt.Println(\"extend ==&gt; init()\")&#125;func Min(a float64, b float64) float64 &#123; if a &gt;= b &#123; return a &#125; return b&#125; 12345678910111213141516171819202122// math/math.gopackage mathimport ( \"fmt\" \"hello/math/extend\")func init() &#123; fmt.Println(\"math ==&gt; init()\")&#125;func Average(xs []float64) float64 &#123; total := float64(0) for _, x := range xs &#123; total += x &#125; return total / float64(len(xs))&#125;func Min(a float64, b float64) float64 &#123; return extend.Min(a, b)&#125; 1234567891011121314151617// main.gopackage mainimport ( \"fmt\" . \"hello/math\")func init() &#123; fmt.Println(\"main ==&gt; init()\")&#125;func main() &#123; fmt.Println(\"hello\") fmt.Println(Average([]float64&#123;1, 2&#125;)) fmt.Println(Min(1, 2))&#125; Package Initialization 工廠模式自動註冊-管理多個packge 12345678910111213141516171819202122232425// base/factory.gopackage base// define interface for Classtype Class interface &#123; Do()&#125;var ( // 存放註冊好的 類別工廠資訊 factoryByName = make(map[string]func() Class))// 註冊一個類別工廠func Register(name string, factory func() Class) &#123; factoryByName[name] = factory&#125;// 根據name創建對應的類別func Create(name string) Class &#123; if f, ok := factoryByName[name]; ok &#123; return f() &#125; panic(\"name not found\")&#125; 12345678910111213141516171819// ex1/reg.gopackage ex1import ( \"fmt\" \"github.com/tedmax100/factory/base\")type Class1 struct &#123;&#125;func (c *Class1) Do() &#123; fmt.Println(\"class1\")&#125;func init() &#123; base.Register(\"Class1\", func() base.Class &#123; return new(Class1) &#125;)&#125; 123456789101112131415161718192021// ex2/reg.gopackage ex1import ( \"fmt\" \"github.com/tedmax100/factory/base\")type Class2 struct &#123;&#125;func (c *Class2) Do() &#123; fmt.Println(\"class2\")&#125;func init() &#123; base.Register(\"Class2\", func() base.Class &#123; return new(Class2) &#125;)&#125; 1234567891011121314151617// main.gopackage mainimport ( \"github.com/tedmax100/factory/base\" _ \"github.com/tedmax100/factory/ex1\" _ \"github.com/tedmax100/factory/ex2\")//因為上面使用匿名導入了ex1 &amp; ex2 package.//main()執行前, 這兩個package的init()會被調用, 而註冊了class1 &amp; class2func main() &#123; c1 := base.Create(\"Class1\") c1.Do() c2 := base.Create(\"Class2\") c2.Do()&#125;","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"}]},{"title":"Go環境安裝","slug":"Go環境安裝","date":"2019-07-14T07:30:26.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/07/14/Go環境安裝/","link":"","permalink":"https://tedmax100.github.io/2019/07/14/Go環境安裝/","excerpt":"","text":"Download pageInstall doc Install the GO on Linux123456789# Download filewget https://dl.google.com/go/go1.12.7.linux-amd64.tar.gz# Extract it into /usr/localtar -C /usr/local -xzf go1.12.7.linux-amd64.tar.gz# Add /usr/local/go/bin to the Path environment variableexport PATH=$PATH:/usr/local/go/bin# Check installationgo env Upgrade Go123456# Download filewget https://dl.google.com/go/go$VERSION.linux-amd64.tar.gz# Extract it into /usr/localtar -C /usr/local -xzf go$VERSION.linux-amd64.tar.gz# Add /usr/local/go/bin to the Path environment variableexport PATH=$PATH:/usr/local/go/bin Upgrade by shell scriptupdate-golang WorkspacesWorkspacesSetting GoPath在GoPath所顯示的目錄下創建以下資料夾 src : go source file pkg : 編譯產生的文件, .a檔案(一包object file) ; 暫態緩存文件 bin : 編譯後可執行檔案1mkdir -p $GOPATH/src $GOPATH/pkg $GOPATH/bin First Go Program123mkdir -p $GOPATH/src/hellocd $GOPATH/src/hellocode . 以VsCode開啟該目錄 1234567package mainimport \"fmt\"func main() &#123; fmt.Println(\"hello\")&#125; 12345# 編譯產生可執行的二進制檔案, 會被安裝到$GOPATH/bin底下go install hello# 執行$GOPATH/bin/hello&gt; hello","categories":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/categories/Go/"}],"tags":[{"name":"Go","slug":"Go","permalink":"https://tedmax100.github.io/tags/Go/"}]},{"title":"Rx簡介","slug":"Rx簡介","date":"2019-07-14T04:21:13.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/07/14/Rx簡介/","link":"","permalink":"https://tedmax100.github.io/2019/07/14/Rx簡介/","excerpt":"","text":"When to use Rx使用Rx來精心地安排非同步和事件流的計算經常為了處理單一事件或是非同步的計算，而把程式的結構搞得非常的複雜，通常會設計狀態機來循序處理。還得處理每一個節點的成功跟失敗端點。這讓程式非常難以了解跟維護。 Rx的出現，使得這些計算跟處理成為一等公民(First-class citizens)。提供了一些模型和可組合的API來處理這些非同步操作。 Sample : 1234567891011121314151617181920var scheduler = new ControlScheduler(this);var keyDown = Observale.FromEvent&lt;KeyEventHandler, KeyEventArgs&gt;( d =&gt; d.Invoke, h =&gt; textBox.keyUp += h, h =&gt; textBox.KeyUp -= h);var dictionarySuggest = keyDown.Select( _ =&gt;textBox1.Text) .Where(text =&gt;!string.IsNullOrEmpty(text)) .DistingctUntilChanged() .Throttle(TimeSpan.FromMilliseconds(250), scheduler) .SelectMany( text =&gt; AsyncLookupInDictionary(text) .TakeUntil(keyDown) );dictionarySuggest.Subscribe( results =&gt; listView1.Items.AddRange(results.Select( result =&gt;new ListViewItem(result)).ToArray() ), error =&gt;LogError(error)); 這範例展示了UI如何接收用戶的鍵入並接收顯示。透過Rx建立了一個可觀察的序列(Observable sequence)，依附在KeyUp事件下。然後每個事件的上層，嵌入了幾個filter和projection， 確保事件只有透過事件觸發時，會發射event stream和唯一的值。像是KeyUp事件每次都會戳一次，但是其他動作並不會。並且透過Throttle操作子，確保在250ms區間內的行為只會觸發一次，透過延遲觸發節省昂貴的查找。 在傳統的作法上，Throttling的做法通常是透過timer callback來實作，但是timer本身很可能就會錯誤並拋出exceptions。一旦用戶鍵入並過濾完畢，就可以執行字典查找了，但通常這會透過Http來做請求，所以這個操作本身就是個async操作。SelectMany操作子允許輕鬆的組合多個async操作，不只組合了成功的狀態，也能追蹤每個單獨操作中出現的異常。在以往，這通常是引入不同的callback，如果用戶在操作時，仍然繼續鍵入新的值，通常會希望不會在看到之前操作的結果，因此舊的查詢結果就不必再顯示出來。TakeUntil操作確保，一旦偵測到新的KeyDown，就會忽略字典的查找。 最後我們訂閱這個observable sequence的結果，我們掛載了2個函式在訂閱的呼叫上 接收成功的計算結果 接收異常 使用Rx開始來處理非同步序列的資料Rx 遵循著以下幾個文法 OnNext* (OnCompleted|OnError)?。這些文法允許多個信息隨著時間的推移而倒入，使得Rx適用於能操作單個信息的操作，甚至於多個信息。 Sameple : 123456789101112131415161718192021222324//open a 4GB file for async reading in block of 64kvar inFile = new FileStream(@\"d:\\temp\\4GBfile.txt\", FileMode.Open, FileAccess.Read, FileShare.Read, 2 &lt;&lt; 15, true);//open a file for async writing in blocks of 64kvar outFile = new FileStream(@\"d:\\temp\\Encrypted.txt\", FileMode.OpenOrCreate, FileAccess.Write, FileShare.None, 2 &lt;&lt; 15, true);inFile.AsyncRead(2 &lt;&lt; 15) .Select(Encrypt) .WriteToStream(outFile) .Subscribe( _ =&gt;Console.WriteLine(\"Successfully encrypted the file.\"), error =&gt; Console.WriteLine( \"An error occurred while encrypting the file :&#123;0&#125;, error.Message ) ); 在這範例中，4GB的檔案，被整個讀取，並且透過加密存到另一個檔案。讀取整份檔案進去記憶體，透過加密跟寫檔出來，這是個非常高成本的操作。取而代之，我們依靠Rx可以產生許多個信息的event stream。以64K的區塊來非同步讀取文件，這產生了一個observable sequence。然後我們分別加密每個區塊，一旦區塊經過加密，就會立即的被發送到下一個管線，已被保存到另一份文件中。WriteToStream操作就是一個可以處理多個信息的非同步操作。 The Rx ContractIObservable和IObserver只用來這些方法的參數和回傳型別。Rx類別對這兩個介面做了比.net更多的假設。這些假設使得所有Rx類型的producer和consumbers都應該遵從的行為契約。這份契約使得去推論和證明程式的正確性。 Rx的假設文法信息被送到IObserver介面時必須遵從的文法 :OnNext* (OnCompleted |OnError)?這組文法允許observable sequences去送出任意數量的OnNext信息到 被訂閱的observer實例中。或是單一結果的成功(OnCompleted), 或是任何的失敗(OnError)。 單一信息能很明確的指示出這一個observer sequence的消費者可以安全地執行清理操作。單一的失敗信息，能確保多個observable sequences可以終止。 Sample : 1234567var count = 0;xs.Subscribe(v =&gt; &#123; count++ ; &#125;, e =&gt; Console.WriteLine(e.Message), () =&gt;Console.WriteLine(\"OnNext has been called &#123;0&#125; times.\"), count); 這範例我們能安全的假設一旦呼叫了OnComplete，OnNext中的調用變數不會被改變。 假設observer實例可以被當作Rx給序列化呼叫由於Rx是使用發布-訂閱模式，在.net中是支援multi threadss的，因此不同的信息可能同時到達不同的thread被處理。如果observale sequenc的消費者就不得不再每個地方來處理這問題，此時程式就需要實行大量的內文管理，來避免併發問題。這種方式寫的程式非常難以維護，且效能可能很低落。 由於不是所有的observable sequence都有信息是來自不同的執行緒的上下文，因此只有下述這種obervale sequence的producer才需要做序列化，確保消費者，可以安全的假設信息是以序列化的方式到達。 Sample : 12345var count = 0;xs.Subscribe(v=&gt;&#123; count++; Console.WriteLine(\"OnNext has been called &#123;0&#125; times\", count)&#125;); 在這範例中，不需要對count做任何lock或是讀寫互斥鎖的實作，因為只有OnNext的呼叫可以ˇ隨時得讀取和寫值到count。 確保在OnError和OnCompleted之後，資源會被清除上面指出了，只要OnError或是OnCompleted被調用後，就不會再有信息被送達。因此可以確保在OnError或是OnCompleted被觸發後，清除任何訂閱使用的資源。 Sample : 1234567Observavle.Using( () =&gt; new FileStream(@\"d:\\temp\\test.txt\", FileMode.Create), fs =&gt; Observable.Range(0, 10000) .Select(v =&gt; Encoding.ASCII.GetBytes(v.ToString())) .WriteToStream(fs)) .Subscribe(); 這範例中使用了Using去建立資源，這資源將會被disposed在unsubscription被呼叫之後。 盡最大努力去退訂所有未完成的工作當unsubscribe被呼叫後，observable sequence將會盡最大的努力去阻止所有未完成的工作。這也意味著還沒開始的排隊作業都不會被啟用。任何已經在進行中的工作都可能完成。因為放棄正在進行中的工作並不是一個安全的行為。只是這些工作的結果並不會被發送到任何以前訂閱的觀察者的實例中了。 Sample 1 : 1Observable.Timer(TimeSpan.FromSeconds(2)).Subscribe(...)Displose() 在這範例中，訂閱由Timer建立出來的oberservable sequence將在ThreadPool scheduler去形成一個排隊列緒，在2秒內去發送OnNext信息。訂閱之後立即取消，由於排成計畫尚未開始，因此將從scheduler中刪除。 Sample 2 : 1234Observable.Start(() =&gt; &#123; Thread.Sleep(TimeSpan.FromSeconds(2)); return 5;&#125;).Subscribe(...).Dispose(); 在這範例之中，Start操作子，立即安排lambda function做完參數。訂閱後將observer實例作為此執行的監聽器。由於一旦訂閱被執行，它將繼續運行並且忽略返回值5。","categories":[],"tags":[{"name":"Rx","slug":"Rx","permalink":"https://tedmax100.github.io/tags/Rx/"}]},{"title":"Decorator_Pattern","slug":"Decorator-Pattern","date":"2019-04-23T06:09:19.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/04/23/Decorator-Pattern/","link":"","permalink":"https://tedmax100.github.io/2019/04/23/Decorator-Pattern/","excerpt":"","text":"做武器系統今天想模仿暗黑破壞神的武器系統那樣 利用前綴詞為武器加上能力。D2魔法前綴詞表 首先我先建立一個基礎類別，然後各種武器(刀、劍、斧 等等)繼承於它。 12345678910export abstract class BaseWeapon &#123; private name: string; private attackPower: number; constructor(name: string, attackPower: number) &#123; this.name = name; this.attackPower = attackPower; &#125; public Name = (): string =&gt; this.name; public AttackPower = (): number =&gt; this.attackPower;&#125; 再來建立了一個劍和匕首類別 123456789101112131415import &#123; BaseWeapon &#125; from \"./BaseWeapon\";export class Sword extends BaseWeapon &#123; constructor() &#123; super(\"Sword\", 9); &#125; public Name = (): string =&gt; super.Name(); public AttackPower = (): number =&gt; super.AttackPower();&#125;export class Gull extends BaseWeapon &#123; constructor() &#123; super(\"Gull\", 2); &#125; public Name = (): string =&gt; super.Name(); public AttackPower = (): number =&gt; super.AttackPower();&#125; 然後透過繼承生成出了Flery Gull、Flery Sword、Static Gull、Static Sword 123456789101112131415161718192021222324252627282930import &#123; Gull &#125; from \"./Gull\";import &#123; Sword &#125; from \"./Sword\";export class FleryGull extends Gull &#123; constructor() &#123; super() &#125; public Name = (): string =&gt; `烈焰的$&#123;super.Name&#125;`; public AttackPower = (): number =&gt; super.AttackPower() + 16;&#125;export class FlerySword extends Sword &#123; constructor() &#123; super() &#125; public Name = (): string =&gt; `烈焰的$&#123;super.Name&#125;`; public AttackPower = (): number =&gt; super.AttackPower() + 16;&#125;export class StaticGull extends Gull &#123; constructor() &#123; super() &#125; public Name = (): string =&gt; `靜電的$&#123;super.Name&#125;`; public AttackPower = (): number =&gt; super.AttackPower() + 4;&#125;export class StaticSword extends Sword &#123; constructor() &#123; super() &#125; public Name = (): string =&gt; `靜電的$&#123;super.Name&#125;`; public AttackPower = (): number =&gt; super.AttackPower() + 4;&#125; 12345678let sword = new Sword();console.log(`$&#123;sword.Name&#125; : $&#123;sword.AttackPower&#125;`);let gull = new Gull();console.log(`$&#123;gull.Name&#125; : $&#123;gull.AttackPower&#125;`);let flerySword = new FlerySword();console.log(`$&#123;flerySword.Name&#125; : $&#123;flerySword.AttackPower&#125;`);let staicGull = new StaticGull();console.log(`$&#123;staicGull.Name&#125; : $&#123;staicGull.AttackPower&#125;`); 1234Sword : 9Gull : 2烈焰的Sword : 25靜電的Gull : 6 Class Diagram But!!!這才2種武器，2個特效，我已經有4個類別(2*2)。 2層繼承。當我前綴又再一層時，或者有後綴的出現，整個很難維護。再這情境上，我很可能會有一把是”靜電的烈焰”或”烈焰的靜電”這樣在現在設計上是不同類別，太多本質相似的類別需要維護了。 整理發生幾個現象 : 繼承層數過多、類別數量激增繼承超過兩層，可以想想是不是自己設計上出了問題，因為這樣維護成本只會越來越繁重。 為解決這些問題，增加一個抽象方法或介面類別來封裝武器類別。從上面可發現，我第二層跟第三層的類別基本上都是有共同的介面去實作一些行為。 Components: (要被裝飾物件) 123456789101112131415161718192021222324252627export interface BaseWeapon &#123; Name(): string; AttackPower(): number; Attack(): void;&#125;export class Sword implements BaseWeapon &#123; private name: string; private attackPower: number; constructor() &#123; this.name = \"Sword\"; this.attackPower = 9; &#125; public Name = (): string =&gt; this.name; public AttackPower = (): number =&gt; this.attackPower; public Attack = (): void =&gt; console.log(`$&#123;this.name&#125;打出了$&#123;this.attackPower&#125;點傷害!`);&#125;export class Gull implements BaseWeapon &#123; private name: string; private attackPower: number; constructor() &#123; this.name = \"Gull\"; this.attackPower = 2; &#125; public Name = (): string =&gt; this.name; public AttackPower = (): number =&gt; this.attackPower; public Attack = (): void =&gt; console.log(`$&#123;this.name&#125;打出了$&#123;this.attackPower&#125;點傷害!`);&#125; Decorators : 要加上的動態職責，需要有跟Components一樣的介面。 12345678910111213141516171819202122232425262728export abstract class WeaponDecorator implements BaseWeapon&#123; protected name: string; protected attackPower: number; protected weapon: BaseWeapon; constructor(name: string, attackPower: number, weapon: BaseWeapon) &#123; this.name = name; this.attackPower = attackPower; this.weapon = weapon; &#125; public Name = (): string =&gt; this.name + this.weapon.Name(); public AttackPower = (): number =&gt; this.attackPower + this.weapon.AttackPower(); public Attack = (): void =&gt; console.log(`$&#123;this.Name()&#125;打出了$&#123;this.AttackPower()&#125;點傷害!`);&#125;export class FleryDecorator extends WeaponDecorator&#123; constructor(weapon: BaseWeapon) &#123; debugger; if(weapon.Name().indexOf(\"烈焰的\") === -1) super(\"烈焰的\", 16, weapon); else super(\"\", 0, weapon); &#125;&#125;export class StaticDecorator extends WeaponDecorator&#123; constructor(weapon: BaseWeapon) &#123; if(weapon.Name().indexOf(\"靜電的\") === -1) super(\"靜電的\", 4, weapon); else super(\"\", 0, weapon); &#125;&#125; 12345678910const sword = new Sword(); const flerySword = new FleryDecorator(sword); flerySword.Attack(); const staticFleryword = new StaticDecorator(flerySword); staticFleryword.Attack(); const gull = new Gull(); const staticGull = new StaticDecorator(gull); staticGull.Attack(); const fleryStaticGull = new FleryDecorator(staticGull); fleryStaticGull.Attack(); 1234烈焰的Sword打出了25點傷害!靜電的烈焰的Sword打出了29點傷害!靜電的Gull打出了6點傷害!烈焰的靜電的Gull打出了22點傷害! Class Diagram :可以看到繼承關係被簡化了，組件跟功能之間變成組合關係。 裝飾者模式的定義Attach additional responsibilities to an object dynamically keeping the same interface.Decorators provide a flexible alternative to subclassing for extending functionality.(動態的給一個對象添加一些額外的職責，就功能面來說，裝是者模式 比 增加子類別靈活) Compoent抽象類別(BaseWeapon): 原有類別的抽象類或是一組介面ConcreteCompoent : 被裝飾的具体對象，需要去實現Compoent。Decorator : 也是一個抽象類別，實現Compontet，且裡面一定要有一個變數指向Componet抽象物件實體。 舉例: WeaponDecorator中的protected weapon: BaseWeapon 。ConcreteDecorator : Decorator的實作。主要就把基本的東西裝飾成其他東西。 Pros : ConcreteDecorator跟ConcreteComponent可以獨立發展，而不會相互耦合。In other words, 兩方不需要知道彼此的存在。Decorator類是從外部來擴展Component類別的功能，而Decorator也不知道具體的物件。舉例: Decorator依賴的其實是Compoenent的抽象或介面，且是組合關係。 是繼承關係的一種替代方案。看Decorator，不管裝飾多少層，返回的對象還是Component的抽象。實現的是is-a的關係。 可以動態的擴展一個類別的功能，就是該模式的定義。 裝飾者可以擴充Component的狀態，或是修改原有實作方法。 Cons : 除錯比較困難，多層裝飾下，因為會像是剝洋蔥一樣，可能要撥到最裡面那層，才發現出了問題。 ###使用場景 需要擴展一個類別的功能，又或者需要付加給它時。 需要動態的給一個對象增加功能，或者是動態的撤回。 需要為一大群兄弟類別進行改裝或加裝功能時。 使用Curry的概念來練習123456789101112131415161718192021222324252627class Sword &#123; private name: string; private attackPower: number; constructor() &#123; this.name = \"Sword\"; this.attackPower = 9; &#125; public Name = (): string =&gt; this.name; public AddPrefixAndAttackPower = (prefix: string, power: number) =&gt; &#123; this.name = prefix + this.name; this.attackPower += power; &#125; public AttackPower = (): number =&gt; this.attackPower; public Attack = (): void =&gt; console.log(`$&#123;this.name&#125;打出了$&#123;this.attackPower&#125;點傷害!`);&#125;interface PrefixValue &#123; prefix: string, attachPower: number&#125;const Prefix = (prefixValue: PrefixValue) =&gt; &#123; return function(sword: Sword) &#123; sword.AddPrefixAndAttackPower(prefixValue.prefix, prefixValue.attachPower); return sword; &#125;&#125;const FleryValue: PrefixValue = &#123;prefix:\"烈焰的\", attachPower: 16&#125;;Prefix(FleryValue)(new Sword()).Attack(); 1烈焰的Sword打出了25點傷害! 與Proxy的差異?等Proxy pattern寫完文章，再來一起比較。 ES6的Decorator?todo XD","categories":[],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://tedmax100.github.io/tags/Design-Pattern/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://tedmax100.github.io/tags/TypeScript/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://tedmax100.github.io/tags/JavaScript/"}]},{"title":"Multi and LuaScript for Redis","slug":"Multi-and-LuaScript-for-Redis","date":"2019-03-16T06:03:05.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/03/16/Multi-and-LuaScript-for-Redis/","link":"","permalink":"https://tedmax100.github.io/2019/03/16/Multi-and-LuaScript-for-Redis/","excerpt":"","text":"Multi? What is it?主要執行multi和exec包圍起來的部分，當multi命令發出，redis會進入transaction狀態，redis會進入blocking，不再處理其他請求，直到發出multi的session發出exec命令為止。被multi和exec包圍起來的命令們進入獨享redis的過程，直到執行完成。因為是transction，所以命令要全部執行完畢，不然就是都不執行。如果exec命令送出前，client斷線，redis會清空transction queue，所有命令都不會執行。一但client送出了exec命令，所有命列就會被執行，就算client斷線了也無訪。 如果transction過程中，要執行3個命令 1、2、3，其中2出錯了，不會像db那樣整個rollback，依然會執行到完。 透過這種方式，redis就能避免多個client同時訪問，出現讀寫不一致的情況，來完成atomic transction操作。 還有DISCARD (取消transcation)、WATCH(監控某個KEY，只要被更動，則transction無法被觸發，exec會得到nil)由於Multi是把命令逐條發送給redis server，server還會回應QUEUED，並且最後還要回應執行結果，所以封包數量上其實比平常都多，效率也近乎最低的。 Pipeline?一次執行多條命令，無關atomic，網路封包數量也最少。有機會再筆記。 Why use Lua Script to access Redis? 當需要對redis下多個命令，且每一個命令就是一次網路傳輸。 多個指令中，後面的指令依賴前一個操作的結果時。 Redis依然是 單執行緒下執行依序執行這些操作。 如果Lua script本身內容很多，可以先把lua script載入redis, redis會返回一組SHA字串，以後就直接傳遞這SHA字串即可替代原內容。 可以組合多個命令，且該次執行本身也是atomic操作。 支援base、table(array)、string、match、debug、cjson、cmspack。 1234情境 :HotYoutubers 是以sorted set結構存放，檢查要是youtuber不再名單內，則新增要是在名單內了，則score + 1 Initial Data 12345678910const youtubers = ['理科太太', '赤井Akai', 'D Rebound 99', '融融歷險記', '志祺七七X圖文不符', '閃亮胖時代','只會玩刀鋒', 'Ken桑', '尬酒螺仔', '我們Our channel'];const voteCnt = [10000, 9999, 8999, 8000, 8001, 9383, 5345, 6864, 1384, 5131];const newYoutubers = ['华农兄弟'];const key = \"HotRanks\";const youtuberListKey = \"Youtubers\";const promiseArray: any[] = [];youtubers.map(d =&gt; promiseArray.push(d));await Promise.all(youtubers.map(d) =&gt; &#123; redisClient.SADD(\"KEYA\", d);&#125;); 不使用Multi 1234567891011121314151617client.zscan(key, \"0\" , \"MATCH\", youtubers[0], (err, reply) =&gt; &#123; if(err)&#123; console.error(&#123; error: err, key: key, target: youtubers[0] &#125;) return ; &#125; if(reply[1].length &gt; 0) &#123; console.log(`$&#123;youtubers[0]&#125; increase score`); client.zincrby(key, 1, youtubers[0]); &#125; else &#123; console.log(\"add new youtuber\"); client.zadd(key, 1, youtubers[0]); &#125;&#125;); 網路封包 : 5個封包 使用Multi 1234567891011121314151617181920212223242526272829303132333435 client .multi() .zscan(key, \"0\" , \"MATCH\", youtubers[0]) .zincrby(key, 1, youtubers[0]) .zrevrange(key, 0 , 10) .exec((err, replies) =&gt; &#123; if(err)&#123; console.error(&#123; error: err, key: key, target: youtubers[0] &#125;) return ; &#125; console.dir(replies); if(replies[0][1].length &gt; 0) &#123; console.log(`$&#123;youtubers[0]&#125; increase score`); &#125; else &#123; console.log(\"add new youtuber\"); &#125; &#125;)結果 :[ [ '0', [ '理科太太', '10007' ] ], '10008', [ '理科太太', '赤井Akai', '閃亮胖時代', 'D Rebound 99', '志祺七七X圖文不符', '融融歷險記', 'Ken桑', '只會玩刀鋒', '我們Our channel', '尬酒螺仔' ] ]理科太太 increase score 封包數量 : 3個, 一個是multi起transaction,並把命令們丟進去queue，等到exec被發出調用，一次返回全部命令的結果。 But!!!不方便做到更複雜的需求!雖然zincrby在item不存在時，會幫忙新增item，並給上分數。但要是想先檢查youtube set內內是否存在此youtuber時就很難了。 使用Lua Script 來完成! 先檢查youtuber清單 “Youtubers” youtuber存在，則增加分數 youtuber不存在，則回傳nil Notes :Lua的array都是從1開始的。 client.eval(luaScript, 2, key, youtuberListKey, newYoutubers[0]; 這段的2是告訴redis有兩個Key在KEYS[]當中，而在這所引外的都會是在ARGV[]當中了。 宣告變數是用local這關鍵字宣告 lua的null是nill 如果變數x是table(即arry)類型，要使用 則使用#x 來使用; 例如取得x的陣列長度 #x.length 想要對table類型做歷尋有以下方式 使用ipair探索table中的陣列部分, for k, v in ipair(變數x) do ; k就是k, v則是value, ipair 使用pairs探索table中所有資料, for k, v in ipair(變數x) do ; k就是k, v則是value, ipair 123456789101112131415161718192021222324252627282930const luaScript = 'local youtuber = redis.call(\"HEXISTS\", KEYS[2], ARGV[1]) \\if(youtuber == 0) then \\ return nil \\else \\ return redis.call(\"zincrby\", KEYS[1], 1, ARGV[1]) \\end ';client.eval(luaScript, 2, key, youtuberListKey, newYoutubers[0], (err, replies) =&gt; &#123; if(err)&#123; console.error(&#123; error: err, key: key, target: youtubers[0] &#125;) return ; &#125; console.dir(replies); &#125;)// 結果 : nullclient.eval(luaScript, 2, key, youtuberListKey, youtubers[0], (err, replies) =&gt; &#123; if(err)&#123; console.error(&#123; error: err, key: key, target: youtubers[0] &#125;) return ; &#125; console.dir(replies); &#125;)// 結果 : '10010' 封包數量 : 3, 同Multi But!!!每次執行都要送這些腳本以及編譯，有沒有方法省掉呢?Yes!!!先把script透過script load載入，會得到一串hash string。以後執行evalsha跟這hash string即可。 1234567891011121314151617let hashScript: string;client.script('load', luaScript, (err, res) =&gt; &#123; console.dir(res); // 'aa838cb2f4f84408889222a7af3bec845f126ba8' hashScript = res;&#125;)client.evalsha(hashScript, 2, key, youtuberListKey, youtubers[0], (err, replies) =&gt; &#123; if(err)&#123; console.error(&#123; error: err, key: key, target: youtubers[0] &#125;) return ; &#125; console.dir(replies); &#125;) Redis能做到的事情蠻多的，不只是能當快取，透過Lua腳本，也能簡單的做些關聯查詢。只是它畢竟是單執行緒，要是被這任務卡住太久，就喪失快取的意義了。 日後有機會再筆記PUB/SUB，我在實務上的簡單應用。最主要的還是他的叢集架設與資料同步/備份的部分。","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://tedmax100.github.io/tags/Redis/"},{"name":"Lua","slug":"Lua","permalink":"https://tedmax100.github.io/tags/Lua/"}]},{"title":"Strtegy Pattern","slug":"Strtegy-Pattern","date":"2019-02-23T05:57:02.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/02/23/Strtegy-Pattern/","link":"","permalink":"https://tedmax100.github.io/2019/02/23/Strtegy-Pattern/","excerpt":"","text":"小故事劉備去東吳招親前，諸葛亮預測東吳會刁難劉備，甚至吞掉荊州西川，因此諸葛亮特授予趙雲三個錦囊，說是按照天機拆開解決棘手問題。 三個妙計是: 找喬國老幫忙(走後門) 求吳國太放行(訴苦) 孫夫人斷後(親情攻擊) 這三個妙計都是告訴照雲要怎麼去執行，也就是說三個計謀都有一個方法是”執行“。具體執行什麼內容，每個妙計會有所不同。 類別圖 : 12345678910111213interface IStrategy &#123; // 執行錦囊 operate(): void;&#125;class BackDoor implements IStrategy &#123; public operate = () =&gt; console.log(\"找喬國老幫忙，讓吳國太施予壓力\");&#125;class GivenGreenLight implements IStrategy &#123; public operate = () =&gt; console.log(\"找吳國太開綠燈，給予放行\");&#125;class BlockEnemy implements IStrategy &#123; public operate = () =&gt; console.log(\"孫夫人斷後，擋住追兵\");&#125; 還需要裝著計策的錦囊，以及一個執行人 趙雲。 1234567891011121314151617181920212223class Context &#123; private strategy: IStrategy; constructor(strategy: IStrategy) &#123; this.strategy = strategy; &#125; public operate = () =&gt; this.strategy.operate();&#125;// ZhaoYun(() =&gt; &#123; let context: Context; console.log(\"--剛到吳國拆第一個--\"); context = new Context(new BackDoor()); context.operate(); console.log(\"------------------\"); console.log(\"--劉備樂不思蜀，拆第二個--\"); context = new Context(new GivenGreenLight()); context.operate(); console.log(\"------------------\"); console.log(\"--孫權小兵殺來，拆第三個--\"); context = new Context(new BlockEnemy()); context.operate(); console.log(\"------------------\");&#125;)() 策略模式的定義Define a family of algorithms, encapsulate each one, and make them interchangeable.(定義一組算法，將每個算法封裝起來，並且使它們之間可以互換。) 12345678910111213141516171819202122interface IStrategy &#123; doSomething(): void;&#125;class ConcreteStrategy1 implements IStrategy &#123; public doSomething = () =&gt; console.log(1);&#125;class ConcreteStrategy2 implements IStrategy &#123; public doSomething = () =&gt; console.log(2);&#125;class Context &#123; private strategy: IStrategy; constructor(_strategy: IStrategy) &#123; this.strategy = _strategy; &#125; public doAnything = () =&gt; this.strategy.doSomething();&#125;(() =&gt; &#123; let strategy = new ConcreteStrategy1(); let context: Context = new Context(strategy); context.doAnything();&#125;)() 回顧 使用了 OO的繼承跟多態。 要定義哪個行為，是抽象策略介面。Pros : 算法可以自由切換 : 只要有實現抽象策略，就成為了策略家族的一個成員，通過封裝腳色對其進行封裝，保證對外提供”可自由切換”的策略。 去除多重條件判斷 : 因為多重條件不容易維護閱讀，且改壞的機率很大。使用了策略模式後，可能由其他模塊決定採用什麼策略，對外提供的訪問接口就是封裝類別，簡化了操作，也避免掉條件判斷。 擴展性良好 : 只要新增一個策略成員並且實現接口就能, 類似於一個可反覆拆裝的插件，為此這模式符合了OCP原則。Cons : 策略類別太多 = 類別膨脹, 可重複利用程度非常小。 所有策略類別都需要對外暴露: 上層模組一定要知道有哪些策略，才能決定怎麼使用。這樣違反了LKP原則(最少知識原則); 但可以用工廠模式、代理模式或是享元模式解決。 使用場景 多個類別只有在算法或是行為上稍有不同的場景 算法需要自由切換的場景 需要屏蔽算法規則的場景 ; 調用者不必了解太多細節，能依據策略名稱就能知道怎使用，然後反饋給他一個極果，就結束了。 如果策略超過4個，應該要考慮混和模式，解決策略類別過長跟對外暴露的問題。 策略模式的例子加減乘除計算器Version 1 12345678910111213141516171819202122class Calculator &#123; private static readonly ADD_SYMBOL: string = \"+\"; private static readonly SUB_SYMBOL: string = \"-\"; public exec = (a: number, b: number, symbol: string) =&gt; &#123; let result: number = 0; if(symbol === Calculator.ADD_SYMBOL)&#123; result = this.add(a, b); &#125;else if (symbol === Calculator.SUB_SYMBOL) &#123; result = this.sub(a, b); &#125; return result; &#125; private add = (a: number, b: number) =&gt; a + b; private sub = (a: number, b: number) =&gt; a - b;&#125;(() =&gt; &#123; let a = 1; let symbol:string = \"+\"; let b = 2; let cal = new Calculator(); console.log(cal.exec(a, b, symbol));&#125;)() Version 2使用三元運算子簡化主邏輯 1234567891011121314151617181920212223242526272829302345678910111213141516class Calculator &#123; private static readonly ADD_SYMBOL: string = \"+\"; private static readonly SUB_SYMBOL: string = \"-\"; public exec = (a: number, b: number, symbol: string) =&gt; symbol === Calculator.ADD_SYMBOL ? a+b : a-b; &#125;(() =&gt; &#123; let a = 1; let symbol:string = \"+\"; let b = 2; let cal = new Calculator(); console.log(cal.exec(a, b, symbol));&#125;)() Version 3 引入策略模式由上下文角色決定具體策略; 並且封裝角色保證策略時可以相互替換 1234567891011121314151617181920212223242526272829interface Calculator &#123; exec(a: number, b: number): number;&#125;class Add implements Calculator &#123; constructor() &#123;&#125; public exec = (a: number, b: number): number =&gt; a+b; &#125;class Sub implements Calculator &#123; constructor() &#123;&#125; public exec = (a: number, b: number): number =&gt; a-b; &#125;class Context &#123; private cal: Calculator; constructor(_cal: Calculator) &#123; this.cal = _cal; &#125; public exec = (a: number, b: number, symbol: string) =&gt; this.cal.exec(a,b);&#125;(() =&gt; &#123; const ADD_SYMBOL: string = \"+\"; const SUB_SYMBOL: string = \"-\"; let a = 1; let symbol:string = \"+\"; let b = 2; let context: Context; if (symbol === ADD_SYMBOL) context = new Context(new Add()); else if (symbol === SUB_SYMBOL) context = new Context(new Sub()); console.log(context!.exec(a, b, symbol));&#125;)() Version 4 引入策略列舉","categories":[],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://tedmax100.github.io/tags/Design-Pattern/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://tedmax100.github.io/tags/TypeScript/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://tedmax100.github.io/tags/JavaScript/"}]},{"title":"Factory Pattern Cont’d","slug":"Factory-Pattern-Cont’d","date":"2019-02-20T05:48:39.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/02/20/Factory-Pattern-Cont’d/","link":"","permalink":"https://tedmax100.github.io/2019/02/20/Factory-Pattern-Cont’d/","excerpt":"","text":"Simple Factory Method (簡單工廠模式)也稱為靜態工廠模式，去掉了抽象工廠類別，簡單實現，但缺點 工廠類的擴展就困難了，會不符合開閉原則。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354interface Human &#123; // 取得膚色 getColor(): void; //說話 talk() : void;&#125;class BlackHuman implements Human&#123; public getColor = () =&gt; &#123; console.log(\"黑人膚色是黑色的。\"); &#125; public talk = () =&gt; &#123; console.log(\"黑人會說話，一般人聽不懂\"); &#125;&#125;class YellowHuman implements Human&#123; public getColor = () =&gt; &#123; console.log(\"黃種人膚色是黃色的。\"); &#125; public talk = () =&gt; &#123; console.log(\"黃種人會說話，說的都是2byte的文字\"); &#125;&#125;class WhiteHuman implements Human&#123; public getColor = () =&gt; &#123; console.log(\"白人膚色是白色的。\"); &#125; public talk = () =&gt; &#123; console.log(\"白人會說話，說的都是1byte的文字\"); &#125;&#125;class HumanFactory &#123; public static createHuman&lt;T extends Human&gt;(type: (new () =&gt; T)): T &#123; let human: any = &#123;&#125;; // let testType: new() =&gt; T| undefined ; debugger; try &#123; human = new type();//(&lt;any&gt;Object).assign(human, new type()); &#125;catch(exp) &#123; console.error(exp); &#125; return human as T; &#125;&#125;(() =&gt; &#123; let whiteUhman = HumanFactory.createHuman&lt;WhiteHuman&gt;(WhiteHuman); whiteUhman.getColor(); whiteUhman.talk(); let balckhman = HumanFactory.createHuman&lt;BlackHuman&gt;(BlackHuman); balckhman.getColor(); balckhman.talk(); let yellowHuman = HumanFactory.createHuman&lt;YellowHuman&gt;(YellowHuman); yellowHuman.getColor(); yellowHuman.talk();&#125;)(); Multiple Factorys往往在複雜的業務項目上，會遇到一個產品類，有超多種的實現類。每個實現類的初始化方法都不太依樣，如果寫在一個工廠方法之中，一定會導致該方法複雜無比。要讓結構清晰，就替每個產品定義一個創造者，然後由調用者去選擇與哪個工廠方法做關聯。好處 創建類別職責清晰，且結構簡單，但是可擴展性和維護帶來一定影響。因為多一個產品，就要堆一個工廠類，還得考慮對象之間的關係。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162namespace MultipleFactories &#123; interface Human &#123; // 取得膚色 getColor(): void; //說話 talk() : void;&#125;class BlackHuman implements Human&#123; public getColor = () =&gt; &#123; console.log(\"黑人膚色是黑色的。\"); &#125; public talk = () =&gt; &#123; console.log(\"黑人會說話，一般人聽不懂\"); &#125;&#125;class YellowHuman implements Human&#123; public getColor = () =&gt; &#123; console.log(\"黃種人膚色是黃色的。\"); &#125; public talk = () =&gt; &#123; console.log(\"黃種人會說話，說的都是2byte的文字\"); &#125;&#125;class WhiteHuman implements Human&#123; public getColor = () =&gt; &#123; console.log(\"白人膚色是白色的。\"); &#125; public talk = () =&gt; &#123; console.log(\"白人會說話，說的都是1byte的文字\"); &#125;&#125;abstract class AbstractHumanFactory &#123; public abstract createHuman(): Human ;&#125;class YellowHumanFactory extends AbstractHumanFactory &#123; public createHuman = (): YellowHuman =&gt; &#123; return new YellowHuman(); &#125;&#125;class BlackHumanFactory extends AbstractHumanFactory &#123; public createHuman = (): BlackHuman =&gt; &#123; return new BlackHuman(); &#125;&#125;class WhiteHumanFactory extends AbstractHumanFactory &#123; public createHuman = (): WhiteHuman =&gt; &#123; return new WhiteHuman(); &#125;&#125;(() =&gt; &#123; let whiteUhman = new WhiteHumanFactory().createHuman(); whiteUhman.getColor(); whiteUhman.talk(); let balckhman = new BlackHumanFactory().createHuman(); balckhman.getColor(); balckhman.talk(); let yellowHuman = new YellowHumanFactory().createHuman(); yellowHuman.getColor(); yellowHuman.talk();&#125;)();&#125; Lazy initialization 延遲初始化一個物件被消費完成後，不立刻釋放，而是保持其初始狀態，等待被再度使用。這是工廠模式的一種擴展應用。 123456789101112131415161718192021class Product &#123;&#125;class ConcreteProduct1 extends Product &#123;&#125;class ConcreteProduct2 extends Product&#123;&#125;class ProductFactory &#123; private static prMap: Map&lt;string, Product&gt; = new Map(); public static createProduct: Product = (type: string): Product|undefined =&gt; &#123; let product = null; if(ProductFactory.prMap.has(type)) &#123; product = ProductFactory.prMap.get(type); &#125;else&#123; if(type === \"Product1\") &#123; product = new ConcreteProduct1(); &#125;else&#123; product = new ConcreteProduct2(); &#125; // 把物件 放到緩存中 ProductFactory.prMap.set(type, product); &#125; return product; &#125;&#125; 舉例，像是Conneection Pool都會要求設置MaxConnection最大連線數量，該數量就是記憶體中instance的數量。 Conclusion很多官方與第三方套件之中都包含工廠方法，且工廠方法還能與其他模式混搭使用(模板模式、單例、原型模式等)，有多更適合的設計。","categories":[],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://tedmax100.github.io/tags/Design-Pattern/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://tedmax100.github.io/tags/TypeScript/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://tedmax100.github.io/tags/JavaScript/"}]},{"title":"Factory Pattern","slug":"Factory-Pattern","date":"2019-02-19T05:45:41.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/02/19/Factory-Pattern/","link":"","permalink":"https://tedmax100.github.io/2019/02/19/Factory-Pattern/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031/* 定義人類與人種 */interface Human &#123; // 取得膚色 getColor(): void; //說話 talk() : void;&#125;class BlackHuman implements Human&#123; public getColor = () =&gt; &#123; console.log(\"黑人膚色是黑色的。\"); &#125; public talk = () =&gt; &#123; console.log(\"黑人說話，一搬人聽不懂\"); &#125;&#125;class YellowHuman implements Human&#123; public getColor = () =&gt; &#123; console.log(\"黃種人膚色是黃色的。\"); &#125; public talk = () =&gt; &#123; console.log(\"黃種人會說話，說的都是2byte的文字\"); &#125;&#125;class WhiteHuman implements Human&#123; public getColor = () =&gt; &#123; console.log(\"白人膚色是白色的。\"); &#125; public talk = () =&gt; &#123; console.log(\"白人會說話，說的都是1byte的文字\"); &#125;&#125; 1234567891011121314151617/* 抽象人類工廠，透過泛型對createHuman的輸入參數產生限制 : 1. class型別 ; 2. 必須實現Human */abstract class AbstractHumanFactory &#123; public abstract createHuman&lt;T extends Human&gt;(type: (new () =&gt; T)): T ;&#125;// 實踐工廠class HumanFactory extends AbstractHumanFactory &#123; public createHuman&lt;T extends Human&gt;(type: (new () =&gt; T)): T &#123; let human: any = &#123;&#125;; try &#123; human = new type();//(&lt;any&gt;Object).assign(human, new type()); &#125;catch(exp) &#123; console.error(exp); &#125; return human as T; &#125;&#125; 12345678910111213執行 創物者(() =&gt; &#123; let creator: AbstractHumanFactory = new HumanFactory(); let whiteUhman = creator.createHuman&lt;WhiteHuman&gt;(WhiteHuman); whiteUhman.getColor(); whiteUhman.talk(); let balckhman = creator.createHuman&lt;BlackHuman&gt;(BlackHuman); balckhman.getColor(); balckhman.talk(); let yellowHuman = creator.createHuman&lt;YellowHuman&gt;(YellowHuman); yellowHuman.getColor(); yellowHuman.talk();&#125;)(); 123456白人膚色是白色的。白人會說話，說的都是1byte的文字黑人膚色是黑色的。黑人會說話，一般人聽不懂黃種人膚色是黃色的。黃種人會說話，說的都是2byte的文字 Definition :Define an interface for creating an object, but let subclasses decide which class to instantiate Factroy Method lets a class defer instantiation to subclasses.定義一個用於創建對象的介面，讓子類別決定實例化哪一個類別，使一個類別的實例化延遲到其子類別 Pros : 良好的封裝性，結構清晰，一個對象的建立是有條件約束的，降低耦合性。 拓展性優秀，增加業務產品類別十，只要擴展一個工廠類，就能”擁抱變化”。 封裝屏蔽產品類，產品類的實現如何變化，調用者根本不需要關心，他只關心產品的接口。 滿足 迪米特法則(最小知識原則), 滿足依賴倒置原則，滿足里氏替換原則。 萬物皆對象，所以萬物也就是產品類。 Example : JDBC, 從MySQL切換到Oracle，就是更換一下驅動名稱。 MailServer 有 POP3、IMAP、HTTP，把這三種定義為產品類，定義介面IConnectMail，再定義工廠方法，按照不同條件，選擇不同連接方式，做到完美的拓展。 單元測試, 測試類別A，類別有關連到類別B，用工廠方法把類別B虛擬出來，就能Mock依賴物件。","categories":[],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://tedmax100.github.io/tags/Design-Pattern/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://tedmax100.github.io/tags/TypeScript/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://tedmax100.github.io/tags/JavaScript/"}]},{"title":"Rx and Pormise","slug":"Rx-and-Pormise","date":"2019-02-14T04:59:23.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2019/02/14/Rx-and-Pormise/","link":"","permalink":"https://tedmax100.github.io/2019/02/14/Rx-and-Pormise/","excerpt":"","text":"Reactive Programing (響應式編程)Def : 一種面向(data flow)數據流和(propagation of change)變化傳播的編程風格。 propagation of change 變化傳播最初的資料是否會隨著後續對應變量的變化而變化。 在inperative programming中A+B=C 2+3=52+4=5 not 6當B的資料發生改變之後，C的數值必沒有隨著B的改變而改變。 在Reactive Programing中A+B=C2+3=52+4=6 在MVVM中，存在一種M到V的綁定關係當Model由model1變為model2時，View也隨之進行了變化，從view1變成view2.所以MVVM框架，也實現了RX中的propagation of change概念。 data flow(stream)監聽一系列的事件流，並對這一系列事件進行 映射(Map)、過濾(Filter)、合併(Merge)等處理後，在響應整個事件流的callback(回調)，該過程便是 面相數據流的編程。 數據流被封裝在一個叫做Observable的實例中，通過觀察者模式，對數據流進行統一的訂閱，並在中間插入像filter這樣的操作，從而對Observable所封裝的數據流進行處理。 1myObservable.filter(fn).subscribe(callback); ReactiveX微軟開發維護的Reactive Programing套件。結合了 觀察者模式、迭代器模式、函數式編程(Functional Programming)。 ObservableRx核心概念!!所有產生出來的非同步數據都先包裝程Observable對象，Observable對象是把這些非同步數據轉換成 data stream的形式。所以這些Observable對象等同於data stream的源頭，後續操作都圍繞著這些被轉換的流動數據展開的。上圖最上方的箭頭(時間軸)表示了最初的Observable對象，這個對象發出了3個數據，這3個可能是點擊事件的數據，也可能是response的數據。經過map處理後，原來的Observable對象會變成一個新的Observable對象，並且原來的3個數據會轉換成新的數據在新的Observable對象數據流裡流動。 概念雷同於 工廠生產線上的 生產流水線。Observable對象相當於半成品，map相當於流水線上的工人，加工後變成成品。 RX 是 借鑒了集合的操作思想，把複雜的非同步數據流處理問題，簡化成同步的集合處理問題。換言之，開發者能透過Observable，操作集合一樣操作複雜的非同步數據流。 OperatorOperator是實現了迭代器模式、函數式編程的利器。Operator是Observable的操作方式。每一個數據流，都能透過某個operator對該Observable對象進行操作。大部分operator操作完後，會返回一個新的Observable對象給下一個operator處理。也因此，這樣方便在各個operator間透過鍊式寫法編寫。 123let newObservable = observable .debounceTime(500) .take(2); Compare With Promise能用promise的場景, RxJs都適用，因為RxJs是作為promise的超集合存在的。 12345let promise = new Promise((resolve, reject) =&gt; &#123; // some code if(/* 異步執行成功 */) resolve(value); reject(error);&#125;); 123456let observable = new Observable((observer) =&gt; &#123; observer.next(value1); observer.next(value2); observer.error(err);&#125;) Pormise只能針對單一的非同步事件進行resolve()，但在Observable中，不僅能處理單一的非同步事件(就是調用observer的next())，而且能以streaming形式響應多個非同步事件。還有對於Promise中的all()、race()等，RxJs都有對應的解決方案。 12let newPromise = Promise.all(promiseReq1, promiseReq2);let newObservable = Rx.Observable.forkJoin(obsReq1, obsReq2);","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://tedmax100.github.io/tags/JavaScript/"},{"name":"Rx","slug":"Rx","permalink":"https://tedmax100.github.io/tags/Rx/"}]},{"title":"AWS CloudFront","slug":"AWS-CloudFront","date":"2018-12-15T04:56:46.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2018/12/15/AWS-CloudFront/","link":"","permalink":"https://tedmax100.github.io/2018/12/15/AWS-CloudFront/","excerpt":"","text":"AWS CloudFront CloudFront加快靜態和動態web內容分配給用戶的Web服務。 透過全球數據中心(edge location)來傳輸內容。當user向CloudFront請求提供內容時，user會被陸游到提供最低延遲的edge location，以最佳的速度傳送內容。如果內容已經存在edge location十，則cloudfront將直接提供它。(但我們的情境不需要去快取資料)如果請求的內容不再edge，則會對web server進行查找。 配置CloudFront配置source server，CloudFront將從這些server獲取資料。source server儲存的對象是當下最終的版本。建立CloudFront distribution，user通過你的網站或api在請求資料時，告訴cloudfront從那些source server來獲取資料。還需要指定cloudfront是否記錄所有請求以及該分配建立後立即啟用。將配置發送到所有edge location。 Optional configuration:可以配置source server對response添加header;header能設置希望資料再edge location保留的時限。默認是保留24hr。minimum expiration = 0s HTTP MethodsPOST/PUT/PATCH/OPTIONS/DELETE，將直接從edge location站點直接會到連source server，並不會流過regional edge location做快取查找。 指定對象在CloudFront edge location的expirationValues That You Specify When You Create or Update a Web Distribution Lab CloudFront + S3 : Staging config : Restrict Bucket Access： 選擇”Yes”，因為希望網站是向CloudFront存取，而不是向S3。 Query String Forwarding and Caching : only for APICertifacate type : TLS11","categories":[],"tags":[{"name":"AWS","slug":"AWS","permalink":"https://tedmax100.github.io/tags/AWS/"}]},{"title":"JS Clean Code訓練營","slug":"JS-Clean-Code訓練營","date":"2018-10-09T04:46:57.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2018/10/09/JS-Clean-Code訓練營/","link":"","permalink":"https://tedmax100.github.io/2018/10/09/JS-Clean-Code訓練營/","excerpt":"","text":"12345678910111213第一天 :有效的单元测试识别依赖隔离依赖前端逻辑的常见剥离方式Stub与Mock处理Callback和Promise第二天 : 小步重构识别代码臭味处理代码臭味的技巧良好设计的基本原则消除重复，降低复杂度 Day1 :Lesson 1:1 .FizzBuzz 數學歸納法: n =1 =&gt; n+1 ok一個it test, 通常證明2個test case Vue_Header profileCaption test Lesson 2:單元測試的好處: “提早”得知程式碼是否有漏洞; 提早設置check point。 回歸測試 自動運行 說明文件 建立可重複利用的元件 任何測試案例應該是獨立的 使用者角度去做測試案例 private method不應該被特別測試，因為第7點的關係，使用者只在意公開方法，且私有方法一定會被公開方法給使用到。 基本上單元測試，都是黑盒測試，因為只在意輸出入。 單元測試要快 使用類似jest的框架，整合模擬測試ui上的行為 Lesson 3 :物件導向設計原則: 組件 應該要具備 高內聚、低耦合 的特性 物件導向的繼承關係，就是高耦合 只要function內有new()，也是高耦合 Stub : state changeMock : behavior test (called, parameter…) Lesson 4:一一一一一一一一一一一一一一一一一一一UT —————————–&gt; IT Unit Test: 速度快 程式少 定位問題簡單 代碼依賴剝離 成本高 無網路、文檔讀寫、外部第三方套件、跟運行環境無關的、與配置無關 Integration Test: 速度慢 程式多 定位問題多 代碼依賴剝離 成本低 前端的UI 異步執行 Refactoring moment.js(會修改自身，產生副作用) -&gt; date.js budget.js if 有return , else也return remove else 重複的邏輯 -&gt; extract method 可讀性低 || 註解 (因為怕看不懂，所以加註解) code smell 長方法 long method代碼行數過長 (code standard by group define) 多種數據結構 使用同一個數據 表達同一件事情。startDate &amp; endDate 進來後被轉成兩種不同的變數。 duplicate logic(code) temporary variable(Field) -&gt; Inline Temp 令人費解的命名 (不把型別加入命名中) -&gt; *Rename method clearly intention 資料謎團 data clump 抽象干擾 Abstraction Distraction 特性忌妒 Feature Envy 基礎型別偏執 primitive obssession how use inline option delete useless codes delete duplicate codes ; 先讓疑似重複的部分盡可能變得一樣，別一開始就提取代碼。 extract method rename covert param to object create data class change signature use loadash to make code to be clearly intention Refactor vs Rewrite Refactor: 行為與之前一樣，但代碼可讀性更高 Rewrite : 行為未必與之前一樣。 異動範圍大小 流程與結構的不同 Day2被提取出來的私有class，與私有方法，只要是只有被測試公開方法給涵蓋，且只有這些再用，就不必再額外寫測試。除非它後來有其他其他未被涵蓋測試的公開方法給引用。除非後來因為這些被提取的部分出bug，再補充其測試。 Refactor 擁抱變化 從legacy code 實現 演進式設計 建築 vs software design 藍圖 –build–&gt; 建築 代碼 –build–&gt; 軟體 UML 用來與人溝通，一致化想法用的語言，並非藍圖 JS 不一定適合套用design pattern, 只有少數的pattern適用 Legacy code type : new feature stable (已經上無數補丁，正在運行中) unused Lesson 2 MVC vs MVP MVC的進入點是controller -&gt; Model -&gt; Controller -&gt; View MVP的進入點式VIEW -&gt; Presenter -&gt; Model -&gt; Presenter -&gt; View Tell, Don’t ask -&gt; Design principle 防衛性編程 12345678fun A(xxx) &#123; if(A) ... return ___;&#125;let a = A(param);if(a) &#123; ....&#125; 在進入口做防範驗證，內部邏輯別做太多返回值的判斷。 調用者保證參數有效，被調用者保證返回值有效 Design Contract 給予 default value; 別用null 表達某一種邏輯 Null object pattern architecture view model presenter business model dto、dao Smells 註解 不適當的訊息 Inappropriate Information : 註釋只應該描述有關代碼跟設計的技術性訊息，不該帶作者、最後修改時間等。 因為GIT上會記錄。 廢棄的註解 Obsolete Comment:不正確或無關的註解。 冗餘註解 糟糕的註解 註解掉的代碼 方法 過多的參數 Too Many Arguments : 盡量少，沒參數最好，超過3個就要避免。 輸出參數 Output Arguments: appendFooter(s) 不如把footer設定在物件屬性內，再呼叫report.appendFoorer() 標示參數 Flag Arguments 123//pseudo-codeclass Concert... public Booking book (Customer aCustomer, boolean isPremium) &#123;...&#125; 12public Booking regularBook(Customer aCustomer) &#123;...&#125;public Booking premiumBook(Customer aCustomer) &#123;...&#125; * 死方法 Dead Function 一般問題 重複 DRY (Don’t Repeat Yourself): 資料庫正規化，物件導向繼承 接口提供過多 Too Much Information 特性依戀 Feature Envy: 類別的方法只對類中的屬性跟方法有興趣，不該依靠其他類中的變數跟方法。顯然是「內聚力」不夠的一種現象","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://tedmax100.github.io/tags/JavaScript/"},{"name":"CleanCode","slug":"CleanCode","permalink":"https://tedmax100.github.io/tags/CleanCode/"}]},{"title":"Introduce to RabbitMQ","slug":"Introduce-to-RabbitMQ","date":"2017-12-13T04:29:48.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2017/12/13/Introduce-to-RabbitMQ/","link":"","permalink":"https://tedmax100.github.io/2017/12/13/Introduce-to-RabbitMQ/","excerpt":"RabbitMQ Tutorials","text":"RabbitMQ Tutorials What is RabbitMQ?RabbitMQ是實現AMQP的一種微服務，用於分散是系統之中來儲存轉發訊息，便於使用，方便擴展，又有高可用性。目的能替系統之間做雙向解耦。當生產者產出大量資料要送出時，消費者若無法快速消費掉，這時候就需要一個中介層，來保存這些數據。 AMQP的工作流程如下圖 : message被publisher 發送給exchange，exchange常常被比喻為郵局或是郵箱。然後exchange根據收到的message以及規則分發給綁定的queue。最後AMQP代理會將message投遞給訂閱此queue的consumer，或是消費者依照需求自行獲取。 因為網路是不可靠的，接收消息的服務也有可能在處理時失敗，所以AMQP包含的一了message acknowledgement的概念:當一個message從queue當中投遞給consumer後，consumer會通知broker，這個message可以從queue當中刪除。 某些情況下，當message無法被成功投遞時，message或許會被返回給producer並且被丟棄。或者代理執行了延期操作，message會被放入Dead-Letter exchange中。此時producer可選選擇某些參數來處理這些特殊情況。 一個Log系統，能用MQ來簡化工作，一個consumer進行訊息的正常處理，另一個consumer對訊息做log紀錄，只要在系統中，起兩個consumer並把queue以相同的方式binding到同一個exchange即可。 剩下的訊息分派工作全由MQ負責完成。 Concept and Feature Broker就是MQ service本身 Producer發送message的程序 Consumer一個等待從queue當中獲取message的程序 Virtual Host一個broker內可以設置多個Vhost，做為不同用戶的權限分離，或是不同的業務規劃。Vhost之間相互隔離，不同Vhost之間無法共享exchange/queue。 Exchange交換機，指定消息按照什麼規則，路由到哪個queue。有direct、topic、headers、fanout 四種type能設置,不同type的exchange路由行為是不同的。 Queue每個message都會被投遞到一個或是多個queue當中，等待被投遞。類似於郵筒的概念，message都會被存放在此。queue本身是一個很大的message buffer，可以有很多個producer發送，但都會傳到同一個queue且可以有多個consumer獲取資料。 Channel在客戶端的每個connection中，可以建立多個channel,每個channel表示一個session， 客戶端只能透過channel才能執行AMQP的命令。之所以需要channel因為TCP連線的建立跟釋放都是十分昂貴的，如果一個客戶端的每個線程都需要與broker交換訊息，每一個線程都建立一個TCP connection的話，OS也無法承受每秒建立如此多的TCP connection。所以RabbitMQ建議同一個發送串行資料的線程共用Channel和connection。 Binding把exchange和queue按照路由規則綁釘起來。Exchange在跟多個queue binding後會生成一張routing table， Routing Key路由的關鍵字，exchange根據這關鍵字，來進行訊息投遞 AMQP entitiesQueue + Exchange + Binding = AMQP entities Task QueuesTask queues工作隊列，是為了避免等待一些占用大量資源、費時的操作。只要把task當作訊息丟進queue中，就會有運行的worker取出任務然後處理，當運行多個workers時，任務就會在彼此之間分配。 Message Acknowledgment通常沒特別設置ack在queue的時候，只要message一投遞出去，立刻就為從queue之中移除。此時如果worker運行到一半掛掉，正在處理的message就會遺失了。如果不想遺失任何message，當前worker掛掉時，我們希望任務會重新指派給其他worker。 因此，RabbitMQ提供了acknowledements。worker會通過一個ack訊號，告訴RabbitMQ已經收到了並且處理完該條訊息，然後MQ就會刪除該訊息。 如果worker掛了，沒有發送ack，則MQ就會認為message沒有被完全處理，就會重新發送給其他worker，這樣就不會遺失任何message。 但由於message沒有timeout的概念，只能等worker跟MQ斷開連線，這樣MQ就會重送了。message acknowledement預設是關閉的，只要把auto_ack = true即可。 1234567891011var consumer = new EventingBasicConsumer(channel);consumer.Receved += (model, ea) =&gt;&#123; var body = ea.body; var message = Encoding.UTF8.GetString(body); Console.WriteLine($\"&#123;received &#123;message&#125;&#125;\"); int dots = message.Split('.').Length - 1; Thread.Sleep(dots * 1000); Console.WriteLine(\"Done\"); channel.BasicAck(deliveryTag : ea.DeliveryTag, multiple:false);&#125;;channel.BasicAck(queue:\"task_queue\", autoAck:True, consumer :consumer); Increase throuput and performance關閉ack能提升MQ的效能 Message DurabilityMessage Durability訊息持久化，MQ預設並不會對queue和message做持久化的設置，因此必須先把queue和message設置為durable。 首先先聲明queue為durable，這樣確保MQ重啟後，queue不會被遺失。MQ也不允許使用不同參數定義一個同名的queue。因此producer和consumer的設置必須一樣。 12345channel.QueueDeclare(queue:\"task_queue\", durable :true, exclusive:false, autoDelete:false, arguments:null); 接著設置message persistence 12var properties = channel.CreateBasicProperties();properties.Persistent = true; Note on message persistence把message 設置為persistence，並不能完全保證不會丟失。因為只是告訴MQ要把message存入硬碟，MQ也不是所有message都寫入硬碟，可能只是放在記憶體暫存。 Fair DispatchMQ只管把第n-th消息投遞給第n-th個worker，並不關心worker有沒有ack。可以設置prefetch_count=1，告訴MQ，同一時間，別送超過1條訊息給同一位worker，直到他已經處理完上一條message並送出ack。這樣MQ就會把消息分發給下一位worker。 1channel.basicqos(0, 1, false); Publish/Subscribepub/sub目的是要把一個message分發給多個consumer。這個模型的核心概念是，producer並不會直接發送訊息給queue，而是把消息發送給exchange。 exchange在這裡就是負責從producer接收消息，一邊把消息推送到queue。exchange必須知道如何處理它接受到的消息，是要推送到指定的queue還是多個queue，或是忽略，這些規則是透過exchange type來定義。 Exchange Type direct 直連 fanout 廣播 topic 主題 headers 表頭1channel.ExchangeDeclare(\"logs\", \"fanout\"); Note for default exchangeMQ預設就存在一組default exchagne，名稱是空字串”” Temporary queues在task queue的情境下，給個worker同樣的queue name，這時候會透過round robin做輪詢派送。但是現在要的是每個人都能收到同樣的訊息，因此需要的是一個全新、空的queue，來跟exchagne綁定。能透過自己定義隨機的queue name或是，讓MQ來幫我們選擇一個隨機的queue name。 1var queueName = channel.QueueDeclare().QueueName; 這時拿到的queue name就會類似amq.gen-JzTY20BRgKO-HjmUJj0wLg。 Bindings有了fanout exchange和數個queue，這時就要設置exchange和queue之間的關聯。 123channel.QueueBind(queue:queueName, exchagne:\"logs\", routingKey:\"\"); Note for routing keyfanout type下，routing key是會被忽略的。 RoutingRouting key的設置，能使得queue只訂閱消息的子集合。綁定的時候可以設置routingKey又或是稱為bindingKey，為了避免跟BasicPublish的routingKey搞混。 123channel.QueueBind(queue:queueName, exchange:\"direct_logs\", routingKey:\"black\"); 使用exchange和routing key來進行精確配對，從而確保消息該投遞到哪個queue。 這裡第一個queue用orange作為綁定鍵，另一個queue用black和green。這樣所有orange的消息都會被路由到C1, 而black/green則會被路由到C2，其他message通通被丟棄。 Multiple Bindings多個queue使用同樣的routingKey也是可行的。 C1和C2都使用black做綁定。這樣跟fanout type的行為雷同，只要是black的訊息，C1跟C2都會收到，但其他一樣被丟棄。 Scene : Log System將log依據不同級別作為rougingKey來選擇接收者跟處理方式。建立exchange 1channel.ExchangeDeclare(exchange: \"direct_logs\", type: \"direct\"); 發送log訊息, serverity是info、warning、error其中一個 12345var body = Encoding.UTF8.GetBytes(message);channel.BasicPublish(exchange: \"direct_logs\", routingKey: severity, basicProperties: null, body: body); subscribing 1234567var queueName = channel.QueueDeclare().QueueName;foreach(var severity in args)&#123; channel.QueueBind(queue: queueName, exchange: \"direct_logs\", routingKey: severity);&#125; TopicsDirect exchange有些限制，沒辦法基於多個標準來執行路由操作。有時會希望不只是訂閱基於嚴重程度的日誌，也希望訂閱其他種日誌。這時就需要topic exchange。 發送到topic exchange的訊息不可以設置routingKey，它的routingKey是一個由.分隔開的單字列表。這些單字是什麼都能，跟message有關係的詞彙是最好的。例如:”stock.usd.nyse”, “quick.orange.rabbit”，單字個數可以任意個，但不能超過255 bytes。routingKey中也能使用類似regular expression表達個數: 表示一個單字 表示任意數量的單字一個攜帶有quick.orange.rabbit的消息會被投遞到C1跟C2。攜帶著lazy.orange.elephant的也是。quick.orange,fox只會投遞給C2。lazy.pink.rabbit只會給C2投遞1次。quick.brown.fox的將會被丟棄。orange和quick.orange.male.rabbit的都會被丟棄掉。lazy.orange.male.rabbit將會被投遞到C2。 topic exchange是很powerful的，它可以表現出其他exchnge type的行為。 當一個queue的routingKey是#時，這個queue將會無視message的routingKey，接收全部message。 當*和#都未出現在routingKey時，這時候就跟direct type是一樣的行為。 Questions bindingKey為*的queue會取到一個routingKey為空字串的消息嗎? bindingKey為#.的queue會收到一個routingKey為*..的消息嗎? 它會收到routingKey為一個單字的消息嗎? a.*.#和a.#的區別? RPC遠端過程調用Remote Procedure Call(RPC)如果需要將一個函式運行在遠端服務上並且等待結果時，這時就需要RPC。 透過RabbitMQ來建造一個RPC System，一個client和一個RPC Server。 client interface 1234var rpcClient = new RPCClient();Console.WriteLine(\"Request fib()\");var response = rpcClient.Call(\"30\");Console.WriteLine($\"Got &#123;0&#125;\", response); RabbitMQ Cluster and High AvailableRabbitMQ Cluser設置要求所有機器上的Erlang和RabbitMQ版本需要都相同，機器上Erlang的Cookie也相同","categories":[],"tags":[{"name":"MQ","slug":"MQ","permalink":"https://tedmax100.github.io/tags/MQ/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://tedmax100.github.io/tags/RabbitMQ/"}]},{"title":"Rx_IEnumberbale和IObservable","slug":"Rx-IEnumberbale和IObservable","date":"2017-11-26T04:25:25.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2017/11/26/Rx-IEnumberbale和IObservable/","link":"","permalink":"https://tedmax100.github.io/2017/11/26/Rx-IEnumberbale和IObservable/","excerpt":"","text":"Rx可以做的事情Rx可以處理很多內容，例如async處理、event、IEnumberable等，例如 :MouseClick event、MousePosition等等的事情還有對於時間的處理，例如Timer，可以想成是指定時間間隔會發生的事件的值。還有async，可以想像成某個時間點，才開始進行的處理，且處理完成後，才會得到某個值。 Rx和LinqRx最基本的介面是IObservable(T) (被觀察者)，它與.NET常見的IEnumerable是不同的。但是能跟用Linq查找的方法一樣來查找。 12345678using System.Reactive.Linq;//LinQ to Objectsvar ix = from x in Enumerable.Range(1,10) where x % 2 == 0 select x * x;var rx = from x in Observable.Range(1,10) where x % 2 == 0 select x * x; Rx裡雖然增加了不少新的方法，但是大部分的同名方法操作跟定義上都跟原本的一樣，這降低了很多學習成本。雖然介面不同，但是都可以用Linq expression來達成同樣的效果。所以IObservable/IObserver 和 IEnumerable/IEnumerator，可以視前者為後者的反轉。 這段Code將描述IObserver介面如何反轉IEnumberator介面的。 123456789101112131415161718192021222324252627282930313233//簡化過的IEnumerator&lt;T&gt;public interface IEnumberator&lt;T&gt;&#123; T current&#123;get;&#125; bool MoveNext(); //void Reset(); Reset現在一般不使用&#125;//MoveNext改回傳bool,再調用currentpublic interface IEnumberator&lt;T&gt;&#123; //MoveNext回傳T的instance //如果結束的話，則不回傳(== void) //異常的話，拋出 //因此有3種類型的回傳 T|void|Excecption GetNext(void);&#125;//根據對偶性(Duality)，將參數和回傳值互換位置//以前都是被動式的去取Pull，現在則是主動的拿到Push，//所以改用Gotpublic interface IEnumeratorDual&lt;T&gt;&#123; void GotNext(T|void|Exception);&#125;//進而按照Pull的3種回傳類型，分開定義介面public interface IEnumeratorDual&lt;T&gt;&#123; void GotNext(T); void GotVoid(void); void GotException(Exception);&#125;//最後視現在用的IObserver&lt;T&gt;介面public interface IObserver&lt;T&gt;&#123; void OnNext(T value); void OnComplete(); void OnError(Exception error);&#125; 所以IObservable和IEnumberator視可以相互轉換的，兩人可透過彼此的擴充方法相互轉換。且這些擴充方法，在Rx中都已經定義了。通過這突，可以清楚的了解IEnumerable是Pull,而IObservable是Push。 Event use Rx123456789//監聽Mouse move eventpublic static IObservable&lt;MouseEventArgs&gt; MouseMoveAsObservable(this Form form)&#123; return Observable.FromEventPattern&lt;MouseEventArgs&gt;(from, \"MouseMode\").Select(e =&gt;e.EventArgs);&#125;public void TextChangeAsObservable()&#123; //等待1秒後若沒在收到新的資料，就用最近收到的資料來處理 Observable.FromEventPattern&lt;EventArgs&gt;(textBox, \"TextChanged\").Select(_ =&gt;textBox.Text) .Throttle(TimeSpane.FromSeconds(1));&#125; Throttle可以設定一定的時間間隔，過濾掉一些不必要的輸入，上面範例中，一秒內無論發生多少次變化，只有最後一次的值才會被push出去。 Async By Rx12345678910111213141516171819202122232425var req = WebRequest.Create(\"http://hoge/\"); req.BeginGetResponse(ar =&gt; &#123; try &#123; var res = req.EndGetResponse(ar); var url = new StreamReader(res.GetResponseStream()).ReadToEnd(); var req2 = WebRequest.Create(url); // 在前面請求的結果上，再發請請求 req2.BeginGetResponse(ar2 =&gt; &#123; //再多次請求的處理下，往往需要在每一層加上try-catch try &#123; var res2 = req2.EndGetResponse(ar2); var str = new StreamReader(res2.GetResponseStream()).ReadToEnd(); Dispatcher.BeginInvoke(new Action(() =&gt; MessageBox.Show(str))); &#125; catch (WebException e) &#123; Dispatcher.BeginInvoke(new Action(() =&gt; MessageBox.Show(e.ToString()))); &#125; &#125;, null); &#125; catch (WebException e) &#123; Dispatcher.BeginInvoke(new Action(() =&gt; MessageBox.Show(e.ToString()))); &#125; &#125;, null); 1234567891011121314151617WebRequest.Create(\"http://hoge/\") .DownloadStringAsysnc() .SelectMany(url =&gt; WebRequest.Create(url).DownloadStringAsync()) .ObserveOnDisaptcher() .Subscribe( str =&gt;MeesageBox.Show(str), e =&gt; MessageBox.Show(e.ToString()); )public static class WebRequestExtensions&#123; return Observable.FromAsyncPattern&lt;WebResponse&gt;(request.BeginGetResponse, request.EndGetResponse)() .Select(res =&gt; &#123; using(var stram = res.GetResponseStream()) using(var sr = new StreamReader(stream))&#123; return sr.ReadToEnd(); &#125; &#125;);&#125; 使用Rx能把Lambda expression的call back改寫成Method Chain，降低閱讀複雜度。","categories":[],"tags":[{"name":"Rx","slug":"Rx","permalink":"https://tedmax100.github.io/tags/Rx/"}]},{"title":"State Pattern","slug":"State-Pattern","date":"2017-11-21T05:51:52.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2017/11/21/State-Pattern/","link":"","permalink":"https://tedmax100.github.io/2017/11/21/State-Pattern/","excerpt":"","text":"實作電梯電梯的動作: 開門、關門、運行、停止 123456789101112interface ILift &#123; open(): void; close(): void; run(): void; stop(): void&#125;class Lift implements ILift &#123; public open = () =&gt; console.log(\"電梯門打開\"); public close = () =&gt; console.log(\"電梯門關閉\"); public run = () =&gt; console.log(\"電梯上下運行\"); public stop = () =&gt; console.log(\"電梯停止\");&#125; 1234567891011(() =&gt;&#123; const lift: ILift = new Lift(); lift.open(); lift.close(); lift.run(); lift.stop();&#125;)()電梯門打開電梯門關閉電梯上下運行電梯停止 But!!!電梯是有狀態的, 有前提條件的。 不可能在運行時突然開門，或是停止了不開門的情況。所以動作執行都有前置條件，也就是在特定狀態下才能做特定事務。| | Open | Close | Run | Stop ||———-|——|——-|—–|——|| 開門狀態 | x | o | x | x || 關門狀態 | o | x | o | o || 運行狀態 | x | x | x | o || 停止狀態 | o | x | o | x | Version 1 : 加上前置條件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697enum LiftState &#123; OPENING_STATE = 1, CLOSING_STATE= 2, RUNNIG_STATE = 3, STOPPING_STATE = 4&#125;interface ILift &#123; setState(state: LiftState): void; open(): void; close(): void; run(): void; stop(): void&#125;class Lift implements ILift &#123; private state: LiftState; constructor() &#123; this.state = LiftState.STOPPING_STATE; &#125; public setState = (value: LiftState) =&gt; this.state = value; public open = () =&gt; &#123; switch (this.state) &#123; case LiftState.OPENING_STATE : break; case LiftState.CLOSING_STATE : this.openWithoutLogic(); this.setState(LiftState.OPENING_STATE); break; case LiftState.RUNNIG_STATE : break; case LiftState.STOPPING_STATE : this.openWithoutLogic(); this.setState(LiftState.OPENING_STATE); break; &#125; &#125; public close = () =&gt; &#123; switch (this.state) &#123; case LiftState.OPENING_STATE : this.closeWithoutLogic(); this.setState(LiftState.CLOSING_STATE); break; case LiftState.CLOSING_STATE : break; case LiftState.RUNNIG_STATE : break; case LiftState.STOPPING_STATE : break; &#125; &#125;; public run = () =&gt; &#123; switch (this.state) &#123; case LiftState.OPENING_STATE : break; case LiftState.CLOSING_STATE : this.runWithoutLogic(); this.setState(LiftState.RUNNIG_STATE); break; case LiftState.RUNNIG_STATE : break; case LiftState.STOPPING_STATE : this.runWithoutLogic(); this.setState(LiftState.RUNNIG_STATE); break; &#125; &#125; public stop = () =&gt; &#123; switch (this.state) &#123; case LiftState.OPENING_STATE : break; case LiftState.CLOSING_STATE : this.stopWithoutLogic(); this.setState(LiftState.STOPPING_STATE); break; case LiftState.RUNNIG_STATE : this.stopWithoutLogic(); this.setState(LiftState.STOPPING_STATE); break; case LiftState.STOPPING_STATE : break; &#125; &#125; private closeWithoutLogic = () =&gt; console.log(\"電梯門關閉...\"); private openWithoutLogic = () =&gt; console.log(\"電梯門開啟...\"); private runWithoutLogic = () =&gt; console.log(\"電梯上下運行...\"); private stopWithoutLogic = () =&gt; console.log(\"電梯停止了...\");&#125;(() =&gt;&#123; const lift: ILift = new Lift(); lift.open(); lift.close(); lift.run(); lift.stop();&#125;)()電梯門開啟...電梯門關閉...電梯上下運行...電梯停止了... 思考問題實現類別Lift邏輯很饒舌，充斥著很多switch或是if-else。難以閱讀維護。擴展性很差，當狀態越多(通電狀態、斷電狀態)，都要增加條件。非常規狀態難以實踐，故障、檢修等狀態。 會違反單一職責原則。 轉換思考角度剛剛都是以電梯的方法跟方法執行的條件去分析。現在換個角度思考，電梯在具有這些狀態時能夠做什麼事情， 也就是說電梯處於某個具體狀態時，思考這個狀態是由什麼動作觸發而產生的，以及在這狀態下電梯還能做什麼事情? 停止狀態怎來的? 當然是因為執行了stop()停止狀態下，還能做什麼? 運行? 開門?所以只要實現電梯在一個狀態下的兩個任務模型即可 : 這個狀態如何產生的這個狀態下還能做什麼(怎過度狀態) Version 2 : 抽象與撥離Context 12345678910111213141516import &#123; LiftState &#125; from './state';export class Context &#123; private liftState?: LiftState; constructor() &#123; this.liftState = undefined; &#125; public getLiftState = () =&gt; this.liftState!; public setLiftState = (liftState: LiftState) =&gt; &#123; this.liftState = liftState; this.liftState.setContext(this); &#125; public open = () =&gt; this.liftState!.open(); public close = () =&gt; this.liftState!.close(); public run = () =&gt; this.liftState!.run(); public stop = () =&gt; this.liftState!.stop();&#125; LiftState 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import &#123; Context &#125; from \"./Context\";let context = new Context();export abstract class LiftState &#123; public setContext = (_context: Context) =&gt; context = _context; public abstract open(): void; public abstract close(): void; public abstract run(): void; public abstract stop(): void;&#125;export class OpenningState extends LiftState &#123; constructor() &#123; super(); &#125; public close = () =&gt; &#123; context.setLiftState(new ClosingState()); context.getLiftState().close(); &#125; public open = () =&gt; console.log(\"電梯門開啟...\"); public run = () =&gt; &#123;&#125;; public stop = () =&gt; &#123;&#125;;&#125;export class ClosingState extends LiftState &#123; constructor() &#123; super(); &#125; public close = () =&gt; console.log(\"電梯門關閉...\"); public open = () =&gt; &#123; context.setLiftState(new OpenningState()); context.getLiftState().open(); &#125; public run = () =&gt; &#123; context.setLiftState(new RunningState()); context.getLiftState().run(); &#125;; public stop = () =&gt; &#123; context.setLiftState(new StoppingState()); context.getLiftState().stop(); &#125;;&#125;export class RunningState extends LiftState &#123; constructor() &#123; super(); &#125; public close = () =&gt; &#123;&#125;; public open = () =&gt; &#123;&#125;; public run = () =&gt; console.log(\"電梯上下運行...\"); public stop = () =&gt; &#123; context.setLiftState(new StoppingState()); context.getLiftState().stop(); &#125;;&#125;export class StoppingState extends LiftState &#123; constructor() &#123; super(); &#125; public close = () =&gt; &#123;&#125;; public open = () =&gt; &#123; context.setLiftState(new OpenningState()); context.getLiftState().open(); &#125;; public run = () =&gt; &#123; context.setLiftState(new RunningState()); context.getLiftState().run(); &#125; public stop = () =&gt; console.log(\"電梯停止了...\");&#125;(() =&gt;&#123; const context = new Context(); context.setLiftState(new ClosingState()); context.open(); context.close(); context.run(); context.stop();&#125;)()電梯門開啟...電梯門關閉...電梯上下運行...電梯停止了... 回顧 Client場景變簡單了，只要給初始狀態，調用相關方法，完全不用考慮狀態的切換變更。也就是說只看到行為的發生改變，並不用知道是狀態變化引起的改變。 各場景的程式碼縮短了，因為切成各個子類別; 也取消了switch…case的判斷。 符合”開閉原則”, 因為要增加狀態，除了要增加子類別，也要修改原有的類別，只是要在原有的方法上增加新的方法，而不更動原有的。 符合單一職責, 現在各狀態式單獨的類別，只有與這狀態相關的因素能做修改。 狀態模式的定義Allow an object to alter its behavior when its internal state changes. The object will appear to change its class. (當一個對象內在狀態改變時，允許其改變行為，這個對象則看起來像是改變了類別) State - 抽象狀態 interface或abstact class, 負責對象狀態定義，並且封裝環境腳色用來實現狀態切換。 ConcreateState - 具體狀態 自己的狀態行為管理，跟趨向狀態處理; 當下狀態要做的事情，以及過渡到其他狀態。 Context - 環境腳色 定義client要得介面，並且負責具體狀態的切換。 Pros : 結構清晰 : 避免過多switch…case或if…else，增加可維護性 遵循設計原則 : 實現”開閉原則” 和 “單一職責” 封裝性良好 : 狀態變換放置到內部實現，外部不用知道 Cons : 子類別太多 = 類別膨脹 使用場景 行為隨著狀態改變而改變 條件、分之判斷語句的替代 組合技建造者+狀態模式 : 將狀態間切換的一定順序用建造者做構建。","categories":[],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://tedmax100.github.io/tags/Design-Pattern/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://tedmax100.github.io/tags/TypeScript/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://tedmax100.github.io/tags/JavaScript/"}]},{"title":"Docker入門_01","slug":"Docker入門-01","date":"2017-11-12T16:01:59.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2017/11/13/Docker入門-01/","link":"","permalink":"https://tedmax100.github.io/2017/11/13/Docker入門-01/","excerpt":"What is Docker?","text":"What is Docker? Docker從廣義上是個服務容器(Application Container)，基本上跟一般系統中執行的Process並無不同，特別的是它負責操作鏡像檔案(images)。所以Docker+構建昇成出來的image file == Docker Container。 Windows上的Docker有何不同Docker在Windows上安裝好時，會自動安裝一個Docker專用的Linux虛擬機，透過Hyper-V來管理。透過這個Linux虛擬基在背後提供和運行Container的方式來達成使用。 也正因為如此，所以目前找到的打包好的image file都是以Linux為主的原因了。所以基本上，Docker上的容器都是跑在Linux內核中，只是單獨包成一隻應用程式檔，掛載進去Docker的進程內。 Docker images鏡像 ，就類似於VM中的快照，但容量卻小上許多，Docker透過ID或是容易識別的別名+tag來抓到唯一的目標鏡像檔。ImagesID是一個64bit長度的字串，但通常只要使用前4碼即可。 Ubuntu上安裝DockerLink","categories":[{"name":"Docker","slug":"Docker","permalink":"https://tedmax100.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://tedmax100.github.io/tags/Docker/"}]},{"title":"PixiJS-簡介","slug":"PixiJS-簡介","date":"2017-06-05T15:59:50.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2017/06/05/PixiJS-簡介/","link":"","permalink":"https://tedmax100.github.io/2017/06/05/PixiJS-簡介/","excerpt":"PixiJS - PixiJs 簡介Pixi.js is a rendering library that will allow you to create rich, interactive graphics, cross platform applications, and games without having to dive into the WebGL API or deal with browser and device compatibility.","text":"PixiJS - PixiJs 簡介Pixi.js is a rendering library that will allow you to create rich, interactive graphics, cross platform applications, and games without having to dive into the WebGL API or deal with browser and device compatibility. PixiJS官網上的說明這是一個套件，能讓玩家創造出豐富的、互動的、跨平台的應用/遊戲。開發者不必深入理解WebGL的API或是處理瀏覽器的相容性問題的一個容易上手的套件。 利用texture(紋理)來準備遊戲圖形，使用Proton粒子引擎做到particle effect(粒子效果)，以及如何將Pixi整合到自己做的遊戲引擎中。當然它不只適用於遊戲，也能用來創建任何交互式的應用程式。 安裝小弟安裝學習的版本是V4.0.0直接使用官網提供的CDN載點Pixi Link 1234567891011121314&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt; &lt;script src=\"pixi.min.js\"&gt;&lt;/script&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; var type = \"WebGL\" if(!PIXI.utils.isWebGLSupported())&#123; type = \"canvas\" &#125; PIXI.utils.sayHello(type) &lt;/script&gt;&lt;/body&gt;","categories":[],"tags":[{"name":"JavaSCript","slug":"JavaSCript","permalink":"https://tedmax100.github.io/tags/JavaSCript/"},{"name":"Pixi","slug":"Pixi","permalink":"https://tedmax100.github.io/tags/Pixi/"}]},{"title":"JS30 - JavaScript Drum Kit","slug":"JS30-JavaScript-Drum-Kit","date":"2017-06-04T15:49:37.000Z","updated":"2020-12-20T07:56:16.169Z","comments":true,"path":"2017/06/04/JS30-JavaScript-Drum-Kit/","link":"","permalink":"https://tedmax100.github.io/2017/06/04/JS30-JavaScript-Drum-Kit/","excerpt":"","text":"#核心需求 根據鍵盤的KeyCode，來撥放對應的聲音 改變觸發的物件樣式 實現思維 在元素上綁定keydown event 對應事件的處理流程 給每個div元素綁定transitioned event 綁定事件 獲取所有classname為key的元素 去除樣式的事件處理流程 123windows.addEventListener('keydown', function(e)&#123; console.log(e);&#125;);","categories":[],"tags":[{"name":"JavaSCript","slug":"JavaSCript","permalink":"https://tedmax100.github.io/tags/JavaSCript/"},{"name":"JS30Day","slug":"JS30Day","permalink":"https://tedmax100.github.io/tags/JS30Day/"}]}]}